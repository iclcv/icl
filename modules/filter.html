
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Unary- and Binary Image Filters &#8212; ICL Manual</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Image In- and Output" href="io.html" />
    <link rel="prev" title="Basic Types for Image Processing" href="core.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="io.html" title="Image In- and Output"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="core.html" title="Basic Types for Image Processing"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ICL Manual</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../modules.html" accesskey="U">Modules</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <script src="../js/jquery.tools.min.js"></script>

<div id="sticky">
  <table class="sticky-table">
  <tr><td><div class="sticky-entry "id="sticky-1"/><a class="sticky-link" href="../modules/utils.html">utils</a></td></tr>
  <tr><td><div class="sticky-entry "id="sticky-2"/><a class="sticky-link" href="../modules/math.html">math</a></td></tr>
  <tr><td><div class="sticky-entry "id="sticky-3"/><a class="sticky-link" href="../modules/core.html">core</a></td></tr>
  <tr><td><div class="sticky-entry "id="sticky-4"/><a class="sticky-link" href="../modules/filter.html">filter</a></td></tr>
  <tr><td><div class="sticky-entry "id="sticky-5"/><a class="sticky-link"href="../modules/io.html">io</a></td></tr>
  <tr><td><div class="sticky-entry "id="sticky-6"/><a class="sticky-link"href="../modules/qt.html">qt</a></td></tr>
  <tr><td><div class="sticky-entry "id="sticky-7"/><a class="sticky-link"href="../modules/cv.html">cv</a></td></tr>
  <tr><td><div class="sticky-entry "id="sticky-8"/><a class="sticky-link"href="../modules/geom.html">geom</a></td></tr>
  <tr><td><div class="sticky-entry "id="sticky-9"/><a class="sticky-link"href="../modules/markers.html">marker</a></td></tr>
  <tr><td><div class="sticky-entry "id="sticky-10"/><a class="sticky-link"href="../modules/physics.html">physics</a></td></tr>
  <!--tr><td><div class="sticky-entry "id="sticky-10"/><a class="sticky-link"href="../extras/tutorial.html">tutorial</a></td></tr-->
  </tr>
  </table>
</div>
<style type="text/css">
  .sticky-table{
     float: right;
  }

  a.sticky-link{
     color: inherit;
     font-size: 12px;
  }

  a.sticky-link:hover{
     text-decoration: none;
     color: inherit;
  }


  .sticky-entry{
     width: 12px;
     height: 12px;
     float: right;
     border-left: 1px solid rgb(200,200,200);
     border-top: 1px solid rgb(200,200,200);
     border-right: 1px solid rgb(100,100,100);
     border-bottom: 1px solid rgb(100,100,100);

     border-radius: 4px;
     box-shadow: 2px 2px 5px rgba(0,0,0,0.6);
     border: 1px solid blue;
     background-color: transparent; /* white; */
     color: transparent;
  }
  .sticky-entry:hover{
     width: 40px;
     color: rgb(100,100,100);
     background-color: white;
     padding-left: 2px;
     box-shadow: 5px 5px 10px rgba(0,0,0,0.6);
  }
  .sticky-entry:active{
     box-shadow: 0px 0px 0px transparent;
     border-left: 1px solid rgb(70,70,70);
     border-top: 1px solid rgb(70,70,70);
     border-right: 1px solid white;
     border-bottom: 1px solid white;
  }

  #sticky-1{ border: 1px solid rgb(255,0,255); }
  #sticky-2{ border: 1px solid rgb(255,0,0); }
  #sticky-3{ border: 1px solid rgb(255,128,0); }
  #sticky-4{ border: 1px solid rgb(255,255,0); }
  #sticky-5{ border: 1px solid rgb(168,255,0); }
  #sticky-6{ border: 1px solid rgb(0,200,255); }
  #sticky-7{ border: 1px solid rgb(0,255,0); }
  #sticky-8{ border: 1px solid rgb(0,50,255); }
  #sticky-9{ border: 1px solid rgb(0,0,255); }
  #sticky-10{ border: 1px solid rgb(128,0,255); }

  #sticky{
    line-height: 8px;
    margin-left:auto;
    position:absolute;
    right:0px;
    top:100px;
    padding:2px;
    padding-right:0px;
    padding-left:1px;
    position: fixed;
    background: transparent url(../_static/images/dash.png);
    width: 33px;
    height: 193px;
    top: 99px;
    padding-top: 12px;
  }

</style>

<script type="text/javascript">

$('#sticky-1').bind('click',function(e){ location = '../modules/utils.html';  });
$('#sticky-2').bind('click',function(e){ location = '../modules/math.html';  });
$('#sticky-3').bind('click',function(e){ location = '../modules/core.html';  });
$('#sticky-4').bind('click',function(e){ location = '../modules/filter.html';  });
$('#sticky-5').bind('click',function(e){ location = '../modules/io.html';  });
$('#sticky-6').bind('click',function(e){ location = '../modules/cv.html';  });
$('#sticky-7').bind('click',function(e){ location = '../modules/qt.html';  });
$('#sticky-8').bind('click',function(e){ location = '../modules/geom.html';  });
$('#sticky-9').bind('click',function(e){ location = '../modules/markers.html';  });
$('#sticky-10').bind('click',function(e){ location = '../modules/physics.html.html';  });

/* Script by: www.jtricks.com
 * Version: 20071127
 * Latest version:
 * www.jtricks.com/javascript/navigation/fixed_menu.html
 */
fixedMenuId = 'sticky';

var fixedMenu = {
    hasInner: typeof(window.innerWidth) == 'number',
    hasElement: document.documentElement != null
       && document.documentElement.clientWidth,

    menu: document.getElementById
        ? document.getElementById(fixedMenuId)
        : document.all
          ? document.all[fixedMenuId]
          : document.layers[fixedMenuId]
};

fixedMenu.computeShifts = function(){
    fixedMenu.shiftX = fixedMenu.hasInner
        ? pageXOffset
        : fixedMenu.hasElement
          ? document.documentElement.scrollLeft
          : document.body.scrollLeft;
    if (fixedMenu.targetLeft > 0){
        fixedMenu.shiftX += fixedMenu.targetLeft;
    }else{
        fixedMenu.shiftX +=
            (fixedMenu.hasElement
              ? document.documentElement.clientWidth
              : fixedMenu.hasInner
                ? window.innerWidth - 20
                : document.body.clientWidth)
            - fixedMenu.targetRight
            - fixedMenu.menu.offsetWidth;
    }

    fixedMenu.shiftY = fixedMenu.hasInner
        ? pageYOffset
        : fixedMenu.hasElement
          ? document.documentElement.scrollTop
          : document.body.scrollTop;
    if (fixedMenu.targetTop > 0){
        fixedMenu.shiftY += fixedMenu.targetTop;
    }else{
        fixedMenu.shiftY +=
            (fixedMenu.hasElement
            ? document.documentElement.clientHeight
            : fixedMenu.hasInner
              ? window.innerHeight - 20
              : document.body.clientHeight)
            - fixedMenu.targetBottom
            - fixedMenu.menu.offsetHeight;
    }
};

fixedMenu.moveMenu = function(){
    fixedMenu.computeShifts();

    if (fixedMenu.currentX != fixedMenu.shiftX
        || fixedMenu.currentY != fixedMenu.shiftY){
        fixedMenu.currentX = fixedMenu.shiftX;
        fixedMenu.currentY = fixedMenu.shiftY;

        if (document.layers){
            fixedMenu.menu.left = fixedMenu.currentX;
            fixedMenu.menu.top = fixedMenu.currentY;
        }else{
            fixedMenu.menu.style.left = fixedMenu.currentX + 'px';
            fixedMenu.menu.style.top = fixedMenu.currentY + 'px';
        }
    }

    fixedMenu.menu.style.right = '';
    fixedMenu.menu.style.bottom = '';
};

fixedMenu.floatMenu = function(){
    fixedMenu.moveMenu();
    setTimeout('fixedMenu.floatMenu()', 20);
};

// addEvent designed by Aaron Moore
fixedMenu.addEvent = function(element, listener, handler){
    if(typeof element[listener] != 'function' ||
       typeof element[listener + '_num'] == 'undefined'){
        element[listener + '_num'] = 0;
        if (typeof element[listener] == 'function'){
            element[listener + 0] = element[listener];
            element[listener + '_num']++;
        }
        element[listener] = function(e){
            var r = true;
            e = (e) ? e : window.event;
            for(var i = 0; i < element[listener + '_num']; i++)
                if(element[listener + i](e) === false)
                    r = false;
            return r;
        }
    }

    //if handler is not already stored, assign it
    for(var i = 0; i < element[listener + '_num']; i++)
        if(element[listener + i] == handler)
            return;
    element[listener + element[listener + '_num']] = handler;
    element[listener + '_num']++;
};

fixedMenu.supportsFixed = function(){
    var testDiv = document.createElement("div");
    testDiv.id = "testingPositionFixed";
    testDiv.style.position = "fixed";
    testDiv.style.top = "0px";
    testDiv.style.right = "0px";
    document.body.appendChild(testDiv);
    var offset = 1;
    if (typeof testDiv.offsetTop == "number"
        && testDiv.offsetTop != null
        && testDiv.offsetTop != "undefined")
    {
        offset = parseInt(testDiv.offsetTop);
    }
    if (offset == 0)
    {
        return true;
    }

    return false;
};

fixedMenu.init = function(){
    if (fixedMenu.supportsFixed())
        fixedMenu.menu.style.position = "fixed";
    else
    {
        var ob =
            document.layers
            ? fixedMenu.menu
            : fixedMenu.menu.style;

        fixedMenu.targetLeft = parseInt(ob.left);
        fixedMenu.targetTop = parseInt(ob.top);
        fixedMenu.targetRight = parseInt(ob.right);
        fixedMenu.targetBottom = parseInt(ob.bottom);

        if (document.layers)
        {
            menu.left = 0;
            menu.top = 0;
        }
        fixedMenu.addEvent(window, 'onscroll', fixedMenu.moveMenu);
        fixedMenu.floatMenu();
    }
};

fixedMenu.addEvent(window, 'onload', fixedMenu.init);

jQuery(document).ready(function() {

  console.log('executing java-script-based document upgrade');

  $('.reference.external').after(function() {

    this.href = this.href.replace('doc/icl-manual/doc/icl-api/','doc/icl-api/');

    var href = this.href;
    var text = this.text;

    var package = 'unknown';
    var type = 'other';

    if( this.text.match('^ICL.*\.h$') ){ // we have a header file
       var m = this.text.match('ICL(\[^/\]*)/.*');
       if( m ){
          package = m[1].toLowerCase();
          type = "header";
       }
    }else if(this.text.match('.*\.h$')){
       package  = 'unknown';
       type = "header";
    }


    var packages = [ 'utils', 'math', 'core', 'filter', 'io', 'qt', 'cv', 'geom', 'markers', 'physics' ];
    var groupLUT = [ ['TIME', 'EXCEPT', 'THREAD', 'RANDOM', 'UTILS' , 'PA', 'XML', 'STRUTILS', 'FUNCTION', 'BASIC__TYPES'],
                     ['LINALG'],
                     ['TYPES', 'GENERAL', 'IMAGE'],
                     ['UNARY', 'BINARY', 'AFFINE', 'NBH', 'INPLACE' ],
                     ['DC_G', 'UTILS_G', 'FILEIO_G', 'MOVIE_FILE_G', 'V4L_G', 'GIGE_G'],
                     ['COMMON', 'HANDLES', 'UNCOMMON'],
                     ['G_RD'],
                     [],
                     ['PLUGINS']
                   ];

    if(package == 'unknown'){
      for(var i=0;i<10;++i){
        if( href.match('.*/namespaceicl_1_1'+packages[i]+'\.html') ){
          package = packages[i];
          // could be a function or a namespace
          if(this.text.match('.*'+packages[i]+'$')){
             type = 'namespace';
          }else if(this.text[0] > 'A' && this.text[0] < 'Z'){
             type = 'global type';
          }else{
             type = 'global function';
          }
          break;
        }
        if( href.match('.*icl_1_1'+packages[i]+'.*') ){
          package = packages[i];
          break;
        }
      }
    }
    if(package == 'unknown'){
      var res = href.match('.*group__(\[^.\]*).*')
      if( res ){
         var groupName = res[1];
         for(var i=0;i<9;++i){
            if(groupLUT[i].indexOf(groupName) != -1){
                package = packages[i];
                break;
            }
         }
         var res2 = this.text.match('.*::(\[^:\]*)$');
         var t = "???";
         if(res2){
            t = res2[1];
         }else{
            t = this.text;
         }
         if(t[0] > 'A' && t[0] < 'Z'){
            type = "grouped type";
         }else{
            if(groupName == "TYPES"){
              type = "core type";
            }else if(groupName == "BASIC__TYPES"){
              type = "basic type";
            }else{
              type = "grouped func.";
            }
         }
       }
    }

    if(href.match('.*classicl.*')){
       if(href.match('.*#\[0-9a-f\]*')){
         type = 'class: method';
       }else{
         type = 'class';
       }
    }else if(href.match('.*structicl.*')){
       if(href.match('.*#\[0-9a-f\]*')){
         type = 'struct: method';
       }else{
         type = 'struct';
       }
    }
    if(package == "unknown" && href.match('.*namespaceicl.*')){
      // very special treatment
      return '<div class="tooltip">the <b>icl</b> namespace is used for all '
            +'modules.</div>';

    }else if(package != "unknown"){
      return '<div class="tooltip">'
         + '<a href="../modules/'+package+'.html">'
         + '<img title="manual: '+package+' module" width="110px" src="../_images/'+package+'1.png"></img>'
         + '</a>'
         + '<br/>' + 'Type:   <b>' + type + '</b>'
         + '</div>';
    }else{
      return '<div class="tooltip">'
         + 'Unable to locate package'
         + '<br/>' + 'Type:   <b>' + type + '</b>'
         + '</div>';
    }

    //return '<div class="tooltip">' + 'TEST TEST TEST' + '</div>';
  });

  $('.reference.external').tooltip({
    position: "top center",
    opacity: 0.95,
    effect: 'fade',
    offset: [7,33]
  });

});
</script>
<style type="text/css">

  .tooltip {
    display:none;
    background: transparent url(../_static/images/tooltip.png);
    font-size:13px;
    height:80px;
    width:131px;
    padding:10px;
    color: #555;
    line-height: 20px;
  }
  a.reference.external {
    color: rgb(20,60,100);
    padding: 2px;
    padding-left: 6px;
    padding-right: 5px;
  }
  a.reference.external:hover {
    color: rgb(20,60,100);
    border: 1px solid rgba(0,0,0,0.3);
    border-radius: 5px;
    box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
    padding: 2px;
    padding-left: 5px;
    padding-right: 4px;
    text-decoration: none;
  }

 div.body{
    border-top-left-radius: 15px;
    border-bottom-left-radius: 15px;
    border: 1px solid rgb(110,110,110);
    box-shadow: 0px 0px 50px rgba(0,0,0,0.7);
  }

  div.body h1{
    border-top-left-radius: 15px;
    box-shadow: 0px 2px 0px rgba(0,0,0,0.4);
  }


  div.body h1, div.body h2, div.body h3, div.body h4{
    margin-bottom: -8px;
    background-repeat: no-repeat;
    margin-left: -41px;
    box-shadow: none;
    border: none;
    opacity: 1;
    color: rgb(230,230,230);
    height: 44px;
    padding-top: 4px;
  }

  div.body h1{
    padding-top: 7px;
    background: transparent url(../_static/images/h1.png);
    margin-top: 8px;
    border-radius: 0px;
    height: 57px;
    padding-top: 3px;
  }

  div.body h2{
    padding-top: 7px;
    background: transparent url(../_static/images/h2.png);
    height: 52px;
  }

  div.body h3{
    background: transparent url(../_static/images/h3.png);
  }

  div.body h4{
    padding-top: 5px;
    height: 42px;
    background: transparent url(../_static/images/h4.png);
    color: rgb(60,60,60);
  }

  div.sphinxsidebar{
    font-size: 80%;
  }

  table.docutils td, table.docutils th{
    border: 0px;
  }
  th {
     background-color: #0F67A1;
     color: rgb(220,220,220);
  }

  img[alt="shadow"]{
     box-shadow: 5px 5px 12px rgba(0,0,0,0.3);
  }

  a.headerlink {
     color: rgb(230,230,230);
  }
  a.headerlink:hover{
     color: white;
     background: transparent;
  }

  h4:hover > a.headerlink {
     color: rgb(60,60,60);
  }
  h4 > a.headerlink {
     color: rgb(90,90,90);
  }
  div.related ul{
     background: rgba(60, 60, 60, 0);
     background-image: url(../_static/images/stripes3.png);
     background-position-x: 2px;
  }
  div.documentwrapper, div.footer {
     background-image: url(../_static/images/stripes1.png);
  }

  img.logo{
     background-color: white;
     border-radius: 8px;
     border: 1px solid #A0A0A0;
     box-shadow: 5px 5px 20px rgba(0,0,0,0.4);
     padding: 8px;
  }

  div.sphinxsidebar #searchbox input[type="text"] {
     width: 160px;
  }

</style><div class="section" id="unary-and-binary-image-filters">
<span id="filter"></span><h1>Unary- and Binary Image Filters<a class="headerlink" href="#unary-and-binary-image-filters" title="Permalink to this headline">¶</a></h1>
<img alt="../_images/filter1.png" src="../_images/filter1.png" />
<p>The <strong>ICLFilter</strong> package provides a large variety of set classes for
image filtering. First of all, we recommend to start with
<a class="reference internal" href="#filter-what"><span class="std std-ref">What are Image Filters?</span></a> in order to get an overview of our idea of image
filters. Once you got the difference between unary- and binary
operators, the grouped table of contents (<a class="reference internal" href="#filter-toc"><span class="std std-ref">below</span></a>)
will help you to find the filter you are searching for. Please note
that the grouping that we performed is somehow arbitrary. The use of
image filters is also described in a dedicated tutorial chapter
(<a class="reference internal" href="../tutorials/using-filters.html#tut-using-filters"><span class="std std-ref">How to use Image Filters</span></a>)</p>
<div class="section" id="table-of-contents">
<span id="filter-toc"></span><h2>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="#filter-what"><span class="std std-ref">What are Image Filters?</span></a><ul>
<li><a class="reference internal" href="#filter-cliptoroi"><span class="std std-ref">The Clip To ROI Property</span></a></li>
<li><a class="reference internal" href="#filter-checkonly"><span class="std std-ref">The Check Only Property</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#filter-unary"><span class="std std-ref">Unary Operators</span></a><ul>
<li><a class="reference internal" href="#filter-affine"><span class="std std-ref">Affine and Warp Operators</span></a></li>
<li><a class="reference internal" href="#filter-neighbor"><span class="std std-ref">Neighborhood Operators</span></a></li>
<li><a class="reference internal" href="#filter-inplace"><span class="std std-ref">Inplace Operators</span></a></li>
<li><a class="reference internal" href="#filter-lut"><span class="std std-ref">Lookup-Table Operators</span></a></li>
<li><a class="reference internal" href="#filter-color"><span class="std std-ref">Color Related Operators</span></a></li>
<li><a class="reference internal" href="#filter-others"><span class="std std-ref">General Operators</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#filter-binary"><span class="std std-ref">Binary Operators</span></a></li>
<li><a class="reference internal" href="#filter-tools"><span class="std std-ref">Other Utility Classes</span></a></li>
</ul>
</div>
<div class="section" id="what-are-image-filters">
<span id="filter-what"></span><h2>What are Image Filters?<a class="headerlink" href="#what-are-image-filters" title="Permalink to this headline">¶</a></h2>
<p>In a most general view of image filters, a <em>filter</em> is a <em>black box</em>
that has a number of image inputs, lets say <em>N</em>, and a number of image
outputs, <em>M</em>. Even though this definition provides a very generic
interface for image filters, it is still not very feasible. Most
common filters (e.g. binary image operations, linear filters or
neighborhood operations) only need a single input and a single output
image. Another larger group are filters with exactly two input and one
output images (e.g. arithmetical/logical per-pixel image operations or
image comparison filters).  In order to avoid a large computational
overhead arising of a <em>too general interface</em>, ICL basically supports
two dedicated image filter interfaces for the above mentioned <em>1 to 1</em>
and <em>2 to 1</em> input-output combinations. To obviate further
misunderstandings, we call these filter sets <em>Unary-</em> and <em>Binary</em>
operators – or short, <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html">UnaryOp</a> and <a class="reference external" href="../icl-api/classicl_1_1filter_1_1BinaryOp.html">BinaryOp</a>.  Each of
these sets is represented by an equally named C++-class-interface,
which is inherited by all implemented filters in that group.</p>
<div class="section" id="the-clip-to-roi-property">
<span id="filter-cliptoroi"></span><h3>The <em>Clip To ROI</em> Property<a class="headerlink" href="#the-clip-to-roi-property" title="Permalink to this headline">¶</a></h3>
<p>Each <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html">UnaryOp</a> instance can be set up with this boolean flag. If
<em>clip to ROI</em> is active, the result images will always be adapted to
the size of the source images ROI – or, in case of
<a class="reference internal" href="#filter-neighbor"><span class="std std-ref">neighborhood operations</span></a> even slightly smaller.
If <em>clip to ROI</em> is  deactivated, the result image will become
as large as the source image, but only its ROI pixels will be set.
(see <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html#a4049bde609a7a7f69b96f1132883850c">UnaryOp::setClipToROI</a> and <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html#a98d430af39eb86ab258c322bc0dfcb44">UnaryOp::getClipToROI</a>)</p>
</div>
<div class="section" id="the-check-only-property">
<span id="filter-checkonly"></span><h3>The <em>Check Only</em> Property<a class="headerlink" href="#the-check-only-property" title="Permalink to this headline">¶</a></h3>
<p>This property can also be set of each <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html">UnaryOp</a> instance. If it
is activated, the destination image will only be checked for
compatible parameters rather then adapted.  (see
<a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html#a7241c8bb781b5dbc231dccc413f8468f">UnaryOp::setCheckOnly</a> and <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html#adb26ac7c625fbe23c0b0674fe067e49f">UnaryOp::getCheckOnly</a>)</p>
</div>
</div>
<div class="section" id="unary-operators">
<span id="filter-unary"></span><h2>Unary Operators<a class="headerlink" href="#unary-operators" title="Permalink to this headline">¶</a></h2>
<p>As discussed in <a class="reference internal" href="#filter-what"><span class="std std-ref">What are Image Filters?</span></a>, unary operators have use a single
input and a single output image for their operation. The
<a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html">filter::UnaryOp</a> class interface required the purely virtual
method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">const</span> <span class="n">core</span><span class="p">::</span><span class="n">ImgBase</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="n">ImgBase</span> <span class="o">**</span><span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
<p>to be implemented. The method must applied the operation on the given
source image and writes the result to the given destination image,
whose parameters, such as size, number of channels and also its
<a class="reference external" href="../icl-api/group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">core::depth</a>, is always automatically adapted by the filter. The
destination image is passed as <em>pointer-pointer</em> to enable the filter
to even adapt its depth by reallocation (see also
<a class="reference internal" href="core.html#core-global-image-ensurecompatible"><span class="std std-ref">core::ensureCompatible</span></a>,
<a class="reference internal" href="core.html#core-global-image-bpp"><span class="std std-ref">core::bpp</span></a> and
<a class="reference internal" href="../tutorials/imgbase-ptrptrs.html#tut-imgbase-ptrptrs"><span class="std std-ref">About the Use of ImgBase**s</span></a>).  The <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html#a40fda384376701c2ee5d1c52eb29ce06">UnaryOp::apply</a> method is kept
as general as possible, leaving the managing of the destination image
to the user. However, this is usually very easy, since
<a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html#a40fda384376701c2ee5d1c52eb29ce06">UnaryOp::apply</a> is able to automatically instantiate a
destination image at the given address</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><div class="first last highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ICLCore/Img.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ICLUtils/Random.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ICLQt/Quick.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ICLFilter/UnaryCompareOp.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">icl</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">icl</span><span class="o">::</span><span class="n">utils</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="c1">// VGA-sized image</span>
  <span class="n">core</span><span class="o">::</span><span class="n">Img8u</span> <span class="n">random</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">512</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// fill with random values</span>
  <span class="n">random</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">URand</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">));</span>

  <span class="c1">// create filter</span>
  <span class="n">filter</span><span class="o">::</span><span class="n">UnaryCompareOp</span> <span class="n">cmp</span><span class="p">(</span><span class="s">&quot;&gt;&quot;</span><span class="p">,</span><span class="mi">128</span><span class="p">);</span>

  <span class="c1">// create destination image</span>
  <span class="n">ImgBase</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// apply (will instantiate dst)</span>
  <span class="n">cmp</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">random</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dst</span><span class="p">);</span>

  <span class="c1">// show the image</span>
  <span class="n">show</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</td>
<td><a class="first last reference internal image-reference" href="../_images/filters-1.png"><img alt="shadow" src="../_images/filters-1.png" style="width: 307.2px; height: 307.2px;" /></a>
</td>
</tr>
</tbody>
</table>
<p>In order to simplify the use of filters, an extra apply function is
provided, that uses an internally managed destination image for
calling <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html#a40fda384376701c2ee5d1c52eb29ce06">UnaryOp::apply(const core::ImgBase *operand1,
core::ImgBase **dst)</a>, which is returned by the method. The allows us
to also nest several filters by just passing the result of one filter
to the apply method of another one. Additionally, the <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html">UnaryOp</a>
function operator can also be used instead of apply. The following
example demonstrates how to concatenate filters and it also gives an
example for a custom filter.</p>
<table border="1" class="docutils">
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><div class="first last highlight-c++ notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ICLCore/Img.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ICLUtils/Random.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ICLQt/Quick.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ICLFilter/UnaryCompareOp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ICLFilter/MedianOp.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ICLFilter/ConvolutionOp.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">icl</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">icl</span><span class="o">::</span><span class="n">utils</span><span class="p">;</span>

<span class="c1">// custom filter</span>
<span class="k">struct</span> <span class="nl">NormRangeOp</span> <span class="p">:</span> <span class="k">public</span> <span class="n">UnaryOp</span><span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">apply</span><span class="p">(</span><span class="k">const</span> <span class="n">ImgBase</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">ImgBase</span> <span class="o">**</span><span class="n">dst</span><span class="p">){</span>
    <span class="n">src</span><span class="o">-&gt;</span><span class="n">deepCopy</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
    <span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">normalizeAllChannels</span><span class="p">(</span><span class="n">Range64f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="c1">// demo image</span>
  <span class="n">core</span><span class="o">::</span><span class="n">Img32f</span> <span class="n">image</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="s">&quot;lena&quot;</span><span class="p">);</span>

  <span class="c1">// median filter</span>
  <span class="n">filter</span><span class="o">::</span><span class="n">MedianOp</span> <span class="n">med</span><span class="p">(</span><span class="n">Size</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">));</span>

  <span class="c1">// laplace filter</span>
  <span class="n">filter</span><span class="o">::</span><span class="n">ConvolutionOp</span> <span class="n">lap</span><span class="p">(</span><span class="n">ConvolutionKernel</span><span class="o">::</span><span class="n">laplace5x5</span><span class="p">);</span>

  <span class="c1">// sobel filter</span>
  <span class="n">filter</span><span class="o">::</span><span class="n">ConvolutionOp</span> <span class="n">sob</span><span class="p">(</span><span class="n">ConvolutionKernel</span><span class="o">::</span><span class="n">sobelX5x5</span><span class="p">);</span>

  <span class="c1">// custom operator (normalize range to [0,255])</span>
  <span class="n">NormRangeOp</span> <span class="n">nor</span><span class="p">;</span>

  <span class="c1">// nested call, identical to</span>
  <span class="c1">// *nor.apply(lab.apply(sob.apply(med.apply(image))));</span>
  <span class="k">const</span> <span class="n">ImgBase</span> <span class="o">&amp;</span><span class="n">result</span> <span class="o">=</span> <span class="n">nor</span><span class="p">(</span><span class="n">lap</span><span class="p">(</span><span class="n">sob</span><span class="p">(</span><span class="n">med</span><span class="p">(</span><span class="n">image</span><span class="p">))));</span>

  <span class="c1">// show the image</span>
  <span class="n">show</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</td>
<td><a class="first last reference internal image-reference" href="../_images/filters-2.png"><img alt="shadow" src="../_images/filters-2.png" style="width: 300.0px; height: 300.0px;" /></a>
</td>
</tr>
</tbody>
</table>
<div class="section" id="affine-and-warp-operators">
<span id="filter-affine"></span><h3>Affine and Warp Operators<a class="headerlink" href="#affine-and-warp-operators" title="Permalink to this headline">¶</a></h3>
<p>In this section, we grouped unary operators, that <em>move</em> pixels in general. In
particular, the list contains so called <em>affine operators</em> that use an affine
3x3 matrix to estimate how pixels are to be moved.</p>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1BaseAffineOp.html">filter::BaseAffineOp</a></p>
<blockquote>
<div>Base class interface</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1AffineOp.html">filter::AffineOp</a></p>
<blockquote>
<div>General affine operator. Here, several affine operation can be concatenated
resulting, due to the associative property of the operations, in a single
3x3 matrix that is then applied. By these means, e.g. rotations around a certain
anchor positions can be realized.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1MirrorOp.html">filter::MirrorOp</a></p>
<blockquote>
<div>This operator allows for mirroring images along horizontal, vertical or both
axes at once</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1RotateOp.html">filter::RotateOp</a></p>
<blockquote>
<div>Restricts the generic <a class="reference external" href="../icl-api/classicl_1_1filter_1_1AffineOp.html">AffineOp</a> to allow rotations only</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1ScaleOp.html">filter::ScaleOp</a></p>
<blockquote>
<div>Restricts the generic <a class="reference external" href="../icl-api/classicl_1_1filter_1_1AffineOp.html">AffineOp</a> to allow scaling only</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1TranslateOp.html">filter::TranslateOp</a></p>
<blockquote>
<div>Restricts the generic <a class="reference external" href="../icl-api/classicl_1_1filter_1_1AffineOp.html">AffineOp</a> to allow translations only</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1WarpOp.html">filter::WarpOp</a></p>
<blockquote>
<div><p>The <a class="reference external" href="../icl-api/classicl_1_1filter_1_1WarpOp.html">WarpOp</a> uses a <em>warp-table</em> for estimating the pixel
displacement rather than an affine matrix. The warp-table is a
<a class="reference external" href="../icl-api/group__TYPES.html#ga6441bd8fa2cbf25adb6dec760390d8ed">core::Img32f</a> image with two channels <em>Cx</em> and <em>Cy</em>. Cx(x,y)
contains the source X-position of the resulting images pixel (x,y),
Cy the Y-position resp. Image warping is used, when a functional
description of the pixel displacement is not given, or to complex to
compute for each image pixel in real-time. In particular, this is
used for image undistortion.</p>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">As soon as the image undistortion environment is reimplemented, we need
to link this here</p>
</div>
</div></blockquote>
</div>
<div class="section" id="neighborhood-operators">
<span id="filter-neighbor"></span><h3>Neighborhood Operators<a class="headerlink" href="#neighborhood-operators" title="Permalink to this headline">¶</a></h3>
<p>Neighborhood operators are filters, that use not only one, but also
the neighbor pixels of in the source image to estimate the pixel value
of the destination image. A very prominent example are linear filter
– here called <a class="reference external" href="../icl-api/classicl_1_1filter_1_1ConvolutionOp.html">ConvolutionOp</a>. A very important aspect for the
neighborhood operators is how the image border pixels, for which no
complete neighborhood exists, are handled. Dependent on the setting of
the <a class="reference internal" href="#filter-cliptoroi"><span class="std std-ref">The Clip To ROI Property</span></a>, the destination image will either become
smaller or the border pixels will not be processed.</p>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1NeighborhoodOp.html">filter::NeighborhoodOp</a></p>
<blockquote>
<div>Base class interface, that overwrites. e.g. the destination image adation
methods.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1ConvolutionOp.html">filter::ConvolutionOp</a></p>
<blockquote>
<div><p>The <a class="reference external" href="../icl-api/classicl_1_1filter_1_1ConvolutionOp.html">ConvolutionOp</a> implements general image convolution. The
image is convolved with a so called <a class="reference external" href="../icl-api/structicl_1_1filter_1_1ConvolutionKernel.html">filter::ConvolutionKernel</a>,
which is represented by an extra class. The Kernel can either be
a common predefined one or an arbitrarily custom one. The predefined
kernels, such as e.g. a <em>sobel X</em> kernel are internally hard-coded and
therefore much faster.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The IPP library provides a very high performace optimization here</p>
</div>
</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1DynamicConvolutionOp.html">filter::DynamicConvolutionOp</a></p>
<blockquote>
<div>Uses an <a class="reference external" href="../icl-api/classicl_1_1core_1_1Img.html">core::Img</a>-ROI as convolution kernel</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1MorphologicalOp.html">filter::MorphologicalOp</a></p>
<blockquote>
<div><p>Morphological or Hit-or-Miss transformations are also very common in
digital image processing. It implements a set of common operations,
such as <em>erosion</em>, <em>dilatation</em>, <em>opening</em> and <em>closing</em>, but also
custom masks can used. The predefined operations are usually much
faster.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The IPP library provides a very high performace optimization here</p>
</div>
</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1WienerOp.html">filter::WienerOp</a></p>
<blockquote>
<div>The wiener image operator is defined as optimal de-noise filter.
It is only provided in case of having Intel IPP support.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1GaborOp.html">filter::GaborOp</a></p>
<blockquote>
<div>Gabor-filter and <em>Gabor jets</em> are very commonly used in image
processing, for several proofs.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1MedianOp.html">filter::MedianOp</a></p>
<blockquote>
<div>The median filter is known as an edge preserving filter for noise
reduction. It basically sorts all neighborhood source pixels values
into a 1D-list <strong>L</strong> of size <strong>n</strong> and sets the result pixel to
<strong>L[n/2]</strong> (the median element of this list). However, it is worth
mention, that usually implementations provide the same result
much more efficiently</div></blockquote>
</div>
<div class="section" id="inplace-operators">
<span id="filter-inplace"></span><h3>Inplace Operators<a class="headerlink" href="#inplace-operators" title="Permalink to this headline">¶</a></h3>
<p>Inplace operators allow for memory throughput optimization by storing
the processing result directly in the source image. However, this
is not feasible for each operation. So far, we implemented this feature
for the following operators.</p>
<p><strong>icl::filter::InplaceOp</strong></p>
<blockquote>
<div><p>General interface class. The <a class="reference external" href="../icl-api/classicl_1_1filter_1_1InplaceOp.html#aab001e7f1513ba07bad5c7e9a368532a">InplaceOp::apply</a> method gets an un**const**
<a class="reference external" href="../icl-api/classicl_1_1core_1_1ImgBase.html">core::ImgBase</a><strong>*</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">core</span><span class="p">::</span><span class="n">ImageBase</span> <span class="o">*</span><span class="n">srcDst</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1InplaceArithmeticalOp.html">filter::InplaceArithmeticalOp</a></p>
<blockquote>
<div>Aritmetical operations, such like each pixel plus 5 or divide each
by 2.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1InplaceLogicalOp.html">filter::InplaceLogicalOp</a></p>
<blockquote>
<div>Logical operations, such as each pixel is binary <em>ored</em> with a mask.</div></blockquote>
</div>
<div class="section" id="lookup-table-operators">
<span id="filter-lut"></span><h3>Lookup-Table Operators<a class="headerlink" href="#lookup-table-operators" title="Permalink to this headline">¶</a></h3>
<p>Here, a lookup table is used to assign each pixel a new
value.un-const**. In order to limit the lookup table size, this is
however only supported for <a class="reference external" href="../icl-api/group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">core::Img8u</a> images.</p>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1LUTOp.html">filter::LUTOp</a></p>
<blockquote>
<div>Basic LUT-operation implementation, that uses a simple
<strong>std::vector&lt;icl8u&gt;</strong> as LUT.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1geom_1_1SoftPosit.html#a8aae68ce37660706cb7bd4cf1e925350">filter::LUTOp3Channel</a></p>
<blockquote>
<div>This operator creates a 24bit LUT-index by combining a 3-channel
image’s pixels. It also allows for using less the 8bit per channel
(by no regarding the lesser significant bits) in order become
faster and less memory consuming.</div></blockquote>
</div>
<div class="section" id="color-related-operators">
<span id="filter-color"></span><h3>Color Related Operators<a class="headerlink" href="#color-related-operators" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1ColorDistanceOp.html">filter::ColorDistanceOp</a></p>
<blockquote>
<div>This operator creates a distance map to a given reference color.
Optionally, the distance map can be binarized internally.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1ColorSegmentationOp.html">filter::ColorSegmentationOp</a></p>
<blockquote>
<div>This is a very complex operator that allows for high-performance
LUT base color segmentation. It is used as fundamental component
of the <strong>icl-color-segmentation</strong> application. Please refer to the
API documentation for more details.</div></blockquote>
</div>
<div class="section" id="general-operators">
<span id="filter-others"></span><h3>General Operators<a class="headerlink" href="#general-operators" title="Permalink to this headline">¶</a></h3>
<p>This section contains all operators, that did not obviously belong
to one of the other section.</p>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOpPipe.html">filter::UnaryOpPipe</a></p>
<blockquote>
<div>Rather old utility class, that can be used create a list of
filters where each filter uses its predecessors output as input.
The <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOpPipe.html">UnaryOpPipe</a> also implements the <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html">UnaryOp</a> interface
and it provides access to all intermediate images.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1CannyOp.html">filter::CannyOp</a></p>
<blockquote>
<div>IPP based implementation of the canny edge detector. Here, no
C++ fallback is available (IPP only)</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1ChamferOp.html">filter::ChamferOp</a></p>
<blockquote>
<div><em>Chamfering</em> is used for approximating the creation of <em>Euclidean
Distance Maps (EDMs)</em>. Here, an image is originally filled with
black, <em>containing only a small percentage of white initial
pixels. The EDM then defined for each pixel the euclidean distance
to the nearest white pixel.  The process is used in a model matching
process called *ChamferMatching</em>, which is also implemented by
this class.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1FFTOp.html">filter::FFTOp</a></p>
<blockquote>
<div>Fast Fourier Transform operator</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1IFFTOp.html">filter::IFFTOp</a></p>
<blockquote>
<div>Inverse Fast Fourier Transform operator</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1IntegralImgOp.html">filter::IntegralImgOp</a></p>
<blockquote>
<div>Integral images, originally introduced by Viola and Jones define
the numerical 2D integral of the image function. The integral
image value at location (x,y) is defined by the sum of pixel values
upper left of (x,y) in the source image.
The integral image can be used to compute <em>Haar-Like-Features</em>, but
also for efficient real-time local thresholding.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1LocalThresholdOp.html">filter::LocalThresholdOp</a></p>
<blockquote>
<div><p>This local threshold operator implements three different local threshold
operations</p>
<ul class="simple">
<li>tiled threshold with linear interpolation</li>
<li>tiled threshold with nearest neighbor interpolation</li>
<li>a real local threshold using a neighborhood average as reference value</li>
</ul>
<p>For each of these operations, a global threshold is used that is
adapted for each pixel by looking at the average gray value in the
pixel neighborhood.</p>
</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1ThresholdOp.html">filter::ThresholdOp</a></p>
<blockquote>
<div><p>This operator is the origin for a strong misconception: When we usually
talk about image thresholding we think of an operation like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">source</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">128</span><span class="p">)){</span>
   <span class="n">destination</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
   <span class="n">destination</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However this is actually not a threshold, but a <em>image
comparison</em>-operations. The threshold operator clips the image’s
value range to a given interval</p>
</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryArithmeticalOp.html">filter::UnaryArithmeticalOp</a></p>
<blockquote>
<div>Here, basic aritmetical operations with constant values are
implemented</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryCompareOp.html">filter::UnaryCompareOp</a></p>
<blockquote>
<div>Actually, this is the operation, we most of the time think of, when
talking about image thresholding. It always results in a binary
<a class="reference external" href="../icl-api/group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a>-image.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryLogicalOp.html">filter::UnaryLogicalOp</a></p>
<blockquote>
<div>Here, pixel-wise logical operations are provided for the integer
image types <a class="reference external" href="../icl-api/group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> and <a class="reference external" href="../icl-api/group__TYPES.html#ga3f31ac233fa143556955add6015184f5">Img32s</a>. (<a class="reference external" href="../icl-api/group__TYPES.html#ga7ddf03d82e78b48a4c8a477f093eb769">Img16s</a> is
provided using conversion to <a class="reference external" href="../icl-api/group__TYPES.html#ga6441bd8fa2cbf25adb6dec760390d8ed">Img32f</a>).</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1WeightChannelsOp.html">filter::WeightChannelsOp</a></p>
<blockquote>
<div>Multiplies each image channel with a different constant</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1WeightedSumOp.html">filter::WeightedSumOp</a></p>
<blockquote>
<div>Multiplies each image channel with a different constant
and sums up the result. Mathematically, this is indentical to the
computation of the scalar product of each pixel color vector with
a given constant vector.</div></blockquote>
<dl class="docutils">
<dt><a class="reference external" href="../icl-api/classicl_1_1filter_1_1GradientImage.html">filter::GradientImage</a> Does not extend the <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html">UnaryOp</a></dt>
<dd><p class="first">interface, but it somehow works similar to the <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html">UnaryOp</a>. The
<a class="reference external" href="../icl-api/classicl_1_1filter_1_1GradientImage.html">GradientImage</a> can be used to determine an image gradient
image</p>
<ul class="simple">
<li>intensity</li>
<li>angle</li>
<li>x- and y-component</li>
</ul>
<p class="last">Internally, sobel filters are used</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="binary-operators">
<span id="filter-binary"></span><h2>Binary Operators<a class="headerlink" href="#binary-operators" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1BinaryOp.html">BinaryOp</a> instances behave very similar to the already
presented unary operators, except for the fact, that their
<a class="reference external" href="../icl-api/classicl_1_1filter_1_1BinaryOp.html#ada30e1d6fc4aa56060de7fcfd3aebe86">BinaryOp::apply</a> method get two instead of one source image
arguments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">apply</span><span class="p">(</span><span class="n">const</span> <span class="n">core</span><span class="p">::</span><span class="n">ImgBase</span> <span class="o">*</span><span class="n">src1</span><span class="p">,</span> <span class="n">const</span> <span class="n">core</span><span class="p">::</span><span class="n">ImgBase</span> <span class="o">*</span><span class="n">src2</span><span class="p">,</span><span class="n">core</span><span class="p">::</span><span class="n">ImgBase</span> <span class="o">**</span><span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<p>Binary operators also provide a function operator interface for are
more intuitive use.</p>
</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1BinaryOp.html">filter::BinaryOp</a></p>
<blockquote>
<div>Base class interface</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1BinaryArithmeticalOp.html">filter::BinaryArithmeticalOp</a></p>
<blockquote>
<div>This operator implements binary arithmetical operations such as pixel-wise
addition of two image.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1BinaryCompareOp.html">filter::BinaryCompareOp</a></p>
<blockquote>
<div>Pixel-wise logical comparison of two image, always resulting in a
<a class="reference external" href="../icl-api/group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a>-binary image</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1BinaryLogicalOp.html">filter::BinaryLogicalOp</a></p>
<blockquote>
<div>Pixel-wise logical operation</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1ProximityOp.html">filter::ProximityOp</a></p>
<blockquote>
<div><p>This class is used for proximity measurement, that defines a
pixel-wise similarity of two image. Here, the operand is always
referred to as the source image, while the second operand is
referred to as the pattern image.  Internally, the pattern image
is centered at every pixel location for a local comparison.</p>
<p>The class provides three <em>apply modes</em> that determines how to
deal with overlap of the pattern and the source image borders,
and also three different distance measurement metrics:</p>
<ul class="simple">
<li>square distance</li>
<li>cross correlation</li>
<li>normalized cross correlation</li>
</ul>
<p>The operator is only supported with Intel IPP, but here,
it is incredibly fast!</p>
</div></blockquote>
</div>
<div class="section" id="other-utility-classes">
<span id="filter-tools"></span><h2>Other Utility Classes<a class="headerlink" href="#other-utility-classes" title="Permalink to this headline">¶</a></h2>
<p>In this final section, the remaining tools are listed</p>
<p><a class="reference external" href="../icl-api/structicl_1_1filter_1_1ConvolutionKernel.html">filter::ConvolutionKernel</a></p>
<blockquote>
<div>Utility class for the <a class="reference external" href="../icl-api/classicl_1_1filter_1_1ConvolutionOp.html">ConvolutionOp</a></div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1OpROIHandler.html">filter::OpROIHandler</a></p>
<blockquote>
<div>Utility class for implementing the <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html">UnaryOp</a> featuers
<a class="reference internal" href="#filter-cliptoroi"><span class="std std-ref">The Clip To ROI Property</span></a> and <a class="reference internal" href="#filter-checkonly"><span class="std std-ref">The Check Only Property</span></a>.</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1ImageSplitter.html">filter::ImageSplitter</a></p>
<blockquote>
<div>Splits image horizontally into a set of shared-copies
for mutli threading (not well supported)</div></blockquote>
<p><a class="reference external" href="../icl-api/structicl_1_1filter_1_1UnaryOpWork.html">filter::UnaryOpWork</a></p>
<blockquote>
<div>Utility class for the deprecated <a class="reference external" href="../icl-api/classicl_1_1filter_1_1UnaryOp.html#abb4f655384cf2810b1ae3a7c69868207">UnaryOp::applyMT</a>-function</div></blockquote>
<p><a class="reference external" href="../icl-api/classicl_1_1filter_1_1ImageRectification.html">filter::ImageRectification</a></p>
<blockquote>
<div>Utility class to rectify images. Given a convex quardrangle, the
image patch is interpolated smoothly into a rectangular image of
given size</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Unary- and Binary Image Filters</a><ul>
<li><a class="reference internal" href="#table-of-contents">Table of Contents</a></li>
<li><a class="reference internal" href="#what-are-image-filters">What are Image Filters?</a><ul>
<li><a class="reference internal" href="#the-clip-to-roi-property">The <em>Clip To ROI</em> Property</a></li>
<li><a class="reference internal" href="#the-check-only-property">The <em>Check Only</em> Property</a></li>
</ul>
</li>
<li><a class="reference internal" href="#unary-operators">Unary Operators</a><ul>
<li><a class="reference internal" href="#affine-and-warp-operators">Affine and Warp Operators</a></li>
<li><a class="reference internal" href="#neighborhood-operators">Neighborhood Operators</a></li>
<li><a class="reference internal" href="#inplace-operators">Inplace Operators</a></li>
<li><a class="reference internal" href="#lookup-table-operators">Lookup-Table Operators</a></li>
<li><a class="reference internal" href="#color-related-operators">Color Related Operators</a></li>
<li><a class="reference internal" href="#general-operators">General Operators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#binary-operators">Binary Operators</a></li>
<li><a class="reference internal" href="#other-utility-classes">Other Utility Classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="core.html"
                        title="previous chapter">Basic Types for Image Processing</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="io.html"
                        title="next chapter">Image In- and Output</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="io.html" title="Image In- and Output"
             >next</a> |</li>
        <li class="right" >
          <a href="core.html" title="Basic Types for Image Processing"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">ICL Manual</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../modules.html" >Modules</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2006-2019, Christof Elbrechter, Michael Götting, Robert Haschke, Alexander Neumann.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>