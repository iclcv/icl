<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::core Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1core.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">icl::core Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1AbstractCanvas.html">AbstractCanvas</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1BayerConverter.html">BayerConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utiltity class for bayer pattern conversion.  <a href="classicl_1_1core_1_1BayerConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1CCLUT.html">CCLUT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility helper class for faster and more convenient access to single channel image data.  <a href="classicl_1_1core_1_1Channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1ChromaAndRGBClassifier.html">ChromaAndRGBClassifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combination classifier using RG-chroma. as well as RGB-thresholded reference color classifiation.  <a href="structicl_1_1core_1_1ChromaAndRGBClassifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1ChromaClassifier.html">ChromaClassifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifier interface using RG-chromaticity space and two parables.  <a href="structicl_1_1core_1_1ChromaClassifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Converter.html">Converter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General Image <a class="el" href="classicl_1_1core_1_1Converter.html" title="General Image Converter.">Converter</a>.  <a href="classicl_1_1core_1_1Converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1CvMatDelOp.html">CvMatDelOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility Delete Operator used within <a class="el" href="classicl_1_1core_1_1CvMatWrapper.html" title="Utility class that wraps around a CvMat of type CV_32FC1.">CvMatWrapper</a>.  <a href="structicl_1_1core_1_1CvMatDelOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1CvMatWrapper.html">CvMatWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that wraps around a CvMat of type CV_32FC1.  <a href="classicl_1_1core_1_1CvMatWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1DataSegment.html">DataSegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structicl_1_1core_1_1DataSegment.html" title="The DataSegment class defines a strided data segment (or 1D or 2D ordred array of vectors)">DataSegment</a> class defines a strided data segment (or 1D or 2D ordred array of vectors)  <a href="structicl_1_1core_1_1DataSegment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1DataSegment_3_01T_00_011_01_4.html">DataSegment&lt; T, 1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data-segments, where each entry is just 1D  <a href="structicl_1_1core_1_1DataSegment_3_01T_00_011_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1DataSegmentBase.html">DataSegmentBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract data segment class.  <a href="structicl_1_1core_1_1DataSegmentBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1FixedConverter.html">FixedConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special converter "producing" images with fixed parameters.  <a href="classicl_1_1core_1_1FixedConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImageRenderer.html">ImageRenderer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1ImageSerializer.html">ImageSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for binary Image Serialization.  <a href="structicl_1_1core_1_1ImageSerializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> class implements the <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> Image interface with type specific functionalities.  <a href="classicl_1_1core_1_1Img.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> is the Image-Interface class that provides save access to underlying Img-template.  <a href="classicl_1_1core_1_1ImgBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1ImgBasePtrPtr.html">ImgBasePtrPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility class that helps for an implicit conversion between <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>* to ImgBase**  <a href="structicl_1_1core_1_1ImgBasePtrPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBorder.html">ImgBorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to setup an images border pixels.  <a href="classicl_1_1core_1_1ImgBorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBuffer.html">ImgBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singelton class that provides access to reusable temporary images.  <a href="classicl_1_1core_1_1ImgBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgIterator.html">ImgIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class used to iterate through an Images ROI-pixels.  <a href="classicl_1_1core_1_1ImgIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classicl_1_1core_1_1ImgParams.html" title="The ImgParams class stores all image parameters.">ImgParams</a> class stores all image parameters.  <a href="classicl_1_1core_1_1ImgParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Line.html">Line</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ICLs abstract line class describing a line from Point "start" to Point "end".  <a href="classicl_1_1core_1_1Line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Line32f.html">Line32f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ICLs abstract line class describing a line from Point "start" to Point "end".  <a href="classicl_1_1core_1_1Line32f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1LineSampler.html">LineSampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for line sampling.  <a href="classicl_1_1core_1_1LineSampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1MatWrapper.html">MatWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very simply wrapper about the opencv C++ matrix type cv::Mat.  <a href="structicl_1_1core_1_1MatWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1Parable.html">Parable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for the parable-based chromaticity segmentation.  <a href="structicl_1_1core_1_1Parable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1PixelRef.html">PixelRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel-Type class for copying image pixles to image pixels.  <a href="classicl_1_1core_1_1PixelRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1PseudoColorConverter.html">PseudoColorConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for speudocolor conversion.  <a href="structicl_1_1core_1_1PseudoColorConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a75d400b4a0049c9cfcfa508ee28ee8a5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt; <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a></td></tr>
<tr class="memdesc:a75d400b4a0049c9cfcfa508ee28ee8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default color type of the ICL.  <a href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">More...</a><br /></td></tr>
<tr class="separator:a75d400b4a0049c9cfcfa508ee28ee8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac428d8616ba04149de63594528dd14fd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt; <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ac428d8616ba04149de63594528dd14fd">RGB</a></td></tr>
<tr class="memdesc:ac428d8616ba04149de63594528dd14fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGB Color.  <a href="namespaceicl_1_1core.html#ac428d8616ba04149de63594528dd14fd">More...</a><br /></td></tr>
<tr class="separator:ac428d8616ba04149de63594528dd14fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cf27cd5ffe5182313504324ff5b02f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt; <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a00cf27cd5ffe5182313504324ff5b02f">RGBA</a></td></tr>
<tr class="memdesc:a00cf27cd5ffe5182313504324ff5b02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">RGBA Color.  <a href="namespaceicl_1_1core.html#a00cf27cd5ffe5182313504324ff5b02f">More...</a><br /></td></tr>
<tr class="separator:a00cf27cd5ffe5182313504324ff5b02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3463f5d9cc7e801e25d456eddae634"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt; <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a5e3463f5d9cc7e801e25d456eddae634">Color32f</a></td></tr>
<tr class="memdesc:a5e3463f5d9cc7e801e25d456eddae634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special color type for float valued colors.  <a href="namespaceicl_1_1core.html#a5e3463f5d9cc7e801e25d456eddae634">More...</a><br /></td></tr>
<tr class="separator:a5e3463f5d9cc7e801e25d456eddae634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c38f75570be9610e9b54001e2e3a4e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt; <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a17c38f75570be9610e9b54001e2e3a4e">Color4D</a></td></tr>
<tr class="memdesc:a17c38f75570be9610e9b54001e2e3a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special color type for e.g. rgba color information.  <a href="namespaceicl_1_1core.html#a17c38f75570be9610e9b54001e2e3a4e">More...</a><br /></td></tr>
<tr class="separator:a17c38f75570be9610e9b54001e2e3a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac319969b5fd0cbd3a226655b3ab1f187"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt; <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ac319969b5fd0cbd3a226655b3ab1f187">Color4D32f</a></td></tr>
<tr class="memdesc:ac319969b5fd0cbd3a226655b3ab1f187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special color type for e.g. rgba color information (float)  <a href="namespaceicl_1_1core.html#ac319969b5fd0cbd3a226655b3ab1f187">More...</a><br /></td></tr>
<tr class="separator:ac319969b5fd0cbd3a226655b3ab1f187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ebfd5e35116d194189c8f233607414"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a></td></tr>
<tr class="memdesc:gab9ebfd5e35116d194189c8f233607414"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for 8bit integer images  <a href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">More...</a><br /></td></tr>
<tr class="separator:gab9ebfd5e35116d194189c8f233607414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ddf03d82e78b48a4c8a477f093eb769"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a79af5b84ad2c6e4acf44ae0530d89269">icl16s</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TYPES.html#ga7ddf03d82e78b48a4c8a477f093eb769">Img16s</a></td></tr>
<tr class="memdesc:ga7ddf03d82e78b48a4c8a477f093eb769"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for 16bit integer images  <a href="group__TYPES.html#ga7ddf03d82e78b48a4c8a477f093eb769">More...</a><br /></td></tr>
<tr class="separator:ga7ddf03d82e78b48a4c8a477f093eb769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f31ac233fa143556955add6015184f5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TYPES.html#ga3f31ac233fa143556955add6015184f5">Img32s</a></td></tr>
<tr class="memdesc:ga3f31ac233fa143556955add6015184f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for 8bit integer images  <a href="group__TYPES.html#ga3f31ac233fa143556955add6015184f5">More...</a><br /></td></tr>
<tr class="separator:ga3f31ac233fa143556955add6015184f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6441bd8fa2cbf25adb6dec760390d8ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TYPES.html#ga6441bd8fa2cbf25adb6dec760390d8ed">Img32f</a></td></tr>
<tr class="memdesc:ga6441bd8fa2cbf25adb6dec760390d8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for 32bit float images  <a href="group__TYPES.html#ga6441bd8fa2cbf25adb6dec760390d8ed">More...</a><br /></td></tr>
<tr class="separator:ga6441bd8fa2cbf25adb6dec760390d8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac67db4a74d00ca1073fc308a11ae1777"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TYPES.html#gac67db4a74d00ca1073fc308a11ae1777">Img64f</a></td></tr>
<tr class="memdesc:gac67db4a74d00ca1073fc308a11ae1777"><td class="mdescLeft">&#160;</td><td class="mdescRight">typedef for 64bit float images  <a href="group__TYPES.html#gac67db4a74d00ca1073fc308a11ae1777">More...</a><br /></td></tr>
<tr class="separator:gac67db4a74d00ca1073fc308a11ae1777"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a311ebb3bb437b88229c15306e43155a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6">ccimpl</a> { <br />
&#160;&#160;<a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6a7f0f9e2f0f6ec7a174e39f556fcddad9">ccAvailable</a> = 0, 
<a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6a28f0d3dfaf356b4196247df0ade4b9f8">ccEmulated</a> = 1, 
<a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6a192d677b27da078e0e9c1de125269faf">ccAdapted</a> = 2, 
<a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6a3098df1b3bc48a245e1d6c5922c1b95f">ccUnavailable</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6a900005d8f412071a121f0cdff489ec92">ccImpossible</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a311ebb3bb437b88229c15306e43155a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal used type, that describes an implementation type of a specific color conversion function.  <a href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6">More...</a><br /></td></tr>
<tr class="separator:a311ebb3bb437b88229c15306e43155a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5afcc309f314d5b5ab12067b38b6e9b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9b">DepthPreference</a> { <a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9ba38ec57fed9ee434ad5ef92b17c2e3a5e">PREFERE_SRC_DEPTH</a>, 
<a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9bae6e864a51e12f05c08ab28417622a3c4">PREFERE_DST_DEPTH</a>
 }</td></tr>
<tr class="memdesc:ac5afcc309f314d5b5ab12067b38b6e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modes that define whether to prefer the source image's or the destination image's depth.  <a href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9b">More...</a><br /></td></tr>
<tr class="separator:ac5afcc309f314d5b5ab12067b38b6e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53af74cee38afb59cc3738a1042a1cea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> { <br />
&#160;&#160;<a class="el" href="group__TYPES.html#gga53af74cee38afb59cc3738a1042a1ceaabf13298b91874fafb68eedffe1a5f3de">depth8u</a> = 0, 
<a class="el" href="group__TYPES.html#gga53af74cee38afb59cc3738a1042a1ceaa87c24cd544d0e236c278725a65be3e5a">depth16s</a> = 1, 
<a class="el" href="group__TYPES.html#gga53af74cee38afb59cc3738a1042a1ceaaf560890070519a4c44512122ed605827">depth32s</a> = 2, 
<a class="el" href="group__TYPES.html#gga53af74cee38afb59cc3738a1042a1ceaa318053c024418e71be0457ee9658de1d">depth32f</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__TYPES.html#gga53af74cee38afb59cc3738a1042a1ceaab77509582aeeed38bf30959d653bab39">depth64f</a> = 4, 
<a class="el" href="group__TYPES.html#gga53af74cee38afb59cc3738a1042a1ceaac27979dd2f3e8d3f2b8c7ce3b3a32bb3">depthLast</a> = depth64f
<br />
 }</td></tr>
<tr class="memdesc:ga53af74cee38afb59cc3738a1042a1cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the pixel type of an image (8Bit-int or 32Bit-float)  <a href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">More...</a><br /></td></tr>
<tr class="separator:ga53af74cee38afb59cc3738a1042a1cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cc417c2bd265954eaa29e4a17977410"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> { <br />
&#160;&#160;<a class="el" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a2dcd1637518ac3d59d8636469c6b9e90">formatGray</a> = 0, 
<a class="el" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a14b76eca3cc1e9ac323ba2308a15f49e">formatRGB</a> = 1, 
<a class="el" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a45de0178789ceb9db5d158f3d5955eb7">formatHLS</a> = 2, 
<a class="el" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a398c95411a439c0e83c9387be01af57d">formatYUV</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a0e6336dac6c47d315c4e31d7044d6ad5">formatLAB</a> = 4, 
<a class="el" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410ac84260e8b33ef045b23e6e1f515c94d4">formatChroma</a> = 5, 
<a class="el" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a9f11c5f4c5d0e8ddc461f3f9a7d24721">formatMatrix</a> = 6, 
<a class="el" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410ad67153789c1d9c9fd9dcb0927a2d8a88">formatLast</a> = formatMatrix
<br />
 }</td></tr>
<tr class="memdesc:ga7cc417c2bd265954eaa29e4a17977410"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the color-format, that is associated with the images channels  <a href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">More...</a><br /></td></tr>
<tr class="separator:ga7cc417c2bd265954eaa29e4a17977410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b56af8fa13ba9780f05cb3d3cb0b1d0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> { <a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a> =IPPI_INTER_NN, 
<a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a19429813b18fda3505a3f3d4f4abf60d">interpolateLIN</a> =IPPI_INTER_LINEAR, 
<a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0aed40b19856a83f0a72cbdb55c4cdb5ab">interpolateRA</a> =IPPI_INTER_SUPER
 }</td></tr>
<tr class="memdesc:ga9b56af8fa13ba9780f05cb3d3cb0b1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">for scaling of Img images theses functions are provided  <a href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">More...</a><br /></td></tr>
<tr class="separator:ga9b56af8fa13ba9780f05cb3d3cb0b1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f4cf5ea5da57318ad28638b79fc3714"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a> { <a class="el" href="group__TYPES.html#gga3f4cf5ea5da57318ad28638b79fc3714a72215adc147043a9a40c1145011b130f">axisHorz</a> =ippAxsHorizontal, 
<a class="el" href="group__TYPES.html#gga3f4cf5ea5da57318ad28638b79fc3714a8334e18482a405886596a84d58b24b7a">axisVert</a> =ippAxsVertical, 
<a class="el" href="group__TYPES.html#gga3f4cf5ea5da57318ad28638b79fc3714a5d9187a311bf2bff2004d8ffff264892">axisBoth</a> =ippAxsBoth
 }</td></tr>
<tr class="memdesc:ga3f4cf5ea5da57318ad28638b79fc3714"><td class="mdescLeft">&#160;</td><td class="mdescRight">for flipping of images  <a href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">More...</a><br /></td></tr>
<tr class="separator:ga3f4cf5ea5da57318ad28638b79fc3714"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab4d4dd2cfdee101f82869c674659686e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ab4d4dd2cfdee101f82869c674659686e">cc</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *src, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *dst, bool roiOnly=false)</td></tr>
<tr class="memdesc:ab4d4dd2cfdee101f82869c674659686e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color conversion from source to destination image.  <a href="namespaceicl_1_1core.html#ab4d4dd2cfdee101f82869c674659686e">More...</a><br /></td></tr>
<tr class="separator:ab4d4dd2cfdee101f82869c674659686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1350006bfb293ea223a13945573895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#aad1350006bfb293ea223a13945573895">lut_available</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> srcFmt, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> dstFmt)</td></tr>
<tr class="memdesc:aad1350006bfb293ea223a13945573895"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether a lookup table was already created for src and dst format  <a href="namespaceicl_1_1core.html#aad1350006bfb293ea223a13945573895">More...</a><br /></td></tr>
<tr class="separator:aad1350006bfb293ea223a13945573895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991fd7e0142c41a2709193813480207a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a991fd7e0142c41a2709193813480207a">createLUT</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> srcFmt, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> dstFmt)</td></tr>
<tr class="memdesc:a991fd7e0142c41a2709193813480207a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally creates a lookup table to accelerate conversion between given formats.  <a href="namespaceicl_1_1core.html#a991fd7e0142c41a2709193813480207a">More...</a><br /></td></tr>
<tr class="separator:a991fd7e0142c41a2709193813480207a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade048db03cc9b3e4a0d5b147b7de3734"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ade048db03cc9b3e4a0d5b147b7de3734">releaseLUT</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> srcFmt, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> dstFmt)</td></tr>
<tr class="memdesc:ade048db03cc9b3e4a0d5b147b7de3734"><td class="mdescLeft">&#160;</td><td class="mdescRight">releases the internal lookup table created with createLUT  <a href="namespaceicl_1_1core.html#ade048db03cc9b3e4a0d5b147b7de3734">More...</a><br /></td></tr>
<tr class="separator:ade048db03cc9b3e4a0d5b147b7de3734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556dd6a1592603d5e4a03a261da561dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a556dd6a1592603d5e4a03a261da561dd">releaseAllLUTs</a> ()</td></tr>
<tr class="memdesc:a556dd6a1592603d5e4a03a261da561dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">releases all lookup tables that were created with createLUT  <a href="namespaceicl_1_1core.html#a556dd6a1592603d5e4a03a261da561dd">More...</a><br /></td></tr>
<tr class="separator:a556dd6a1592603d5e4a03a261da561dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab196cf655f714b1797b44ee353d29f98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ab196cf655f714b1797b44ee353d29f98">translateCCImpl</a> (<a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6">ccimpl</a> i)</td></tr>
<tr class="memdesc:ab196cf655f714b1797b44ee353d29f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">translates a ccimpl enum into a string representation  <a href="namespaceicl_1_1core.html#ab196cf655f714b1797b44ee353d29f98">More...</a><br /></td></tr>
<tr class="separator:ab196cf655f714b1797b44ee353d29f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5a26d8159c75cb929d9ecbb2f2cd92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6">ccimpl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#acc5a26d8159c75cb929d9ecbb2f2cd92">translateCCImlp</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:acc5a26d8159c75cb929d9ecbb2f2cd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">translates the string represenation of a  <a href="namespaceicl_1_1core.html#acc5a26d8159c75cb929d9ecbb2f2cd92">More...</a><br /></td></tr>
<tr class="separator:acc5a26d8159c75cb929d9ecbb2f2cd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0512ae166c0bb09680a961a418db03e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6">ccimpl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a0512ae166c0bb09680a961a418db03e8">cc_available</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> srcFmt, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> dstFmt)</td></tr>
<tr class="memdesc:a0512ae166c0bb09680a961a418db03e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the ccimpl state to a conversion from srcFmt to dstFmt  <a href="namespaceicl_1_1core.html#a0512ae166c0bb09680a961a418db03e8">More...</a><br /></td></tr>
<tr class="separator:a0512ae166c0bb09680a961a418db03e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c851f177f492c2e6895cf8453241c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a58c851f177f492c2e6895cf8453241c0">convertYUV420ToRGB8</a> (const unsigned char *pucSrc, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;s, <a class="el" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> *poDst)</td></tr>
<tr class="memdesc:a58c851f177f492c2e6895cf8453241c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an image in YUV420-format to RGB8 format (ippi accelerated)  <a href="namespaceicl_1_1core.html#a58c851f177f492c2e6895cf8453241c0">More...</a><br /></td></tr>
<tr class="separator:a58c851f177f492c2e6895cf8453241c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c7da9666e191badf146e0d610e3d1b"><td class="memTemplParams" colspan="2">template&lt;class S , class D &gt; </td></tr>
<tr class="memitem:a99c7da9666e191badf146e0d610e3d1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a99c7da9666e191badf146e0d610e3d1b">planarToInterleaved</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; S &gt; *src, D *dst, int dstLineStep=-1)</td></tr>
<tr class="memdesc:a99c7da9666e191badf146e0d610e3d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an 4 channel Img8u into Qts ARGB32 interleaved format.  <a href="namespaceicl_1_1core.html#a99c7da9666e191badf146e0d610e3d1b">More...</a><br /></td></tr>
<tr class="separator:a99c7da9666e191badf146e0d610e3d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa54783542b1dce3b93863ce5a16c1c5"><td class="memTemplParams" colspan="2">template&lt;class S , class D &gt; </td></tr>
<tr class="memitem:aaa54783542b1dce3b93863ce5a16c1c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#aaa54783542b1dce3b93863ce5a16c1c5">interleavedToPlanar</a> (const S *src, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; D &gt; *dst, int srcLineStep=-1)</td></tr>
<tr class="memdesc:aaa54783542b1dce3b93863ce5a16c1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts interleaved image data into planar representation.  <a href="namespaceicl_1_1core.html#aaa54783542b1dce3b93863ce5a16c1c5">More...</a><br /></td></tr>
<tr class="separator:aaa54783542b1dce3b93863ce5a16c1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e23be25fbdec91889f20803f495a881"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a8e23be25fbdec91889f20803f495a881">cc_util_rgb_to_yuv</a> (const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> r, const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> g, const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> b, <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;y, <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;u, <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;v)</td></tr>
<tr class="memdesc:a8e23be25fbdec91889f20803f495a881"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts given (r,g,b) pixel into the yuv format  <a href="namespaceicl_1_1core.html#a8e23be25fbdec91889f20803f495a881">More...</a><br /></td></tr>
<tr class="separator:a8e23be25fbdec91889f20803f495a881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1a07dec364f4ac543b8cd7f1b74504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#abf1a07dec364f4ac543b8cd7f1b74504">cc_util_yuv_to_rgb</a> (const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> y, const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> u, const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> v, <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;r, <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;g, <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;b)</td></tr>
<tr class="memdesc:abf1a07dec364f4ac543b8cd7f1b74504"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts given (y,u,v) pixel into the rgb format  <a href="namespaceicl_1_1core.html#abf1a07dec364f4ac543b8cd7f1b74504">More...</a><br /></td></tr>
<tr class="separator:abf1a07dec364f4ac543b8cd7f1b74504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2442db8109afcf4f11d6ec19e2a8fef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a2442db8109afcf4f11d6ec19e2a8fef4">cc_util_rgb_to_hls</a> (const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> r255, const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> g255, const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> b255, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;h, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;l, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;s)</td></tr>
<tr class="memdesc:a2442db8109afcf4f11d6ec19e2a8fef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts given (r,g,b) pixel into the hls format  <a href="namespaceicl_1_1core.html#a2442db8109afcf4f11d6ec19e2a8fef4">More...</a><br /></td></tr>
<tr class="separator:a2442db8109afcf4f11d6ec19e2a8fef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a07ad05d20f696de1c9f8793c84088e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a6a07ad05d20f696de1c9f8793c84088e">cc_util_hls_to_rgb</a> (const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> h255, const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> l255, const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> sl255, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;r, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;g, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;b)</td></tr>
<tr class="memdesc:a6a07ad05d20f696de1c9f8793c84088e"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts given (h,l,s) pixel into the rgb format  <a href="namespaceicl_1_1core.html#a6a07ad05d20f696de1c9f8793c84088e">More...</a><br /></td></tr>
<tr class="separator:a6a07ad05d20f696de1c9f8793c84088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03868c503abfbfbcc9f00881d77a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#aeb03868c503abfbfbcc9f00881d77a84">cc_util_rgb_to_chroma</a> (const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> r, const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> g, const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> b, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;chromaR, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;chromaG)</td></tr>
<tr class="memdesc:aeb03868c503abfbfbcc9f00881d77a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts given (r,g,b) pixel into the RG-chroma format  <a href="namespaceicl_1_1core.html#aeb03868c503abfbfbcc9f00881d77a84">More...</a><br /></td></tr>
<tr class="separator:aeb03868c503abfbfbcc9f00881d77a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89358347537d5b5156d408e50cd01b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a89358347537d5b5156d408e50cd01b15">cc_util_rgb_to_lab</a> (const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;r, const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;g, const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;b, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;L, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;A, <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;B)</td></tr>
<tr class="memdesc:a89358347537d5b5156d408e50cd01b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts given (r,g,b) pixel into the Lab format  <a href="namespaceicl_1_1core.html#a89358347537d5b5156d408e50cd01b15">More...</a><br /></td></tr>
<tr class="separator:a89358347537d5b5156d408e50cd01b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d4c7dfc15ea90335160d122f057788"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a64d4c7dfc15ea90335160d122f057788">iclCreateColor</a> (std::string name)</td></tr>
<tr class="separator:a64d4c7dfc15ea90335160d122f057788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4323233f6ce150bacca673d36fe22cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a4323233f6ce150bacca673d36fe22cbe">darker</a> (const <a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a> &amp;c, double factor=0.8)</td></tr>
<tr class="memdesc:a4323233f6ce150bacca673d36fe22cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (by default 20 percent) darker color.  <a href="namespaceicl_1_1core.html#a4323233f6ce150bacca673d36fe22cbe">More...</a><br /></td></tr>
<tr class="separator:a4323233f6ce150bacca673d36fe22cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e49bc9980afee0753a212f952b72a39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a7e49bc9980afee0753a212f952b72a39">lighter</a> (const <a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a> &amp;c, double factor=0.8)</td></tr>
<tr class="memdesc:a7e49bc9980afee0753a212f952b72a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a (by default 20 percent) lighter color.  <a href="namespaceicl_1_1core.html#a7e49bc9980afee0753a212f952b72a39">More...</a><br /></td></tr>
<tr class="separator:a7e49bc9980afee0753a212f952b72a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30767e4b852844434cc864b7338a8e54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a> <a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a30767e4b852844434cc864b7338a8e54">color_from_string</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a30767e4b852844434cc864b7338a8e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a color string representation into a color structur.  <a href="namespaceicl_1_1core.html#a30767e4b852844434cc864b7338a8e54">More...</a><br /></td></tr>
<tr class="separator:a30767e4b852844434cc864b7338a8e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8193f7ffa6d41f8e43a033ce958c3e98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a8193f7ffa6d41f8e43a033ce958c3e98">convexHull</a> (std::vector&lt; <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &gt; P)</td></tr>
<tr class="memdesc:a8193f7ffa6d41f8e43a033ce958c3e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">convex hull monotone chain algorithm for int-points  <a href="namespaceicl_1_1core.html#a8193f7ffa6d41f8e43a033ce958c3e98">More...</a><br /></td></tr>
<tr class="separator:a8193f7ffa6d41f8e43a033ce958c3e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fa96c81620ca0bdcc7d39a1f08a48c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ae2fa96c81620ca0bdcc7d39a1f08a48c">convexHull</a> (std::vector&lt; <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> &gt; P)</td></tr>
<tr class="memdesc:ae2fa96c81620ca0bdcc7d39a1f08a48c"><td class="mdescLeft">&#160;</td><td class="mdescRight">convex hull monotone chain algorithm for float-points  <a href="namespaceicl_1_1core.html#ae2fa96c81620ca0bdcc7d39a1f08a48c">More...</a><br /></td></tr>
<tr class="separator:ae2fa96c81620ca0bdcc7d39a1f08a48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a4ca4fd769f2fe4f0466235948a6cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga00a4ca4fd769f2fe4f0466235948a6cc">imgNew</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d=<a class="el" href="group__TYPES.html#gga53af74cee38afb59cc3738a1042a1ceaabf13298b91874fafb68eedffe1a5f3de">depth8u</a>, const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;params=<a class="el" href="classicl_1_1core_1_1ImgParams.html#a678ccf92d76d27b2acbcd1a5f3c507d3">ImgParams::null</a>)</td></tr>
<tr class="memdesc:ga00a4ca4fd769f2fe4f0466235948a6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new image instance of the given depth type and with given parameters  <a href="group__IMAGE.html#ga00a4ca4fd769f2fe4f0466235948a6cc">More...</a><br /></td></tr>
<tr class="separator:ga00a4ca4fd769f2fe4f0466235948a6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d45bf9adc5c22962102a84d1b509f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga9d45bf9adc5c22962102a84d1b509f70">imgNew</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:ga9d45bf9adc5c22962102a84d1b509f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> (see the above function for more details)  <a href="group__IMAGE.html#ga9d45bf9adc5c22962102a84d1b509f70">More...</a><br /></td></tr>
<tr class="separator:ga9d45bf9adc5c22962102a84d1b509f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e36ef7b1ad84ae52d9853be533ea164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga9e36ef7b1ad84ae52d9853be533ea164">imgNew</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels=1, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:ga9e36ef7b1ad84ae52d9853be533ea164"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> (see the above function for more details)  <a href="group__IMAGE.html#ga9e36ef7b1ad84ae52d9853be533ea164">More...</a><br /></td></tr>
<tr class="separator:ga9e36ef7b1ad84ae52d9853be533ea164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefe02e15f9f47fa6de8b26084bb4b55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gacefe02e15f9f47fa6de8b26084bb4b55">imgNew</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:gacefe02e15f9f47fa6de8b26084bb4b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> (see the above function for more details)  <a href="group__IMAGE.html#gacefe02e15f9f47fa6de8b26084bb4b55">More...</a><br /></td></tr>
<tr class="separator:gacefe02e15f9f47fa6de8b26084bb4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34211f4aa82c399e327b88ac97f7acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gaa34211f4aa82c399e327b88ac97f7acc">ensureDepth</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoImage, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> eDepth)</td></tr>
<tr class="memdesc:gaa34211f4aa82c399e327b88ac97f7acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has the specified depth  <a href="group__IMAGE.html#gaa34211f4aa82c399e327b88ac97f7acc">More...</a><br /></td></tr>
<tr class="separator:gaa34211f4aa82c399e327b88ac97f7acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e1c2a9513b3034fc6fca1d34d42d05e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga8e1c2a9513b3034fc6fca1d34d42d05e">ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;params)</td></tr>
<tr class="memdesc:ga8e1c2a9513b3034fc6fca1d34d42d05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has given depth and parameters  <a href="group__IMAGE.html#ga8e1c2a9513b3034fc6fca1d34d42d05e">More...</a><br /></td></tr>
<tr class="separator:ga8e1c2a9513b3034fc6fca1d34d42d05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32756378c80a568e326011a71765852a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga32756378c80a568e326011a71765852a">ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:ga32756378c80a568e326011a71765852a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has given depth, size, number of channels and ROI  <a href="group__IMAGE.html#ga32756378c80a568e326011a71765852a">More...</a><br /></td></tr>
<tr class="separator:ga32756378c80a568e326011a71765852a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1aa2160788b3841e3ed0018fcea84b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga1e1aa2160788b3841e3ed0018fcea84b">ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:ga1e1aa2160788b3841e3ed0018fcea84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has given depth, size, format and ROI  <a href="group__IMAGE.html#ga1e1aa2160788b3841e3ed0018fcea84b">More...</a><br /></td></tr>
<tr class="separator:ga1e1aa2160788b3841e3ed0018fcea84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37ff3722e02895ea9d7226ff7d984e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gae37ff3722e02895ea9d7226ff7d984e9">ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:gae37ff3722e02895ea9d7226ff7d984e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has given parameters  <a href="group__IMAGE.html#gae37ff3722e02895ea9d7226ff7d984e9">More...</a><br /></td></tr>
<tr class="separator:gae37ff3722e02895ea9d7226ff7d984e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d25708989e461d211172a8d6abd91af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga9d25708989e461d211172a8d6abd91af">ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *src)</td></tr>
<tr class="memdesc:ga9d25708989e461d211172a8d6abd91af"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that the destination image gets same depth, size, channel count, depth, format and ROI as source image  <a href="group__IMAGE.html#ga9d25708989e461d211172a8d6abd91af">More...</a><br /></td></tr>
<tr class="separator:ga9d25708989e461d211172a8d6abd91af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b41d51e096e2e34405b73449a3ad82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GENERAL.html#gab0b41d51e096e2e34405b73449a3ad82">getChannelsOfFormat</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt)</td></tr>
<tr class="memdesc:gab0b41d51e096e2e34405b73449a3ad82"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines the count of channels, for each color format  <a href="group__GENERAL.html#gab0b41d51e096e2e34405b73449a3ad82">More...</a><br /></td></tr>
<tr class="separator:gab0b41d51e096e2e34405b73449a3ad82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89f24eec3dbe806ecb96d9d53837d81"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad89f24eec3dbe806ecb96d9d53837d81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GENERAL.html#gad89f24eec3dbe806ecb96d9d53837d81">getDepth</a> ()</td></tr>
<tr class="memdesc:gad89f24eec3dbe806ecb96d9d53837d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">getDepth&lt;T&gt; returns to depth enum associated to type T  <a href="group__GENERAL.html#gad89f24eec3dbe806ecb96d9d53837d81">More...</a><br /></td></tr>
<tr class="separator:gad89f24eec3dbe806ecb96d9d53837d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884e67c60ff5ca75a2680cb4ba07c6a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a884e67c60ff5ca75a2680cb4ba07c6a6">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> &amp;f)</td></tr>
<tr class="memdesc:a884e67c60ff5ca75a2680cb4ba07c6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">puts a string representation of format into the given stream  <a href="namespaceicl_1_1core.html#a884e67c60ff5ca75a2680cb4ba07c6a6">More...</a><br /></td></tr>
<tr class="separator:a884e67c60ff5ca75a2680cb4ba07c6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244699ff48834bc060049f1ffbd68f3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a244699ff48834bc060049f1ffbd68f3a">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> &amp;d)</td></tr>
<tr class="memdesc:a244699ff48834bc060049f1ffbd68f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">puts a string representation of depth into the given stream  <a href="namespaceicl_1_1core.html#a244699ff48834bc060049f1ffbd68f3a">More...</a><br /></td></tr>
<tr class="separator:a244699ff48834bc060049f1ffbd68f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbd9ec44264aa56fe312e6485e1c4dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#acdbd9ec44264aa56fe312e6485e1c4dd">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> &amp;f)</td></tr>
<tr class="memdesc:acdbd9ec44264aa56fe312e6485e1c4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">puts a string representation of format into the given stream  <a href="namespaceicl_1_1core.html#acdbd9ec44264aa56fe312e6485e1c4dd">More...</a><br /></td></tr>
<tr class="separator:acdbd9ec44264aa56fe312e6485e1c4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8162b9dbde84ae336dbf21ec936fdae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ad8162b9dbde84ae336dbf21ec936fdae">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> &amp;d)</td></tr>
<tr class="memdesc:ad8162b9dbde84ae336dbf21ec936fdae"><td class="mdescLeft">&#160;</td><td class="mdescRight">puts a string representation of depth into the given stream  <a href="namespaceicl_1_1core.html#ad8162b9dbde84ae336dbf21ec936fdae">More...</a><br /></td></tr>
<tr class="separator:ad8162b9dbde84ae336dbf21ec936fdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab73cd03d6e5c00ada71caf11c3a443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__GENERAL.html#gaeab73cd03d6e5c00ada71caf11c3a443">getSizeOf</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> eDepth)</td></tr>
<tr class="memdesc:gaeab73cd03d6e5c00ada71caf11c3a443"><td class="mdescLeft">&#160;</td><td class="mdescRight">return sizeof value for the given depth type  <a href="group__GENERAL.html#gaeab73cd03d6e5c00ada71caf11c3a443">More...</a><br /></td></tr>
<tr class="separator:gaeab73cd03d6e5c00ada71caf11c3a443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf647b896ac574838c2d26b28d4720b49"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf647b896ac574838c2d26b28d4720b49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GENERAL.html#gaf647b896ac574838c2d26b28d4720b49">copy</a> (const T *src, const T *srcEnd, T *dst)</td></tr>
<tr class="memdesc:gaf647b896ac574838c2d26b28d4720b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">moves data from source to destination array (no casting possible)  <a href="group__GENERAL.html#gaf647b896ac574838c2d26b28d4720b49">More...</a><br /></td></tr>
<tr class="separator:gaf647b896ac574838c2d26b28d4720b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75b88e3dd3c7f9d940833fae02304ecf"><td class="memTemplParams" colspan="2">template&lt;class srcT , class dstT &gt; </td></tr>
<tr class="memitem:ga75b88e3dd3c7f9d940833fae02304ecf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GENERAL.html#ga75b88e3dd3c7f9d940833fae02304ecf">convert</a> (const srcT *poSrcStart, const srcT *poSrcEnd, dstT *poDst)</td></tr>
<tr class="memdesc:ga75b88e3dd3c7f9d940833fae02304ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">moves value from source to destination array (with casting on demand)  <a href="group__GENERAL.html#ga75b88e3dd3c7f9d940833fae02304ecf">More...</a><br /></td></tr>
<tr class="separator:ga75b88e3dd3c7f9d940833fae02304ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76a22dfe2840a3f0110f52d4059c230a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga76a22dfe2840a3f0110f52d4059c230a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GENERAL.html#ga76a22dfe2840a3f0110f52d4059c230a">getMinAndMax</a> (T a, T b, T c, T &amp;minVal, T &amp;maxVal)</td></tr>
<tr class="memdesc:ga76a22dfe2840a3f0110f52d4059c230a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function, that calculates the mininum and the maximum value of three value  <a href="group__GENERAL.html#ga76a22dfe2840a3f0110f52d4059c230a">More...</a><br /></td></tr>
<tr class="separator:ga76a22dfe2840a3f0110f52d4059c230a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fb15f1b2e6cee8954e7e161f2544cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a67fb15f1b2e6cee8954e7e161f2544cb">mean</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poImg, int iChannel=-1, bool roiOnly=false)</td></tr>
<tr class="memdesc:a67fb15f1b2e6cee8954e7e161f2544cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the mean value of a ImgBase* ingroup MATH.  <a href="namespaceicl_1_1core.html#a67fb15f1b2e6cee8954e7e161f2544cb">More...</a><br /></td></tr>
<tr class="separator:a67fb15f1b2e6cee8954e7e161f2544cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909cc5e4d9a60ebb088bc32c33a9e7cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a909cc5e4d9a60ebb088bc32c33a9e7cb">variance</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poImg, const std::vector&lt; double &gt; &amp;<a class="el" href="namespaceicl_1_1core.html#a67fb15f1b2e6cee8954e7e161f2544cb">mean</a>, bool empiricMean=true, int iChannel=-1, bool roiOnly=false)</td></tr>
<tr class="memdesc:a909cc5e4d9a60ebb088bc32c33a9e7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance value of an image a with given mean.  <a href="namespaceicl_1_1core.html#a909cc5e4d9a60ebb088bc32c33a9e7cb">More...</a><br /></td></tr>
<tr class="separator:a909cc5e4d9a60ebb088bc32c33a9e7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacb81a7a685b1d22515064b4d9f0d7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#afacb81a7a685b1d22515064b4d9f0d7b">variance</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poImg, int iChannel=-1, bool roiOnly=false)</td></tr>
<tr class="memdesc:afacb81a7a685b1d22515064b4d9f0d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the variance value of an image a.  <a href="namespaceicl_1_1core.html#afacb81a7a685b1d22515064b4d9f0d7b">More...</a><br /></td></tr>
<tr class="separator:afacb81a7a685b1d22515064b4d9f0d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27888d536d14a8a9183e73a025150b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#af27888d536d14a8a9183e73a025150b5">stdDeviation</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poImage, int iChannel=-1, bool roiOnly=false)</td></tr>
<tr class="memdesc:af27888d536d14a8a9183e73a025150b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the std::deviation of an image.  <a href="namespaceicl_1_1core.html#af27888d536d14a8a9183e73a025150b5">More...</a><br /></td></tr>
<tr class="separator:af27888d536d14a8a9183e73a025150b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b7472df74f8c785daf3ef5d7a617e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#aa5b7472df74f8c785daf3ef5d7a617e9">stdDeviation</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poImage, const std::vector&lt; double &gt; <a class="el" href="namespaceicl_1_1core.html#a67fb15f1b2e6cee8954e7e161f2544cb">mean</a>, bool empiricMean=true, int iChannel=-1, bool roiOnly=false)</td></tr>
<tr class="memdesc:aa5b7472df74f8c785daf3ef5d7a617e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the std::deviation of an image with given channel means.  <a href="namespaceicl_1_1core.html#aa5b7472df74f8c785daf3ef5d7a617e9">More...</a><br /></td></tr>
<tr class="separator:aa5b7472df74f8c785daf3ef5d7a617e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4220b02ba3562123fcbff7aea3fdb251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; std::pair&lt; double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a4220b02ba3562123fcbff7aea3fdb251">meanAndStdDev</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *image, int iChannel=-1, bool roiOnly=false)</td></tr>
<tr class="memdesc:a4220b02ba3562123fcbff7aea3fdb251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates mean and standard deviation of given image simultanously.  <a href="namespaceicl_1_1core.html#a4220b02ba3562123fcbff7aea3fdb251">More...</a><br /></td></tr>
<tr class="separator:a4220b02ba3562123fcbff7aea3fdb251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5cae8c8f53258616b942c6c4c17daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#acb5cae8c8f53258616b942c6c4c17daf">channelHisto</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *image, int channel, int levels=256, bool roiOnly=false)</td></tr>
<tr class="memdesc:acb5cae8c8f53258616b942c6c4c17daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the color histogramm of given image channel  <a href="namespaceicl_1_1core.html#acb5cae8c8f53258616b942c6c4c17daf">More...</a><br /></td></tr>
<tr class="separator:acb5cae8c8f53258616b942c6c4c17daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6c6e7db0d1f6bb3aa89a2fb3da47fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#aab6c6e7db0d1f6bb3aa89a2fb3da47fe">hist</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *image, int levels=256, bool roiOnly=false)</td></tr>
<tr class="memdesc:aab6c6e7db0d1f6bb3aa89a2fb3da47fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the color histogramm of given image  <a href="namespaceicl_1_1core.html#aab6c6e7db0d1f6bb3aa89a2fb3da47fe">More...</a><br /></td></tr>
<tr class="separator:aab6c6e7db0d1f6bb3aa89a2fb3da47fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bef8dfe9aaafedf642c6da1d372523"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga05bef8dfe9aaafedf642c6da1d372523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1core_1_1ImgBasePtrPtr.html">ImgBasePtrPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga05bef8dfe9aaafedf642c6da1d372523">bpp</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *image)</td></tr>
<tr class="memdesc:ga05bef8dfe9aaafedf642c6da1d372523"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to cast an <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> implicitly into an <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> **  <a href="group__IMAGE.html#ga05bef8dfe9aaafedf642c6da1d372523">More...</a><br /></td></tr>
<tr class="separator:ga05bef8dfe9aaafedf642c6da1d372523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab279f13b8c52fb2b960296fb8f2d171d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab279f13b8c52fb2b960296fb8f2d171d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1core_1_1ImgBasePtrPtr.html">ImgBasePtrPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gab279f13b8c52fb2b960296fb8f2d171d">bpp</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; &amp;image)</td></tr>
<tr class="memdesc:gab279f13b8c52fb2b960296fb8f2d171d"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to cast an <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>* implicitly into an <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> **  <a href="group__IMAGE.html#gab279f13b8c52fb2b960296fb8f2d171d">More...</a><br /></td></tr>
<tr class="separator:gab279f13b8c52fb2b960296fb8f2d171d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c1b0e98f54c54dde5a5494114b91a8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a45c1b0e98f54c54dde5a5494114b91a8"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a45c1b0e98f54c54dde5a5494114b91a8">p2o</a> (T *ptr)</td></tr>
<tr class="memdesc:a45c1b0e98f54c54dde5a5494114b91a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion function to transform a pointer into an object.  <a href="namespaceicl_1_1core.html#a45c1b0e98f54c54dde5a5494114b91a8">More...</a><br /></td></tr>
<tr class="separator:a45c1b0e98f54c54dde5a5494114b91a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac255b232de05b40341dc48a2c1b1cbfc"><td class="memTemplParams" colspan="2">template&lt;class ImgType &gt; </td></tr>
<tr class="memitem:gac255b232de05b40341dc48a2c1b1cbfc"><td class="memTemplItemLeft" align="right" valign="top">const ImgType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gac255b232de05b40341dc48a2c1b1cbfc">combineImages</a> (const std::vector&lt; const ImgType * &gt; &amp;vec)</td></tr>
<tr class="memdesc:gac255b232de05b40341dc48a2c1b1cbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine several images using shallow copy.  <a href="group__IMAGE.html#gac255b232de05b40341dc48a2c1b1cbfc">More...</a><br /></td></tr>
<tr class="separator:gac255b232de05b40341dc48a2c1b1cbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9748a47b96e8122edbaad78f4b42511b"><td class="memTemplParams" colspan="2">template&lt;class ImgType &gt; </td></tr>
<tr class="memitem:ga9748a47b96e8122edbaad78f4b42511b"><td class="memTemplItemLeft" align="right" valign="top">ImgType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga9748a47b96e8122edbaad78f4b42511b">combineImages</a> (const std::vector&lt; ImgType * &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga9748a47b96e8122edbaad78f4b42511b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine several images using shallow copy. Non-const version.  <a href="group__IMAGE.html#ga9748a47b96e8122edbaad78f4b42511b">More...</a><br /></td></tr>
<tr class="separator:ga9748a47b96e8122edbaad78f4b42511b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7e8c4530584e4ca897a65c52a7786f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaea7e8c4530584e4ca897a65c52a7786f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gaea7e8c4530584e4ca897a65c52a7786f">deepCopyChannel</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *src, int srcC, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *dst, int dstC)</td></tr>
<tr class="memdesc:gaea7e8c4530584e4ca897a65c52a7786f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the channel from one image to another.  <a href="group__IMAGE.html#gaea7e8c4530584e4ca897a65c52a7786f">More...</a><br /></td></tr>
<tr class="separator:gaea7e8c4530584e4ca897a65c52a7786f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ce00bcf79e53e02b993d7d000932dc"><td class="memTemplParams" colspan="2">template&lt;class S , class D &gt; </td></tr>
<tr class="memitem:ga74ce00bcf79e53e02b993d7d000932dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga74ce00bcf79e53e02b993d7d000932dc">convertChannel</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; S &gt; *src, int srcC, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; D &gt; *dst, int dstC)</td></tr>
<tr class="memdesc:ga74ce00bcf79e53e02b993d7d000932dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies/converts the data from one image to another image (IPP-OPTIMIZED)  <a href="group__IMAGE.html#ga74ce00bcf79e53e02b993d7d000932dc">More...</a><br /></td></tr>
<tr class="separator:ga74ce00bcf79e53e02b993d7d000932dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac583e47b8967070361ea3ce603b9070d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac583e47b8967070361ea3ce603b9070d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gac583e47b8967070361ea3ce603b9070d">clearChannelROI</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *im, int c, T clearVal, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;offs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size)</td></tr>
<tr class="memdesc:gac583e47b8967070361ea3ce603b9070d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets an arbitrary image ROI to a given value  <a href="group__IMAGE.html#gac583e47b8967070361ea3ce603b9070d">More...</a><br /></td></tr>
<tr class="separator:gac583e47b8967070361ea3ce603b9070d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702018256e7c778be8d75029b4c171a5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga702018256e7c778be8d75029b4c171a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga702018256e7c778be8d75029b4c171a5">deepCopyChannelROI</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *src, int srcC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;srcOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;srcSize, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *dst, int dstC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;dstOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;dstSize)</td></tr>
<tr class="memdesc:ga702018256e7c778be8d75029b4c171a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies the channel roi from one image to another  <a href="group__IMAGE.html#ga702018256e7c778be8d75029b4c171a5">More...</a><br /></td></tr>
<tr class="separator:ga702018256e7c778be8d75029b4c171a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab87b761a7fe9bdf8abacc9aacf324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a36ab87b761a7fe9bdf8abacc9aacf324">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> &amp;image)</td></tr>
<tr class="memdesc:a36ab87b761a7fe9bdf8abacc9aacf324"><td class="mdescLeft">&#160;</td><td class="mdescRight">puts a string representation of the image into given steam  <a href="namespaceicl_1_1core.html#a36ab87b761a7fe9bdf8abacc9aacf324">More...</a><br /></td></tr>
<tr class="separator:a36ab87b761a7fe9bdf8abacc9aacf324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e8e200c50b20c2aa482363bc583834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a98e8e200c50b20c2aa482363bc583834">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;p)</td></tr>
<tr class="memdesc:a98e8e200c50b20c2aa482363bc583834"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator <a href="#" onclick="location.href='mai'+'lto:'+'SIZ'+'Ex'+'CHA'+'NN'+'ELS'+'@F'+'ORM'+'AT'+'.RO'+'I'; return false;">SIZEx<span style="display: none;">.nosp@m.</span>CHAN<span style="display: none;">.nosp@m.</span>NELS@<span style="display: none;">.nosp@m.</span>FORM<span style="display: none;">.nosp@m.</span>AT.RO<span style="display: none;">.nosp@m.</span>I</a>  <a href="namespaceicl_1_1core.html#a98e8e200c50b20c2aa482363bc583834">More...</a><br /></td></tr>
<tr class="separator:a98e8e200c50b20c2aa482363bc583834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937b058e72e49c5a13b528c37c3ad155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a937b058e72e49c5a13b528c37c3ad155">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;p)</td></tr>
<tr class="memdesc:a937b058e72e49c5a13b528c37c3ad155"><td class="mdescLeft">&#160;</td><td class="mdescRight">istream operator  <a href="namespaceicl_1_1core.html#a937b058e72e49c5a13b528c37c3ad155">More...</a><br /></td></tr>
<tr class="separator:a937b058e72e49c5a13b528c37c3ad155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcdca8afd9e433978cdd5976ee6c7ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a1dcdca8afd9e433978cdd5976ee6c7ba">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classicl_1_1core_1_1Line.html">Line</a> &amp;l)</td></tr>
<tr class="memdesc:a1dcdca8afd9e433978cdd5976ee6c7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator (start-x,start-y)(end-x,end-y)  <a href="namespaceicl_1_1core.html#a1dcdca8afd9e433978cdd5976ee6c7ba">More...</a><br /></td></tr>
<tr class="separator:a1dcdca8afd9e433978cdd5976ee6c7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52890b08df9f03dd30da2354a65a7814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a52890b08df9f03dd30da2354a65a7814">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classicl_1_1core_1_1Line.html">Line</a> &amp;l)</td></tr>
<tr class="memdesc:a52890b08df9f03dd30da2354a65a7814"><td class="mdescLeft">&#160;</td><td class="mdescRight">istream operator  <a href="namespaceicl_1_1core.html#a52890b08df9f03dd30da2354a65a7814">More...</a><br /></td></tr>
<tr class="separator:a52890b08df9f03dd30da2354a65a7814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c41817392b76c1a5f4c0b1df8f672e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ac7c41817392b76c1a5f4c0b1df8f672e">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classicl_1_1core_1_1Line32f.html">Line32f</a> &amp;l)</td></tr>
<tr class="memdesc:ac7c41817392b76c1a5f4c0b1df8f672e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator (start-x,start-y)(end-x,end-y)  <a href="namespaceicl_1_1core.html#ac7c41817392b76c1a5f4c0b1df8f672e">More...</a><br /></td></tr>
<tr class="separator:ac7c41817392b76c1a5f4c0b1df8f672e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7660026bfb42cc775474de6b0e3559dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a7660026bfb42cc775474de6b0e3559dd">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classicl_1_1core_1_1Line32f.html">Line32f</a> &amp;l)</td></tr>
<tr class="memdesc:a7660026bfb42cc775474de6b0e3559dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">istream operator  <a href="namespaceicl_1_1core.html#a7660026bfb42cc775474de6b0e3559dd">More...</a><br /></td></tr>
<tr class="separator:a7660026bfb42cc775474de6b0e3559dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33d722c94cdb961d9956d8d198b99d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ad33d722c94cdb961d9956d8d198b99d5">ipl_to_img</a> (CvArr *src, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst=0, <a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9b">DepthPreference</a> e=<a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9ba38ec57fed9ee434ad5ef92b17c2e3a5e">PREFERE_SRC_DEPTH</a>)</td></tr>
<tr class="memdesc:ad33d722c94cdb961d9956d8d198b99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert OpenCV IplImage to ICLimage.  <a href="namespaceicl_1_1core.html#ad33d722c94cdb961d9956d8d198b99d5">More...</a><br /></td></tr>
<tr class="separator:ad33d722c94cdb961d9956d8d198b99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace954463381a6820ddef49fed87ea8ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> IplImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ace954463381a6820ddef49fed87ea8ea">img_to_ipl</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *src, IplImage **dst=0, <a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9b">DepthPreference</a> e=<a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9ba38ec57fed9ee434ad5ef92b17c2e3a5e">PREFERE_SRC_DEPTH</a>)</td></tr>
<tr class="memdesc:ace954463381a6820ddef49fed87ea8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert ICLimage to OpenCV IplImage.  <a href="namespaceicl_1_1core.html#ace954463381a6820ddef49fed87ea8ea">More...</a><br /></td></tr>
<tr class="separator:ace954463381a6820ddef49fed87ea8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca81629d04600362891438cef19a0d01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> CvMat *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#aca81629d04600362891438cef19a0d01">img_to_cvmat</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *src, CvMat *dst=0, int channel=0)</td></tr>
<tr class="memdesc:aca81629d04600362891438cef19a0d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy single ICLimage channel to OpenCV single channel CvMat.  <a href="namespaceicl_1_1core.html#aca81629d04600362891438cef19a0d01">More...</a><br /></td></tr>
<tr class="separator:aca81629d04600362891438cef19a0d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21038dfb445e8d6abf3edbc422f1506"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa21038dfb445e8d6abf3edbc422f1506"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#aa21038dfb445e8d6abf3edbc422f1506">operator&lt;&lt;</a> (std::ostream &amp;str, const <a class="el" href="classicl_1_1core_1_1CvMatWrapper.html">CvMatWrapper</a>&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:aa21038dfb445e8d6abf3edbc422f1506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded ostream operator for the CvMat32fWrapper.  <a href="namespaceicl_1_1core.html#aa21038dfb445e8d6abf3edbc422f1506">More...</a><br /></td></tr>
<tr class="separator:aa21038dfb445e8d6abf3edbc422f1506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b1803b5fd5ed9becec3baa500017aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> ::cv::Mat *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#ac6b1803b5fd5ed9becec3baa500017aa">img_to_mat</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *src, ::cv::Mat *dst=0)</td></tr>
<tr class="memdesc:ac6b1803b5fd5ed9becec3baa500017aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts icl image into opencv's C++ image type cv::Mat (data is deeply copied)  <a href="namespaceicl_1_1core.html#ac6b1803b5fd5ed9becec3baa500017aa">More...</a><br /></td></tr>
<tr class="separator:ac6b1803b5fd5ed9becec3baa500017aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245ca1d7e111c24ba5c9cce19990a39b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a245ca1d7e111c24ba5c9cce19990a39b">mat_to_img</a> (const ::cv::Mat *src, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *dstIn=0)</td></tr>
<tr class="memdesc:a245ca1d7e111c24ba5c9cce19990a39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts cv::Mat to <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> (internally the pixel data is type-converted if needed)  <a href="namespaceicl_1_1core.html#a245ca1d7e111c24ba5c9cce19990a39b">More...</a><br /></td></tr>
<tr class="separator:a245ca1d7e111c24ba5c9cce19990a39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5b215d5cb44dc09c300b42a4d69eec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a4c5b215d5cb44dc09c300b42a4d69eec">mat_to_img</a> (const ::cv::Mat *src, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dstIn)</td></tr>
<tr class="memdesc:a4c5b215d5cb44dc09c300b42a4d69eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts cv::Mat to <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> (internally the pixel data is type-converted if needed)  <a href="namespaceicl_1_1core.html#a4c5b215d5cb44dc09c300b42a4d69eec">More...</a><br /></td></tr>
<tr class="separator:a4c5b215d5cb44dc09c300b42a4d69eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
type conversion of channel ROIs</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc4d9b41d97c1d2dedc3bd1d58fe8e62d"></a> copies/converts the ROI data from one image to the ROI of another image (IPP-OPTIMIZED) </p>
</td></tr>
<tr class="memitem:a4a928e3ddbf9fe2ad0abc4771606dcfb"><td class="memTemplParams" colspan="2">template&lt;class S , class D &gt; </td></tr>
<tr class="memitem:a4a928e3ddbf9fe2ad0abc4771606dcfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a4a928e3ddbf9fe2ad0abc4771606dcfb">convertChannelROI</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; S &gt; *src, int srcC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;srcOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;srcROISize, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; D &gt; *dst, int dstC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;dstOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;dstROISize)</td></tr>
<tr class="separator:a4a928e3ddbf9fe2ad0abc4771606dcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
scaling of channel ROIs</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd35635495181165c1fe2e8499aaa1aa6"></a> scales an image channels ROI into another images ROI (with implicit type conversion) (IPP-OPTIMIZED) </p>
</td></tr>
<tr class="memitem:a55daebb91e9496b292a66fc3939a5e2a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a55daebb91e9496b292a66fc3939a5e2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1core.html#a55daebb91e9496b292a66fc3939a5e2a">scaledCopyChannelROI</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *src, int srcC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;srcOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;srcSize, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *dst, int dstC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;dstOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;dstSize, <a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> eScaleMode)</td></tr>
<tr class="separator:a55daebb91e9496b292a66fc3939a5e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f84be8075e9ce4bf05c7707996d8bf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga88f84be8075e9ce4bf05c7707996d8bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga88f84be8075e9ce4bf05c7707996d8bf">flippedCopyChannelROI</a> (<a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a> eAxis, const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *src, int srcC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;srcOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;srcSize, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *dst, int dstC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;dstOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;dstSize)</td></tr>
<tr class="memdesc:ga88f84be8075e9ce4bf05c7707996d8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror copy ROI data from one image to the ROI of another image (IPP-OPTIMIZED)  <a href="group__IMAGE.html#ga88f84be8075e9ce4bf05c7707996d8bf">More...</a><br /></td></tr>
<tr class="separator:ga88f84be8075e9ce4bf05c7707996d8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7343097d928bee1057f6356b38cb3ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga7343097d928bee1057f6356b38cb3ec5">flippedCopy</a> (<a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a> eAxis, const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poSrc, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0)</td></tr>
<tr class="memdesc:ga7343097d928bee1057f6356b38cb3ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror copy of an image from source to destination image (1:1 copy)  <a href="group__IMAGE.html#ga7343097d928bee1057f6356b38cb3ec5">More...</a><br /></td></tr>
<tr class="separator:ga7343097d928bee1057f6356b38cb3ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9dad01f2988ee2ff540f4ad900a2e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gab9dad01f2988ee2ff540f4ad900a2e1a">flippedCopyROI</a> (<a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a> eAxis, const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poSrc, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0)</td></tr>
<tr class="memdesc:gab9dad01f2988ee2ff540f4ad900a2e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror copy of an images ROI into a destination images ROI  <a href="group__IMAGE.html#gab9dad01f2988ee2ff540f4ad900a2e1a">More...</a><br /></td></tr>
<tr class="separator:gab9dad01f2988ee2ff540f4ad900a2e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a75d400b4a0049c9cfcfa508ee28ee8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d400b4a0049c9cfcfa508ee28ee8a5">&#9670;&nbsp;</a></span>Color</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt;<a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>,3&gt; <a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">icl::core::Color</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default color type of the ICL. </p>

</div>
</div>
<a id="a5e3463f5d9cc7e801e25d456eddae634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3463f5d9cc7e801e25d456eddae634">&#9670;&nbsp;</a></span>Color32f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt;<a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>,3&gt; <a class="el" href="namespaceicl_1_1core.html#a5e3463f5d9cc7e801e25d456eddae634">icl::core::Color32f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special color type for float valued colors. </p>

</div>
</div>
<a id="a17c38f75570be9610e9b54001e2e3a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c38f75570be9610e9b54001e2e3a4e">&#9670;&nbsp;</a></span>Color4D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt;<a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>,4&gt; <a class="el" href="namespaceicl_1_1core.html#a17c38f75570be9610e9b54001e2e3a4e">icl::core::Color4D</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special color type for e.g. rgba color information. </p>

</div>
</div>
<a id="ac319969b5fd0cbd3a226655b3ab1f187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac319969b5fd0cbd3a226655b3ab1f187">&#9670;&nbsp;</a></span>Color4D32f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt;<a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>,4&gt; <a class="el" href="namespaceicl_1_1core.html#ac319969b5fd0cbd3a226655b3ab1f187">icl::core::Color4D32f</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special color type for e.g. rgba color information (float) </p>

</div>
</div>
<a id="ac428d8616ba04149de63594528dd14fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac428d8616ba04149de63594528dd14fd">&#9670;&nbsp;</a></span>RGB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt;<a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>,3&gt; <a class="el" href="namespaceicl_1_1core.html#ac428d8616ba04149de63594528dd14fd">icl::core::RGB</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RGB Color. </p>

</div>
</div>
<a id="a00cf27cd5ffe5182313504324ff5b02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00cf27cd5ffe5182313504324ff5b02f">&#9670;&nbsp;</a></span>RGBA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structicl_1_1math_1_1FixedColVector.html">math::FixedColVector</a>&lt;<a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>,4&gt; <a class="el" href="namespaceicl_1_1core.html#a00cf27cd5ffe5182313504324ff5b02f">icl::core::RGBA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RGBA Color. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a311ebb3bb437b88229c15306e43155a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311ebb3bb437b88229c15306e43155a6">&#9670;&nbsp;</a></span>ccimpl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6">icl::core::ccimpl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal used type, that describes an implementation type of a specific color conversion function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a311ebb3bb437b88229c15306e43155a6a7f0f9e2f0f6ec7a174e39f556fcddad9"></a>ccAvailable&#160;</td><td class="fielddoc"><p>conversion is supported natively/directly </p>
</td></tr>
<tr><td class="fieldname"><a id="a311ebb3bb437b88229c15306e43155a6a28f0d3dfaf356b4196247df0ade4b9f8"></a>ccEmulated&#160;</td><td class="fielddoc"><p>conversion is supported using the bridge format RGB </p>
</td></tr>
<tr><td class="fieldname"><a id="a311ebb3bb437b88229c15306e43155a6a192d677b27da078e0e9c1de125269faf"></a>ccAdapted&#160;</td><td class="fielddoc"><p>conversion is actually not possible but although performed ( like XXX to matrix ) </p>
</td></tr>
<tr><td class="fieldname"><a id="a311ebb3bb437b88229c15306e43155a6a3098df1b3bc48a245e1d6c5922c1b95f"></a>ccUnavailable&#160;</td><td class="fielddoc"><p>conversion is not implemented yet, but possible </p>
</td></tr>
<tr><td class="fieldname"><a id="a311ebb3bb437b88229c15306e43155a6a900005d8f412071a121f0cdff489ec92"></a>ccImpossible&#160;</td><td class="fielddoc"><p>conversion does not make sense (like croma to RGB ) </p>
</td></tr>
</table>

</div>
</div>
<a id="ac5afcc309f314d5b5ab12067b38b6e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5afcc309f314d5b5ab12067b38b6e9b">&#9670;&nbsp;</a></span>DepthPreference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9b">icl::core::DepthPreference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modes that define whether to prefer the source image's or the destination image's depth. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac5afcc309f314d5b5ab12067b38b6e9ba38ec57fed9ee434ad5ef92b17c2e3a5e"></a>PREFERE_SRC_DEPTH&#160;</td><td class="fielddoc"><p>prefer source depth </p>
</td></tr>
<tr><td class="fieldname"><a id="ac5afcc309f314d5b5ab12067b38b6e9bae6e864a51e12f05c08ab28417622a3c4"></a>PREFERE_DST_DEPTH&#160;</td><td class="fielddoc"><p>prefer destination depth </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab4d4dd2cfdee101f82869c674659686e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d4dd2cfdee101f82869c674659686e">&#9670;&nbsp;</a></span>cc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::cc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roiOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Color conversion from source to destination image. </p>
<p>All color conversions of the ICL are tackled by this function. The destination images size is adapted to the source images size, as cc does not provide implicit scaling; Use the <a class="el" href="classicl_1_1core_1_1Converter.html" title="General Image Converter.">Converter</a> class, also located in this package, for color conversion with implicit scaling instead.</p>
<p>Currently ICL supports the following color formats:</p><ul>
<li>RGB (sRGB)</li>
<li>HLS</li>
<li>YUV</li>
<li>LAB</li>
<li>r-g-Chromaticity</li>
<li>Grayscale</li>
</ul>
<h1><a class="anchor" id="secRanges"></a>
Color Ranges</h1>
<p>As default, the all ICL color spaces are represented in the full range of [0,255] in all depths. By this, we get the advantage of being able to treat all color images in the same way. The disadvantage is, that already existing color conversion routines must be adapted to scale each color component to that range.</p>
<h1><a class="anchor" id="secDefFormat"></a>
sRGB, most common and default</h1>
<p>Obviously, the RGB Color Model (or its absolute Version sRGB -&gt; standard RGB) is one of the best known one by most of the users. Although many computer vision approaches are using other color spaces as HLS or LAB, the sRGB color space complies a kind of angle point for color conversion functions. So in most cases, the sRGB format forms a <em>bridge format</em> for conversion from one to another format (xxx-&gt;yyy ==&gt; xxx-&gt;rgb followed by rgb-&gt;yyy ; Another bridge color space (XYZ) is not considered here). In term of efficiency of the color conversion code: Converting from or to RGB is fast, other conversion may be much slower.</p>
<h1><a class="anchor" id="secYUV"></a>
YUV Color Space Conversion</h1>
<p>The literature yuv color model conversion is mostly a bit confusing and far away from a kind of pseudocode, that can easily be converted to (fast) c++ code. The YUV Color model divides an incoming RGB signal into its luminance component (Y) and two chrominance components (U and V). The common yuv-color holds Y in the range [0,1], u in range [-0.436,0.436] and v in range [-0.615,0,615]. These different ranges compound implementing algorithms. Hence the color conversion functions of the ICL are adapted to scale the resulting values to the range [0,255] in all channels. Outgoing from the basic equation for converting rgb to yuv and back </p><pre>
Y = 0.299*R + 0.587*G + 0.114*B
U = -0.147*R - 0.289*G + 0.436*B = 0.492*(B- Y)
V = 0.615*R - 0.515*G - 0.100*B = 0.877*(R- Y)</pre><pre>R = Y + 1.140*V
G = Y - 0.394*U - 0.581*V
B = Y + 2.032*U
</pre><p>The formulas are adapted for using ranges [0,255]: </p><pre>
Y = (0.299*R + 0.587*G + 0.114*B);
U = 0.56433408*(B-Y) + 127.5;
V = 0.71326676*(R-Y) + 127.5;</pre><pre>R = Y +               290.7   * v2;
G = Y - 100.47 * u2 - 148.155 * v2;   with: u2 = 0.0034196078*U - 0.436;
B = Y + 518.16 * u2;                   and  v2 = 0.0048235294*V - 0.615;
</pre><p>To avoid <em>expensive</em> floating point operations, the conversions can be optimized by creating a so called <b>fixed point approximation</b> of the above code: </p><pre>
Y = ( 1254097*R + 2462056*G + 478151*B ) &gt;&gt; 22;
U = ( 2366989*(B-Y) + 534773760        ) &gt;&gt; 22;
V = ( 2991658*(R-Y) + 534773760        ) &gt;&gt; 22;</pre><pre>R = Y +  ( ( 290 * V2 ) &gt;&gt; 22 );
G = Y -  ( ( 100  * U2 + 148 * V2) &gt;&gt; 22 ); with: U2 = 14343*U - 1828717;
B = Y +  ( ( 518 * U2 ) &gt;&gt; 22 );             and  V2 = 20231*v - 2579497;
</pre><p> This approximation produces errors less 3/255, and runs up to 20% faster. A further optimization can be implemented using lookup tables.</p>
<p>The SSE-implementation uses the original floating point calculation, that is extended to match the value range [0,255]: </p><pre>
Y = 0.299f*R + 0.587f*G + 0.114*B
U = 0.492f*(B-Y) + 128.0f
V = 0.877f*(R-Y) + 128.0f
if(V &lt; 0.0f) V = 0.0f;
else if(V &gt; 255.0f) V = 255.0f;</pre><pre>R = Y + 1.140*(V - 128)
G = Y - 0.394*(U - 128) - 0.581*(V - 128)
B = Y + 2.032*(U - 128)
R = clip(R, 0, 255);
G = clip(G, 0, 255);
B = clip(B, 0, 255);
</pre><h2><a class="anchor" id="IPPCOMPA_XYZ"></a>
IPP Compatibility</h2>
<p>In order to achieve compatibility with the yuv color conversion provided by intel IPP (which is used if IPP is available), also ICL's color conversion methods were slightly adapted. We again used fixed point approximations for the algorithms described in the IPP manual:</p>
<pre>
rgb-to-yuv:</pre><pre>y = ( 1254097*r + 2462056*g + 478151*b ) &gt;&gt; 22;
u = (2063598*(b-y) &gt;&gt; 22) + 128;
v = (3678405*(r-y) &gt;&gt; 22) + 128;</pre><pre>if(v&lt;0) v=0;
else if(v &gt; 255) v = 255;
</pre><pre>
yuv-to-rgb:</pre><pre>icl32s u2 = u-128;
icl32s v2 = v-128;
icl32s y2 = y&lt;&lt;22;</pre><pre>r = (y2 + 4781506 * v2 ) &gt;&gt; 22;
g = (y2 - 1652556 * u2 - 2436891 *v2 ) &gt;&gt; 22;
b = (y2 + 8522826 * u2 ) &gt;&gt; 22;
</pre><p> <b>please note</b> Due to the clipping process of 'v' in rgb_to_yuv, this method cannot restore an original rgb value completetly. Since we lost some information in v, the resulting r and g values are differ as follows: r-r' in [-32,35], and g-g' in [-17,18]</p>
<h1><a class="anchor" id="secHLS"></a>
HLS Color Space Conversion</h1>
<p>The HLS color space, also known as the HSI color space with another channel order describes colors in more independent components. The <b>H</b>ue component complies an angle and is as well as all other color information scaled to the range [0,254]. The value H=255 is identical to H=0 (red). Independent from the colors hue, its <b>L</b>ightness is estimated by the second component. Basic colors as red (r=255,g=0,b=0) have a lightness of 127; lighter colors have a hight L value; darker colors have a lower one. The last component is the <b>S</b>aturation of the color. The color model can be drawn as a double (hex)cone . Note that the HLS color spaces resolution is higher in its center (L near 127). The following formulas describe the conversion from and to the RGB format: </p><pre>
(H,L,S) RGBToHLS(R,G,B)
(r,g,b) = (R,G,B)/255;</pre><pre>m = min(r,g,b)
v = max(r,g,b)</pre><pre>l = (m+v)/2
if(l &lt;= 0){
  (H,L,S) = (0,0,0)
  return
}</pre><pre>vm = v-m
if ( vm &gt; 0 ) {
  if(l&lt;=0.5){
    s=vm/(v+m)
  }else{
    s=vm/(2.0-v-m)
  }
}else{
  (H,L,S)=(0,l*255,0)
  return
}</pre><pre>r2 = (v - r) / vm
g2 = (v - g) / vm
b2 = (v - b) / vm</pre><pre>if (r == v)
  h = (g == m ? 5.0 + b2 : 1.0 - g2)
else if (g == v)
  h = (b == m ? 1.0 + r2 : 3.0 - b2)
else
  h = (r == m ? 3.0 + g2 : 5.0 - r2)
if(h == 255) h = 0
  (H,L,S) = (h*255/6,l*255,s*255)
</pre><p>An optimization, that allows conversion directly with (r,g,b) values in range [0,255] is not yet implemented.</p>
<pre>
(R,G,B) HLSToRGB(H,L,S)</pre><pre>(h,l,s) = (H,L,S)/255;
v = (l &lt;= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl)
if (v &lt;= 0 ) {
  R = G = B = 0;
  return;
}</pre><pre>m = l + l - v;
sv = (v - m ) / v;
h *= 6.0;</pre><pre>int sextant = (int)h;</pre><pre>fract = h - sextant;
vsf = v * sv * fract;
mid1 = m + vsf;
mid2 = v - vsf;</pre><pre>switch (sextant) {
  case 0: r = v;    g = mid1; b = m;    break;
  case 1: r = mid2; g = v;    b = m;    break;
  case 2: r = m;    g = v;    b = mid1; break;
  case 3: r = m;    g = mid2; b = v;    break;
  case 4: r = mid1; g = m;    b = v;    break;
  case 5: r = v;    g = m;    b = mid2; break;
}</pre><pre>(R,G,B) = (r,g,b)*255;
</pre><p> An additional optimization can be implemented using lookup tables.</p>
<h1><a class="anchor" id="secLAB"></a>
Lab Color Space Conversion</h1>
<p>The LAB color space (strictly CIE L*a*b*), was designed to describe the complete range of colors, that can be seen by the human eye. It must not be mixed up with the "Hunter Lab" color space, that is sure related to the CIE L*a*b*, but in detail much different. "The three parameters in the model represent the lightness of the color (L*, L*=0 yields black and L*=100 indicates white), its position between magenta and green (a*, negative values indicate green while positive values indicate magenta) and its position between yellow and blue (b*, negative values indicate blue and positive values indicate yellow)"(wikipedia).
"CIE 1976 L*a*b* is based directly on the CIE 1931 XYZ color space as an attempt to linearize the perceptibility of color differences, using the color difference metric described by the MacAdam ellipse"(wikipedia). So an euclidian (linear) color difference metric can be used here. The following code show the formulas LabToXYZ, XYZToLab, RGBToXYZ and XYZToRGB. </p><pre>
RGBToXYZ
static icl32f m[3][3] = {{ 0.412453, 0.35758 , 0.180423},
                         { 0.212671, 0.71516 , 0.072169},
                         { 0.019334, 0.119193, 0.950227}};</pre><pre>X = m[0][0] * R + m[0][1] * G + m[0][2] * B;
Y = m[1][0] * R + m[1][1] * G + m[1][2] * B;
Z = m[2][0] * R + m[2][1] * G + m[2][2] * B;</pre><pre>XYZToRGB
static icl32f m[3][3] = {{ 3.2405, -1.5372,-0.4985},
                         {-0.9693,  1.8760, 0.0416},
                         { 0.0556, -0.2040, 1.0573}};
R = m[0][0] * x + m[0][1] * y + m[0][2] * z;
G = m[1][0] * x + m[1][1] * y + m[1][2] * z;
B = m[2][0] * x + m[2][1] * y + m[2][2] * z;</pre><pre>XYZToLAB
wX = 0.950455;
wY = 1.0;
wZ = 1.088753;
_13 = 1.0/3.0;</pre><pre>XXn = X / wX;
YYn = Y / wY;
ZZn = Z / wZ;</pre><pre>L = (YYn &gt; 0.008856) ? ((116 * pow (YYn, _13))-16) : (903.3 * YYn);</pre><pre>fX = (XXn &gt; 0.008856) ? pow (XXn, _13) : 7.787 * XXn + (16 / 116);
fY = (YYn &gt; 0.008856) ? pow (YYn, _13) : 7.787 * YYn + (16 / 116);
fZ = (ZZn &gt; 0.008856) ? pow (ZZn, _13) : 7.787 * ZZn + (16 / 116);</pre><pre>L = 116 * fY - 16;
a = 500.0 * (fX - fY);
b = 200.0 * (fY - fZ);</pre><pre>LABToXYZ
n = 16.0/116.0;</pre><pre>wX = 0.950455;
wY = 1.0;
wZ = 1.088754f;</pre><pre>fy = (l+16)/116;
fx = fy+a/500;
fz = fy-b/200;</pre><pre>X = (fx&gt;0.206893f) ?  wX*pow(fx,3) : wX*(fx-n)/7.787f;
Y = (fy&gt;0.206893f) ?  wY*pow(fy,3) : wY*(fy-n)/7.787f;
Z = (fz&gt;0.206893f) ?  wZ*pow(fz,3) : wZ*(fz-n)/7.787f;
</pre><h1><a class="anchor" id="secGray"></a>
Gray Scale Conversion</h1>
<p>The gray scale conversion is optimized for speed performance. Although, L of Lab is not equal to the Y of YUV, color formats, that have an brightness-like component are converted to gray scale by picking this channel. RGB is converted to gray by the simple channel mean (r+g+b)/3.</p>
<h1><a class="anchor" id="matrix"></a>
formatMatrix Conversion</h1>
<p>As the matrix image format offers no color information, matrix image data is just copied from the source image channels to the destination image channels. If the source image has more channels, the remaining channels are left unregarded. If otherwise the destination image has more channels, this channels are left unchanged</p>
<h1><a class="anchor" id="secChroma"></a>
r-g-Chromaticity Color Space Conversion</h1>
<p>The chromaticity space r,g,b divides the R,G,B components by the city block norm of the according color r=R/(R+G+B), g=G/(R+G+B), b= B/(R+G+B). By this means, the b-component becomes redundant, and can be left out, which leads to the r-g-chromaticity space. Conversions form the r-g-Chromaticity space to other formats are not possible, as to much information is lost.</p>
<h1><a class="anchor" id="secBench"></a>
Benchmarks</h1>
<p>The following tables, show the cross format conversion times: <b>TODO: re-run this test --&gt; which machine / which image size ?</b></p>
<p><b><em>depth32f</em></b> </p><table class="doxtable">
<tr>
<td>src\dst</td><td>rgb </td><td>yuv </td><td>lab </td><td>hls </td><td>gray </td><td>chroma  </td></tr>
<tr>
<td>rgb </td><td>10* </td><td>26 </td><td>47 </td><td>30 </td><td>7 </td><td>21  </td></tr>
<tr>
<td>yuv </td><td>23 </td><td>8 </td><td>387?</td><td>64 </td><td>2 </td><td>45  </td></tr>
<tr>
<td>lab </td><td>45 </td><td>63 </td><td>8 </td><td>75 </td><td>2 </td><td>63  </td></tr>
<tr>
<td>hls </td><td>23 </td><td>43 </td><td>67 </td><td>8 </td><td>2 </td><td>44  </td></tr>
<tr>
<td>gray </td><td>11 </td><td>12 </td><td>11 </td><td>13 </td><td>3 </td><td>**  </td></tr>
<tr>
<td>chroma </td><td>** </td><td>** </td><td>** </td><td>** </td><td>** </td><td>6  </td></tr>
</table>
<p><em>* times in ms</em> <em>** this does not make sense!</em></p>
<p><b><em>depth8u</em></b> </p><table class="doxtable">
<tr>
<td>src\dst</td><td>rgb </td><td>yuv </td><td>lab </td><td>hls </td><td>gray </td><td>chroma  </td></tr>
<tr>
<td>rgb </td><td>3 </td><td>9 </td><td>31 </td><td>22 </td><td>3 </td><td>22  </td></tr>
<tr>
<td>yuv </td><td>13 </td><td>2 </td><td>487?</td><td>56 </td><td>0.2 </td><td>33  </td></tr>
<tr>
<td>lab </td><td>31 </td><td>40 </td><td>2 </td><td>54 </td><td>0.2 </td><td>52  </td></tr>
<tr>
<td>hls </td><td>12 </td><td>21 </td><td>43 </td><td>2 </td><td>0.2 </td><td>33  </td></tr>
<tr>
<td>gray </td><td>3 </td><td>4 </td><td>4 </td><td>4 </td><td>0.2 </td><td>**  </td></tr>
<tr>
<td>chroma </td><td>** </td><td>** </td><td>** </td><td>** </td><td>** </td><td>6  </td></tr>
</table>
<p><b><em>cross depth conversion depth8u --&gt; depth32f</em></b> </p><table class="doxtable">
<tr>
<td>src\dst</td><td>rgb </td><td>yuv </td><td>lab </td><td>hls </td><td>gray </td><td>chroma  </td></tr>
<tr>
<td>rgb </td><td>9 </td><td>10 </td><td>32 </td><td>22 </td><td>4 </td><td>23  </td></tr>
<tr>
<td>yuv </td><td>11 </td><td>8 </td><td>474?</td><td>54 </td><td>3 </td><td>34  </td></tr>
<tr>
<td>lab </td><td>30 </td><td>41 </td><td>8 </td><td>52 </td><td>3 </td><td>53  </td></tr>
<tr>
<td>hls </td><td>14 </td><td>22 </td><td>43 </td><td>8 </td><td>3 </td><td>34  </td></tr>
<tr>
<td>gray </td><td>8 </td><td>8 </td><td>8 </td><td>8 </td><td>3 </td><td>**  </td></tr>
<tr>
<td>chroma </td><td>7 </td><td>** </td><td>** </td><td>** </td><td>** </td><td>5  </td></tr>
</table>
<h1><a class="anchor" id="ROI"></a>
ROI-Support</h1>
<p>A new feature is the ROI-Support of the "cc" function. If the "roiOnly"-flag given to cc function is set to true, the source images ROI is converted into the destination images ROI. In this case, the destination image is not adapted to the source image. Instead, a single test is performed to ensure, that the source images ROI has the same size as the destination images ROI. If the test fails, an error occurs and the function returns immediately.<br  />
<b>Note:</b> internally all functions are optimized for running without ROI support (in this case, the images data arrays are 1D). Thus, the ROI-Support mode (roiOnly = true) runs approx. 20% (2%-50%) slower depended on the specific source and destination format.</p>
<h1><a class="anchor" id="IPP"></a>
IPP Acceleration</h1>
<p>Most functions are not IPP accelerated even if IPP support is available because IPP supports most conversions for interleaved formats only. However a few very common conversions make use of available IPP acceleration:</p><ul>
<li>RGB -&gt; YUV</li>
<li>YUV -&gt; RGB</li>
<li>RGB -&gt; HLS</li>
<li>HLS -&gt; RGB</li>
</ul>
<p>The IPP accelerated times are not part of the benchmark above. Usually, as a rule of thumb, IPP is supposed to be at least twice as fast as the C++-fallback implementation. </p>
<h1><a class="anchor" id="IPPComp"></a>
Important note regarding IPP compatibility&lt;/b&gt;</h1>
<p>Currently, IPP and C++ fallback version are not 100% compatible as IPP uses additional optimizations that causes, that the U- and V- channel range are not full 8bit range [0-255]. We aim to fix that in future </p>

</div>
</div>
<a id="a0512ae166c0bb09680a961a418db03e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0512ae166c0bb09680a961a418db03e8">&#9670;&nbsp;</a></span>cc_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6">ccimpl</a> icl::core::cc_available </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>srcFmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>dstFmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the ccimpl state to a conversion from srcFmt to dstFmt </p>

</div>
</div>
<a id="a6a07ad05d20f696de1c9f8793c84088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a07ad05d20f696de1c9f8793c84088e">&#9670;&nbsp;</a></span>cc_util_hls_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::cc_util_hls_to_rgb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td>
          <td class="paramname"><em>h255</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td>
          <td class="paramname"><em>l255</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td>
          <td class="paramname"><em>sl255</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts given (h,l,s) pixel into the rgb format </p>

</div>
</div>
<a id="aeb03868c503abfbfbcc9f00881d77a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb03868c503abfbfbcc9f00881d77a84">&#9670;&nbsp;</a></span>cc_util_rgb_to_chroma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::cc_util_rgb_to_chroma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>chromaR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>chromaG</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts given (r,g,b) pixel into the RG-chroma format </p>

</div>
</div>
<a id="a2442db8109afcf4f11d6ec19e2a8fef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2442db8109afcf4f11d6ec19e2a8fef4">&#9670;&nbsp;</a></span>cc_util_rgb_to_hls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::cc_util_rgb_to_hls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td>
          <td class="paramname"><em>r255</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td>
          <td class="paramname"><em>g255</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td>
          <td class="paramname"><em>b255</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts given (r,g,b) pixel into the hls format </p>

</div>
</div>
<a id="a89358347537d5b5156d408e50cd01b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89358347537d5b5156d408e50cd01b15">&#9670;&nbsp;</a></span>cc_util_rgb_to_lab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icl::core::cc_util_rgb_to_lab </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts given (r,g,b) pixel into the Lab format </p>

</div>
</div>
<a id="a8e23be25fbdec91889f20803f495a881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e23be25fbdec91889f20803f495a881">&#9670;&nbsp;</a></span>cc_util_rgb_to_yuv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::cc_util_rgb_to_yuv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts given (r,g,b) pixel into the yuv format </p>

</div>
</div>
<a id="abf1a07dec364f4ac543b8cd7f1b74504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1a07dec364f4ac543b8cd7f1b74504">&#9670;&nbsp;</a></span>cc_util_yuv_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::cc_util_yuv_to_rgb </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts given (y,u,v) pixel into the rgb format </p>

</div>
</div>
<a id="acb5cae8c8f53258616b942c6c4c17daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb5cae8c8f53258616b942c6c4c17daf">&#9670;&nbsp;</a></span>channelHisto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt;int&gt; icl::core::channelHisto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>levels</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roiOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the color histogramm of given image channel </p>

</div>
</div>
<a id="a30767e4b852844434cc864b7338a8e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30767e4b852844434cc864b7338a8e54">&#9670;&nbsp;</a></span>color_from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a> <a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> icl::core::color_from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a color string representation into a color structur. </p>
<p>If an error occurs, a warning is shown and black color is returned first checks for some default color names:</p><ul>
<li>black</li>
<li>white</li>
<li>red</li>
<li>green</li>
<li>blue</li>
<li>cyan</li>
<li>magenta</li>
<li>yellow</li>
<li>gray50</li>
<li>gray100</li>
<li>gray150</li>
<li>gray200 </li>
</ul>

</div>
</div>
<a id="a4a928e3ddbf9fe2ad0abc4771606dcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a928e3ddbf9fe2ad0abc4771606dcfb">&#9670;&nbsp;</a></span>convertChannelROI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icl::core::convertChannelROI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; S &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>srcOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>srcROISize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; D &gt; *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>dstOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>dstROISize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used by all other deepCopyROI functions internally. It copies / converts ROI image data to another images ROI using the icl::copy(..) function line by line or, in case of IPP-optimization enabled, corresponding ippCopy/ippConvert Calls (see the following specialized template functions also). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image </td></tr>
    <tr><td class="paramname">srcC</td><td>source image channel </td></tr>
    <tr><td class="paramname">srcOffs</td><td>source images ROI-offset (src-&gt;getROIOffset() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">srcROISize</td><td>source images ROI-size (src-&gt;getROISize() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">dst</td><td>destination image </td></tr>
    <tr><td class="paramname">dstC</td><td>destination image channel </td></tr>
    <tr><td class="paramname">dstOffs</td><td>destination images ROI-offset (dst-&gt;getROIOffset() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">dstROISize</td><td>destination images ROI-size (dst-&gt;getROISize() is <b>not</b> regarded) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58c851f177f492c2e6895cf8453241c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c851f177f492c2e6895cf8453241c0">&#9670;&nbsp;</a></span>convertYUV420ToRGB8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::convertYUV420ToRGB8 </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>pucSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> *&#160;</td>
          <td class="paramname"><em>poDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an image in YUV420-format to RGB8 format (ippi accelerated) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poDst</td><td>destination image </td></tr>
    <tr><td class="paramname">pucSrc</td><td>pointer to source data (data is in YUV420 format, which is planar and which's U- and V-channel has half X- and half Y-resolution. The data pointer has iW*iH*1.5 elements) </td></tr>
    <tr><td class="paramname">s</td><td>image size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8193f7ffa6d41f8e43a033ce958c3e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8193f7ffa6d41f8e43a033ce958c3e98">&#9670;&nbsp;</a></span>convexHull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt;<a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a>&gt; icl::core::convexHull </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &gt;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convex hull monotone chain algorithm for int-points </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>list of <a class="el" href="classicl_1_1utils_1_1Point.html" title="Point class of the ICL used e.g. for the Images ROI offset.">utils::Point</a> (input) call-by-value, as we need an inplace-sort internally </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of points of the convex hull first point is identical to the last point in this list! </dd></dl>

</div>
</div>
<a id="ae2fa96c81620ca0bdcc7d39a1f08a48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fa96c81620ca0bdcc7d39a1f08a48c">&#9670;&nbsp;</a></span>convexHull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt;<a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a>&gt; icl::core::convexHull </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> &gt;&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convex hull monotone chain algorithm for float-points </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>list of <a class="el" href="classicl_1_1utils_1_1Point32f.html" title="Single precission 3D Vectors Point class of the ICL.">utils::Point32f</a> (input) call-by-value, as we need an inplace-sort internally </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of points of the convex hull first point is identical to the last point in this list! </dd></dl>

</div>
</div>
<a id="a991fd7e0142c41a2709193813480207a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991fd7e0142c41a2709193813480207a">&#9670;&nbsp;</a></span>createLUT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::createLUT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>srcFmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>dstFmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internally creates a lookup table to accelerate conversion between given formats. </p>
<p>Take care: <b>Each LUT uses up to 48MB of system memory</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcFmt</td><td>source format </td></tr>
    <tr><td class="paramname">dstFmt</td><td>destination format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4323233f6ce150bacca673d36fe22cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4323233f6ce150bacca673d36fe22cbe">&#9670;&nbsp;</a></span>darker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a> icl::core::darker </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>0.8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (by default 20 percent) darker color. </p>

</div>
</div>
<a id="aab6c6e7db0d1f6bb3aa89a2fb3da47fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6c6e7db0d1f6bb3aa89a2fb3da47fe">&#9670;&nbsp;</a></span>hist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt;std::vector&lt;int&gt; &gt; icl::core::hist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>levels</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roiOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the color histogramm of given image </p>

</div>
</div>
<a id="a64d4c7dfc15ea90335160d122f057788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d4c7dfc15ea90335160d122f057788">&#9670;&nbsp;</a></span>iclCreateColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a>&amp; icl::core::iclCreateColor </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca81629d04600362891438cef19a0d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca81629d04600362891438cef19a0d01">&#9670;&nbsp;</a></span>img_to_cvmat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> CvMat* icl::core::img_to_cvmat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvMat *&#160;</td>
          <td class="paramname"><em>dst</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy single ICLimage channel to OpenCV single channel CvMat. </p>
<p>Copy single ICLimage channel to single channel CvMat. If dst is NULL, the sourceimagedepth will be used, else the destinationmatrixdepth will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td>pointer to sourceimage </td></tr>
    <tr><td class="paramname">**dst</td><td>pointer to pointer to destinationmatrix </td></tr>
    <tr><td class="paramname">channel</td><td>channel to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace954463381a6820ddef49fed87ea8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace954463381a6820ddef49fed87ea8ea">&#9670;&nbsp;</a></span>img_to_ipl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> IplImage* icl::core::img_to_ipl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IplImage **&#160;</td>
          <td class="paramname"><em>dst</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9b">DepthPreference</a>&#160;</td>
          <td class="paramname"><em>e</em> = <code><a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9ba38ec57fed9ee434ad5ef92b17c2e3a5e">PREFERE_SRC_DEPTH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert ICLimage to OpenCV IplImage. </p>
<p>Converts ICLimage to IplImage. If dst is NULL, the sourceimagedepth will be used, else the destinationimagedepth will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td>pointer to sourceimage </td></tr>
    <tr><td class="paramname">**dst</td><td>pointer to pointer to destinationimage (IplImage) </td></tr>
    <tr><td class="paramname">e</td><td>depthpreference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6b1803b5fd5ed9becec3baa500017aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b1803b5fd5ed9becec3baa500017aa">&#9670;&nbsp;</a></span>img_to_mat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> ::cv::Mat* icl::core::img_to_mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::cv::Mat *&#160;</td>
          <td class="paramname"><em>dst</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts icl image into opencv's C++ image type cv::Mat (data is deeply copied) </p>
<p>If a destimation Mat is given, it will be set up to resemble the input images parameters exactly. Therefore, the data is always copied and never converted </p>

</div>
</div>
<a id="aaa54783542b1dce3b93863ce5a16c1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa54783542b1dce3b93863ce5a16c1c5">&#9670;&nbsp;</a></span>interleavedToPlanar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::interleavedToPlanar </td>
          <td>(</td>
          <td class="paramtype">const S *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; D &gt; *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcLineStep</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts interleaved image data into planar representation. </p>
<p>The source data is transformed into the destination images ROI </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>data pointer </td></tr>
    <tr><td class="paramname">dst</td><td>image pointer </td></tr>
    <tr><td class="paramname">srcLineStep</td><td>optionally given src linestep size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad33d722c94cdb961d9956d8d198b99d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33d722c94cdb961d9956d8d198b99d5">&#9670;&nbsp;</a></span>ipl_to_img()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::ipl_to_img </td>
          <td>(</td>
          <td class="paramtype">CvArr *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>dst</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9b">DepthPreference</a>&#160;</td>
          <td class="paramname"><em>e</em> = <code><a class="el" href="namespaceicl_1_1core.html#ac5afcc309f314d5b5ab12067b38b6e9ba38ec57fed9ee434ad5ef92b17c2e3a5e">PREFERE_SRC_DEPTH</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert OpenCV IplImage to ICLimage. </p>
<p>Converts IplImage to ICLimage. If dst is NULL, the sourceimagedepth will be used, else the destinationimagedepth will be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td>pointer to sourceimage (IplImage) </td></tr>
    <tr><td class="paramname">**dst</td><td>pointer to pointer to destinationimage (ICLimage) </td></tr>
    <tr><td class="paramname">e</td><td>depthpreference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e49bc9980afee0753a212f952b72a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e49bc9980afee0753a212f952b72a39">&#9670;&nbsp;</a></span>lighter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a> icl::core::lighter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceicl_1_1core.html#a75d400b4a0049c9cfcfa508ee28ee8a5">Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>factor</em> = <code>0.8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a (by default 20 percent) lighter color. </p>

</div>
</div>
<a id="aad1350006bfb293ea223a13945573895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1350006bfb293ea223a13945573895">&#9670;&nbsp;</a></span>lut_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> bool icl::core::lut_available </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>srcFmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>dstFmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether a lookup table was already created for src and dst format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcFmt</td><td>source format </td></tr>
    <tr><td class="paramname">dstFmt</td><td>destination format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c5b215d5cb44dc09c300b42a4d69eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5b215d5cb44dc09c300b42a4d69eec">&#9670;&nbsp;</a></span>mat_to_img() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::mat_to_img </td>
          <td>(</td>
          <td class="paramtype">const ::cv::Mat *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>dstIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts cv::Mat to <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> (internally the pixel data is type-converted if needed) </p>

</div>
</div>
<a id="a245ca1d7e111c24ba5c9cce19990a39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245ca1d7e111c24ba5c9cce19990a39b">&#9670;&nbsp;</a></span>mat_to_img() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::mat_to_img </td>
          <td>(</td>
          <td class="paramtype">const ::cv::Mat *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>dstIn</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts cv::Mat to <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> (internally the pixel data is type-converted if needed) </p>

</div>
</div>
<a id="a67fb15f1b2e6cee8954e7e161f2544cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fb15f1b2e6cee8954e7e161f2544cb">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt;double&gt; icl::core::mean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>poImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roiOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the mean value of a ImgBase* ingroup MATH. </p>
<p>IPP-Optimized for icl32f and icl64f </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poImg</td><td>input image </td></tr>
    <tr><td class="paramname">iChannel</td><td>channel index (-1 for all channels) </td></tr>
    <tr><td class="paramname">roiOnly</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mean value of image or image channel (optionally: roi) </dd></dl>

</div>
</div>
<a id="a4220b02ba3562123fcbff7aea3fdb251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4220b02ba3562123fcbff7aea3fdb251">&#9670;&nbsp;</a></span>meanAndStdDev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt; std::pair&lt;double, double&gt; &gt; icl::core::meanAndStdDev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roiOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates mean and standard deviation of given image simultanously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>input image </td></tr>
    <tr><td class="paramname">iChannel</td><td>image channel if &lt; 0 all channels are used </td></tr>
    <tr><td class="paramname">roiOnly</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector v of pairs p with p.first = mean and p.second = stdDev v[i] containing i-th channel's results </dd></dl>

</div>
</div>
<a id="a98e8e200c50b20c2aa482363bc583834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e8e200c50b20c2aa482363bc583834">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream&amp; icl::core::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ostream operator <a href="#" onclick="location.href='mai'+'lto:'+'SIZ'+'Ex'+'CHA'+'NN'+'ELS'+'@F'+'ORM'+'AT'+'.RO'+'I'; return false;">SIZEx<span style="display: none;">.nosp@m.</span>CHAN<span style="display: none;">.nosp@m.</span>NELS@<span style="display: none;">.nosp@m.</span>FORM<span style="display: none;">.nosp@m.</span>AT.RO<span style="display: none;">.nosp@m.</span>I</a> </p>

</div>
</div>
<a id="a244699ff48834bc060049f1ffbd68f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244699ff48834bc060049f1ffbd68f3a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream&amp; icl::core::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>puts a string representation of depth into the given stream </p>

</div>
</div>
<a id="a884e67c60ff5ca75a2680cb4ba07c6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884e67c60ff5ca75a2680cb4ba07c6a6">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream&amp; icl::core::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>puts a string representation of format into the given stream </p>

</div>
</div>
<a id="a36ab87b761a7fe9bdf8abacc9aacf324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ab87b761a7fe9bdf8abacc9aacf324">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream&amp; icl::core::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>puts a string representation of the image into given steam </p>

</div>
</div>
<a id="a1dcdca8afd9e433978cdd5976ee6c7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcdca8afd9e433978cdd5976ee6c7ba">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream&amp; icl::core::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Line.html">Line</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ostream operator (start-x,start-y)(end-x,end-y) </p>

</div>
</div>
<a id="ac7c41817392b76c1a5f4c0b1df8f672e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c41817392b76c1a5f4c0b1df8f672e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::ostream&amp; icl::core::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Line32f.html">Line32f</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ostream operator (start-x,start-y)(end-x,end-y) </p>

</div>
</div>
<a id="aa21038dfb445e8d6abf3edbc422f1506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21038dfb445e8d6abf3edbc422f1506">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; icl::core::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1CvMatWrapper.html">CvMatWrapper</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded ostream operator for the CvMat32fWrapper. </p>

</div>
</div>
<a id="a937b058e72e49c5a13b528c37c3ad155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937b058e72e49c5a13b528c37c3ad155">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream&amp; icl::core::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>istream operator </p>

</div>
</div>
<a id="ad8162b9dbde84ae336dbf21ec936fdae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8162b9dbde84ae336dbf21ec936fdae">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream&amp; icl::core::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>puts a string representation of depth into the given stream </p>

</div>
</div>
<a id="acdbd9ec44264aa56fe312e6485e1c4dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbd9ec44264aa56fe312e6485e1c4dd">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream&amp; icl::core::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>puts a string representation of format into the given stream </p>

</div>
</div>
<a id="a52890b08df9f03dd30da2354a65a7814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52890b08df9f03dd30da2354a65a7814">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream&amp; icl::core::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Line.html">Line</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>istream operator </p>

</div>
</div>
<a id="a7660026bfb42cc775474de6b0e3559dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7660026bfb42cc775474de6b0e3559dd">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::istream&amp; icl::core::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Line32f.html">Line32f</a> &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>istream operator </p>

</div>
</div>
<a id="a45c1b0e98f54c54dde5a5494114b91a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c1b0e98f54c54dde5a5494114b91a8">&#9670;&nbsp;</a></span>p2o()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T icl::core::p2o </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion function to transform a pointer into an object. </p>
<p>This function is very common: in many cases, <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> member functions return pointer instead of objects. This might lead to some extra code lines, if these pointer are used locally: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> *image){</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> *channel0 = image-&gt;<a class="code" href="classicl_1_1core_1_1Img.html#af1b77c10cf3bcd9cca01b87d8dcae892">selectChannel</a>(0);</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> *imageWithFullROI = image-&gt;<a class="code" href="classicl_1_1core_1_1Img.html#a5551b9551361837a4cae9a5720be30bd">shallowCopy</a>(image-&gt;getImageRect());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// do something with the shallow copies</span></div>
<div class="line">  <span class="comment">// e.g. call some other functions</span></div>
<div class="line">  show_one_channel_image(*channel0);</div>
<div class="line">  process_image_with_full_roi(*imageWithFullROI);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">delete</span> channel0;</div>
<div class="line">  <span class="keyword">delete</span> imageWithFullROI;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This code can be written much shorter using the <em>NEW</em> p2o function: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keyword">const</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> *image){</div>
<div class="line">  show_one_channel_image(<a class="code" href="namespaceicl_1_1core.html#a45c1b0e98f54c54dde5a5494114b91a8">p2o</a>(image-&gt;selectChannel(0)));</div>
<div class="line">  process_image_with_full_roi(<a class="code" href="namespaceicl_1_1core.html#a45c1b0e98f54c54dde5a5494114b91a8">p2o</a>(image-&gt;shallowCopy(image-&gt;getImageRect())));</div>
<div class="line">}</div>
</div><!-- fragment --><p>internally: p2o uses a smart pointer to ensure <b>given pointer is released properly before function returns</b></p>
<h1><a class="anchor" id="IMPL"></a>
Implementing the Configurable Interface</h1>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</div>
<div class="line"><span class="keyword">inline</span> T <a class="code" href="namespaceicl_1_1core.html#a45c1b0e98f54c54dde5a5494114b91a8">p2o</a>(T *ptr){</div>
<div class="line">  <span class="keywordflow">return</span> T(*SmartPtr&lt;T&gt;(<span class="keyword">const_cast&lt;</span>T*<span class="keyword">&gt;</span>(ptr)));</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="CMPLX"></a>
Complexity</h1>
<p>the function internally creates a smart Pointer object and calls the copy constructor of given T once. Hence the function complexity scales with the implementation of the standard copy constructor of T. Particularly for ICL's <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> classes, the default copy constructor performs a shallow copy internally which induces negligible computational costs. </p>

</div>
</div>
<a id="a99c7da9666e191badf146e0d610e3d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c7da9666e191badf146e0d610e3d1b">&#9670;&nbsp;</a></span>planarToInterleaved()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::planarToInterleaved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; S &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstLineStep</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an 4 channel Img8u into Qts ARGB32 interleaved format. </p>
<p>@param pucDst destination data pointer of size poSrc-&gt;getDim()*4 @param poSrc source image with 4 channels Convert an 4 channel Img32f into Qts ARGB32 interleaved format This function will first convert the given Img32f poSrc into the buffer image poBuffer. Then it will call the above method, to convert the buffer data into pucDst. If the buffer is not valid, the method will return immediately. @param pucDst destination data pointer of size poSrc-&gt;getDim()*4 @param poSrc source image with 4 channels @param poBuffer buffer to use for internal depth conversion. Converts a planar <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a><s> images ROI into its interleaved representations by mixing the channels This function is highly optimized, because it is needed whenever we need interleaved images </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image image </td></tr>
    <tr><td class="paramname">dst</td><td>destination data pointer </td></tr>
    <tr><td class="paramname">dstLineStep</td><td>optinal linestep of the destination image. This must be given, if it differs from the source images lineStep multiplied by the source images channel count </td></tr>
  </table>
  </dd>
</dl>
<p></s></p>

</div>
</div>
<a id="a556dd6a1592603d5e4a03a261da561dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556dd6a1592603d5e4a03a261da561dd">&#9670;&nbsp;</a></span>releaseAllLUTs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::releaseAllLUTs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>releases all lookup tables that were created with createLUT </p>

</div>
</div>
<a id="ade048db03cc9b3e4a0d5b147b7de3734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade048db03cc9b3e4a0d5b147b7de3734">&#9670;&nbsp;</a></span>releaseLUT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::releaseLUT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>srcFmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>dstFmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>releases the internal lookup table created with createLUT </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcFmt</td><td>source format </td></tr>
    <tr><td class="paramname">dstFmt</td><td>destination format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55daebb91e9496b292a66fc3939a5e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55daebb91e9496b292a66fc3939a5e2a">&#9670;&nbsp;</a></span>scaledCopyChannelROI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::scaledCopyChannelROI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>srcOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>dstOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a>&#160;</td>
          <td class="paramname"><em>eScaleMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function provides all necessary functionalities for scaling images. Please regard, that the fallback- implementation is very slow. Only scaling operations with identical source and destination type is optimized by corresponding ippResize calls (see also the specialized template functions). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image </td></tr>
    <tr><td class="paramname">srcC</td><td>source image channel </td></tr>
    <tr><td class="paramname">srcOffs</td><td>source images ROI-offset (src-&gt;getROIOffset() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">srcSize</td><td>source images ROI-size (src-&gt;getROISize() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">dst</td><td>destination image </td></tr>
    <tr><td class="paramname">dstC</td><td>destination image channel </td></tr>
    <tr><td class="paramname">dstOffs</td><td>destination images ROI-offset (dst-&gt;getROIOffset() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">dstSize</td><td>destination images ROI-size (dst-&gt;getROISize() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">eScaleMode</td><td>scaling mode to use (nearest neighbor, linear, or region-average) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5b7472df74f8c785daf3ef5d7a617e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b7472df74f8c785daf3ef5d7a617e9">&#9670;&nbsp;</a></span>stdDeviation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt;double&gt; icl::core::stdDeviation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>poImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>empiricMean</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roiOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the std::deviation of an image with given channel means. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poImage</td><td>input image </td></tr>
    <tr><td class="paramname">mean</td><td>vector with channel means </td></tr>
    <tr><td class="paramname">empiricMean</td><td>if true, sum of square distances is devided by n-1 else by n </td></tr>
    <tr><td class="paramname">iChannel</td><td>channel index (all channels if -1) </td></tr>
    <tr><td class="paramname">roiOnly</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af27888d536d14a8a9183e73a025150b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27888d536d14a8a9183e73a025150b5">&#9670;&nbsp;</a></span>stdDeviation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt;double&gt; icl::core::stdDeviation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>poImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roiOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the std::deviation of an image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poImage</td><td>input image </td></tr>
    <tr><td class="paramname">iChannel</td><td>channel index (all channels if -1) </td></tr>
    <tr><td class="paramname">roiOnly</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc5a26d8159c75cb929d9ecbb2f2cd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5a26d8159c75cb929d9ecbb2f2cd92">&#9670;&nbsp;</a></span>translateCCImlp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6">ccimpl</a> icl::core::translateCCImlp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>translates the string represenation of a </p>

</div>
</div>
<a id="ab196cf655f714b1797b44ee353d29f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab196cf655f714b1797b44ee353d29f98">&#9670;&nbsp;</a></span>translateCCImpl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::string icl::core::translateCCImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceicl_1_1core.html#a311ebb3bb437b88229c15306e43155a6">ccimpl</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>translates a ccimpl enum into a string representation </p>
<p>The returned string for ccAvailable is "available" (...) </p>

</div>
</div>
<a id="a909cc5e4d9a60ebb088bc32c33a9e7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909cc5e4d9a60ebb088bc32c33a9e7cb">&#9670;&nbsp;</a></span>variance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt;double&gt; icl::core::variance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>poImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>empiricMean</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roiOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the variance value of an image a with given mean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poImg</td><td>input imge </td></tr>
    <tr><td class="paramname">mean</td><td>vector with channel means </td></tr>
    <tr><td class="paramname">empiricMean</td><td>if true, sum of square distances is devided by n-1 else by n </td></tr>
    <tr><td class="paramname">iChannel</td><td>channel index (-1 for all channels) </td></tr>
    <tr><td class="paramname">roiOnly</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The variance value form the vector </dd></dl>

</div>
</div>
<a id="afacb81a7a685b1d22515064b4d9f0d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacb81a7a685b1d22515064b4d9f0d7b">&#9670;&nbsp;</a></span>variance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> std::vector&lt;double&gt; icl::core::variance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>poImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>roiOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the variance value of an image a. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poImg</td><td>input imge </td></tr>
    <tr><td class="paramname">iChannel</td><td>channel index (-1 for all channels) </td></tr>
    <tr><td class="paramname">roiOnly</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The variance value form the vector </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassicl_1_1core_1_1Img_html_a5551b9551361837a4cae9a5720be30bd"><div class="ttname"><a href="classicl_1_1core_1_1Img.html#a5551b9551361837a4cae9a5720be30bd">icl::core::Img::shallowCopy</a></div><div class="ttdeci">Img&lt; Type &gt; &amp; shallowCopy(const Img&lt; Type &gt; &amp;tSource)</div><div class="ttdoc">Private assign operator (internally used)</div></div>
<div class="ttc" id="anamespaceicl_1_1core_html_a45c1b0e98f54c54dde5a5494114b91a8"><div class="ttname"><a href="namespaceicl_1_1core.html#a45c1b0e98f54c54dde5a5494114b91a8">icl::core::p2o</a></div><div class="ttdeci">static T p2o(T *ptr)</div><div class="ttdoc">Conversion function to transform a pointer into an object.</div><div class="ttdef"><b>Definition:</b> Img.h:1685</div></div>
<div class="ttc" id="aclassicl_1_1core_1_1Img_html_af1b77c10cf3bcd9cca01b87d8dcae892"><div class="ttname"><a href="classicl_1_1core_1_1Img.html#af1b77c10cf3bcd9cca01b87d8dcae892">icl::core::Img::selectChannel</a></div><div class="ttdeci">Img&lt; Type &gt; * selectChannel(int channelIndex, Img&lt; Type &gt; *poDst=0)</div><div class="ttdoc">Create a shallow copy of a single image channel of an image.</div><div class="ttdef"><b>Definition:</b> Img.h:685</div></div>
<div class="ttc" id="agroup__TYPES_html_gab9ebfd5e35116d194189c8f233607414"><div class="ttname"><a href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">icl::core::Img8u</a></div><div class="ttdeci">Img&lt; icl8u &gt; Img8u</div><div class="ttdoc">typedef for 8bit integer images</div><div class="ttdef"><b>Definition:</b> Types.h:98</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 15:28:20 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
