<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::math::QuadTree&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1math.html">math</a></li><li class="navelem"><a class="el" href="classicl_1_1math_1_1QuadTree.html">QuadTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classicl_1_1math_1_1QuadTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icl::math::QuadTree&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> Implementation.  
 <a href="classicl_1_1math_1_1QuadTree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="QuadTree_8h_source.html">QuadTree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1QuadTree_1_1AABB.html">AABB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally used axis-aligned bounding box  <a href="structicl_1_1math_1_1QuadTree_1_1AABB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1QuadTree_1_1Allocator.html">Allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inernally used block allocator.  <a href="structicl_1_1math_1_1QuadTree_1_1Allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1QuadTree_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used node structure.  <a href="structicl_1_1math_1_1QuadTree_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae5287dca8d3ed9cb9aa67c9c86a7223e"><td class="memItemLeft" align="right" valign="top">typedef VECTOR_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a></td></tr>
<tr class="separator:ae5287dca8d3ed9cb9aa67c9c86a7223e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a970576a6182e3e62a7aa9768ff7de8e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a970576a6182e3e62a7aa9768ff7de8e3">QuadTree</a> (const Scalar &amp;minX, const Scalar &amp;minY, const Scalar &amp;width, const Scalar &amp;height)</td></tr>
<tr class="memdesc:a970576a6182e3e62a7aa9768ff7de8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> for the given 2D rectangle  <a href="classicl_1_1math_1_1QuadTree.html#a970576a6182e3e62a7aa9768ff7de8e3">More...</a><br /></td></tr>
<tr class="separator:a970576a6182e3e62a7aa9768ff7de8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa45f9ba387f794eb74f9c6f9b035ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#acaa45f9ba387f794eb74f9c6f9b035ab">QuadTree</a> (const <a class="el" href="classicl_1_1utils_1_1Rect32f.html">utils::Rect32f</a> &amp;bounds)</td></tr>
<tr class="memdesc:acaa45f9ba387f794eb74f9c6f9b035ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience constructor wrapper for given Rect32f bounds  <a href="classicl_1_1math_1_1QuadTree.html#acaa45f9ba387f794eb74f9c6f9b035ab">More...</a><br /></td></tr>
<tr class="separator:acaa45f9ba387f794eb74f9c6f9b035ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad152e059ed5af392c6f957ca5474ef9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ad152e059ed5af392c6f957ca5474ef9d">QuadTree</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;bounds)</td></tr>
<tr class="memdesc:ad152e059ed5af392c6f957ca5474ef9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience constructor wrapper for given Rect32f bounds  <a href="classicl_1_1math_1_1QuadTree.html#ad152e059ed5af392c6f957ca5474ef9d">More...</a><br /></td></tr>
<tr class="separator:ad152e059ed5af392c6f957ca5474ef9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af058996b5a8ac287dd7d732e1522fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a2af058996b5a8ac287dd7d732e1522fb">QuadTree</a> (const Scalar &amp;width, const Scalar &amp;height)</td></tr>
<tr class="memdesc:a2af058996b5a8ac287dd7d732e1522fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> for the given 2D Size (minX and minY are set to 0 here)  <a href="classicl_1_1math_1_1QuadTree.html#a2af058996b5a8ac287dd7d732e1522fb">More...</a><br /></td></tr>
<tr class="separator:a2af058996b5a8ac287dd7d732e1522fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc6776e310f36823176932fb0b352e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a8cc6776e310f36823176932fb0b352e8">QuadTree</a> (const <a class="el" href="classicl_1_1utils_1_1Size32f.html">utils::Size32f</a> &amp;<a class="el" href="classicl_1_1math_1_1QuadTree.html#a34e61206860b0acfae1359760367b6e4">size</a>)</td></tr>
<tr class="memdesc:a8cc6776e310f36823176932fb0b352e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper for given Size32f bounds  <a href="classicl_1_1math_1_1QuadTree.html#a8cc6776e310f36823176932fb0b352e8">More...</a><br /></td></tr>
<tr class="separator:a8cc6776e310f36823176932fb0b352e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b87447e49b8a640e40130f29918866"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a73b87447e49b8a640e40130f29918866">QuadTree</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;<a class="el" href="classicl_1_1math_1_1QuadTree.html#a34e61206860b0acfae1359760367b6e4">size</a>)</td></tr>
<tr class="memdesc:a73b87447e49b8a640e40130f29918866"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper for given Size bounds  <a href="classicl_1_1math_1_1QuadTree.html#a73b87447e49b8a640e40130f29918866">More...</a><br /></td></tr>
<tr class="separator:a73b87447e49b8a640e40130f29918866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee34be84c40e69ab90688b5b78bb539"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a2ee34be84c40e69ab90688b5b78bb539">~QuadTree</a> ()</td></tr>
<tr class="memdesc:a2ee34be84c40e69ab90688b5b78bb539"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="classicl_1_1math_1_1QuadTree.html#a2ee34be84c40e69ab90688b5b78bb539">More...</a><br /></td></tr>
<tr class="separator:a2ee34be84c40e69ab90688b5b78bb539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50d83e728805f9b095fe130f0178efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ad50d83e728805f9b095fe130f0178efa">nn_approx</a> (const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &amp;p) const</td></tr>
<tr class="memdesc:ad50d83e728805f9b095fe130f0178efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an approximated nearst neighbour  <a href="classicl_1_1math_1_1QuadTree.html#ad50d83e728805f9b095fe130f0178efa">More...</a><br /></td></tr>
<tr class="separator:ad50d83e728805f9b095fe130f0178efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cf537efbd0c88956cc1bfc8b15268d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ac1cf537efbd0c88956cc1bfc8b15268d">nn</a> (const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &amp;pIn) const</td></tr>
<tr class="memdesc:ac1cf537efbd0c88956cc1bfc8b15268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the nearest neighbor to the given node  <a href="classicl_1_1math_1_1QuadTree.html#ac1cf537efbd0c88956cc1bfc8b15268d">More...</a><br /></td></tr>
<tr class="separator:ac1cf537efbd0c88956cc1bfc8b15268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849f1c3f14fa18c56b50c7b2698a7efb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a849f1c3f14fa18c56b50c7b2698a7efb">nn</a> (const <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> &amp;p) const</td></tr>
<tr class="memdesc:a849f1c3f14fa18c56b50c7b2698a7efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper for the Point32f type  <a href="classicl_1_1math_1_1QuadTree.html#a849f1c3f14fa18c56b50c7b2698a7efb">More...</a><br /></td></tr>
<tr class="separator:a849f1c3f14fa18c56b50c7b2698a7efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f912dbfb35a2a7d231c124a7020c4c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a6f912dbfb35a2a7d231c124a7020c4c3">nn</a> (const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;p) const</td></tr>
<tr class="memdesc:a6f912dbfb35a2a7d231c124a7020c4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper for the Point32f type  <a href="classicl_1_1math_1_1QuadTree.html#a6f912dbfb35a2a7d231c124a7020c4c3">More...</a><br /></td></tr>
<tr class="separator:a6f912dbfb35a2a7d231c124a7020c4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0e204985901c56ad5fb4c39ed86611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a3e0e204985901c56ad5fb4c39ed86611">insert</a> (const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &amp;pIn)</td></tr>
<tr class="memdesc:a3e0e204985901c56ad5fb4c39ed86611"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a node into the <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a>  <a href="classicl_1_1math_1_1QuadTree.html#a3e0e204985901c56ad5fb4c39ed86611">More...</a><br /></td></tr>
<tr class="separator:a3e0e204985901c56ad5fb4c39ed86611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab888ce309285e0e5079cfa4459ba748a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ab888ce309285e0e5079cfa4459ba748a">insert</a> (const <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> &amp;p)</td></tr>
<tr class="memdesc:ab888ce309285e0e5079cfa4459ba748a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper for the Point32f instances  <a href="classicl_1_1math_1_1QuadTree.html#ab888ce309285e0e5079cfa4459ba748a">More...</a><br /></td></tr>
<tr class="separator:ab888ce309285e0e5079cfa4459ba748a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabf63b6087d525575b4b5f034663f6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#adabf63b6087d525575b4b5f034663f6d">insert</a> (const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;p)</td></tr>
<tr class="memdesc:adabf63b6087d525575b4b5f034663f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper for the Point instances  <a href="classicl_1_1math_1_1QuadTree.html#adabf63b6087d525575b4b5f034663f6d">More...</a><br /></td></tr>
<tr class="separator:adabf63b6087d525575b4b5f034663f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384c8cf9201ba2ec497821cb49c6417c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a384c8cf9201ba2ec497821cb49c6417c">query</a> (const Scalar &amp;minX, const Scalar &amp;minY, const Scalar &amp;width, const Scalar &amp;height) const</td></tr>
<tr class="memdesc:a384c8cf9201ba2ec497821cb49c6417c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all contained points within the given rectangle  <a href="classicl_1_1math_1_1QuadTree.html#a384c8cf9201ba2ec497821cb49c6417c">More...</a><br /></td></tr>
<tr class="separator:a384c8cf9201ba2ec497821cb49c6417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c26f7ff2e30d0908b7119bdc6d995d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5c26f7ff2e30d0908b7119bdc6d995d">query</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;r) const</td></tr>
<tr class="memdesc:ae5c26f7ff2e30d0908b7119bdc6d995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper for Rect class  <a href="classicl_1_1math_1_1QuadTree.html#ae5c26f7ff2e30d0908b7119bdc6d995d">More...</a><br /></td></tr>
<tr class="separator:ae5c26f7ff2e30d0908b7119bdc6d995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88210a0fe056fd0ea1edd8cb83591b35"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a88210a0fe056fd0ea1edd8cb83591b35">query</a> (const <a class="el" href="classicl_1_1utils_1_1Rect32f.html">utils::Rect32f</a> &amp;r) const</td></tr>
<tr class="memdesc:a88210a0fe056fd0ea1edd8cb83591b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper for Rect32f class  <a href="classicl_1_1math_1_1QuadTree.html#a88210a0fe056fd0ea1edd8cb83591b35">More...</a><br /></td></tr>
<tr class="separator:a88210a0fe056fd0ea1edd8cb83591b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86ed694ca1ba4c5fd67cced84afe1b5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ad86ed694ca1ba4c5fd67cced84afe1b5">queryAll</a> () const</td></tr>
<tr class="memdesc:ad86ed694ca1ba4c5fd67cced84afe1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all contained points  <a href="classicl_1_1math_1_1QuadTree.html#ad86ed694ca1ba4c5fd67cced84afe1b5">More...</a><br /></td></tr>
<tr class="separator:ad86ed694ca1ba4c5fd67cced84afe1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9be4f3c84f70c81c0513eeaa2101d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1VisualizationDescription.html">utils::VisualizationDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a1d9be4f3c84f70c81c0513eeaa2101d0">vis</a> () const</td></tr>
<tr class="memdesc:a1d9be4f3c84f70c81c0513eeaa2101d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a visualization description for <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> structure (not for the contained points)  <a href="classicl_1_1math_1_1QuadTree.html#a1d9be4f3c84f70c81c0513eeaa2101d0">More...</a><br /></td></tr>
<tr class="separator:a1d9be4f3c84f70c81c0513eeaa2101d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7066a8291da619925e7c1e3e14798f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#abf7066a8291da619925e7c1e3e14798f">clear</a> ()</td></tr>
<tr class="memdesc:abf7066a8291da619925e7c1e3e14798f"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes all contained points and nodes  <a href="classicl_1_1math_1_1QuadTree.html#abf7066a8291da619925e7c1e3e14798f">More...</a><br /></td></tr>
<tr class="separator:abf7066a8291da619925e7c1e3e14798f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e61206860b0acfae1359760367b6e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a34e61206860b0acfae1359760367b6e4">size</a> () const</td></tr>
<tr class="memdesc:a34e61206860b0acfae1359760367b6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elments inserted  <a href="classicl_1_1math_1_1QuadTree.html#a34e61206860b0acfae1359760367b6e4">More...</a><br /></td></tr>
<tr class="separator:a34e61206860b0acfae1359760367b6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c0b2c0c3746a1cdf2b808792dd72d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a06c0b2c0c3746a1cdf2b808792dd72d3">printStructure</a> ()</td></tr>
<tr class="memdesc:a06c0b2c0c3746a1cdf2b808792dd72d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints the quad-tree structure hierachically (for debug purpose)  <a href="classicl_1_1math_1_1QuadTree.html#a06c0b2c0c3746a1cdf2b808792dd72d3">More...</a><br /></td></tr>
<tr class="separator:a06c0b2c0c3746a1cdf2b808792dd72d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9d71660d7b5311e2d17289483e769a58"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a9d71660d7b5311e2d17289483e769a58">nn_approx_internal</a> (const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &amp;p, double &amp;currMinDist, const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> *&amp;currNN) const</td></tr>
<tr class="memdesc:a9d71660d7b5311e2d17289483e769a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal utility method that is used to find an approximated nearest neighbour  <a href="classicl_1_1math_1_1QuadTree.html#a9d71660d7b5311e2d17289483e769a58">More...</a><br /></td></tr>
<tr class="separator:a9d71660d7b5311e2d17289483e769a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0792c4039ff88e91e4ecedd16d6871c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1QuadTree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a0792c4039ff88e91e4ecedd16d6871c1">root</a></td></tr>
<tr class="memdesc:a0792c4039ff88e91e4ecedd16d6871c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">root node pointer  <a href="classicl_1_1math_1_1QuadTree.html#a0792c4039ff88e91e4ecedd16d6871c1">More...</a><br /></td></tr>
<tr class="separator:a0792c4039ff88e91e4ecedd16d6871c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c95b9c67879398b39755b0cee33a87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1QuadTree_1_1Allocator.html">Allocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a26c95b9c67879398b39755b0cee33a87">alloc</a></td></tr>
<tr class="memdesc:a26c95b9c67879398b39755b0cee33a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory allocator for all children except for the root node  <a href="classicl_1_1math_1_1QuadTree.html#a26c95b9c67879398b39755b0cee33a87">More...</a><br /></td></tr>
<tr class="separator:a26c95b9c67879398b39755b0cee33a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a36863eeb4138ea6a6ec9740dfa5a65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1QuadTree.html#a6a36863eeb4138ea6a6ec9740dfa5a65">num</a></td></tr>
<tr class="memdesc:a6a36863eeb4138ea6a6ec9740dfa5a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal counter for the number of contained points  <a href="classicl_1_1math_1_1QuadTree.html#a6a36863eeb4138ea6a6ec9740dfa5a65">More...</a><br /></td></tr>
<tr class="separator:a6a36863eeb4138ea6a6ec9740dfa5a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Scalar, int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE = FixedColVector&lt;Scalar,2&gt;&gt;<br />
class icl::math::QuadTree&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;</h3>

<p>Generic <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> Implementation. </p>
<p>The implementation follows the pseudo code from Wikipedia. However, we added some performance related implementation enhancements.</p>
<h1><a class="anchor" id="TMP"></a>
Template Parameters</h1>
<p><b>Scalar</b> the internal data type, which must be either float or double <b>CAPACITY</b> the node capacity. This defines the number of Points, that are stored in each node. Due to an internal optimization, best performace in terms insertion and nearest-neighbor search is given for CAPACITIES in the range of 32 to 128 entries. <b>SF</b> the internal data scale factor. This can be used to reach a higher exact integer resolution when splitting regions. The scale factor should usually be a power of two. In our benchmarks, it turned out, that using a non-1 scalefactor does not affect the speed of the quadtree's methods. We recommend to use a scalefactor of 32, which ensures at least 5 quad-tree levels can be split perfectly, while still allowing a data range of [-67M,67M] (2^(31-5)). <b>ALLOC_CHUNK_SIZE</b> This parameters does actually not alter the performance very much. It defines the size of memory blocks allocated by the internal block allocator</p>
<h1><a class="anchor" id="PERF"></a>
Performance</h1>
<p>As far as we can say, the implementation is quite fast. For now, we will only provide a few examples; a full evaluation will be given soon.</p>
<p>System: 2.4GHz Core2Duo, Ubuntu 12.04 32Bit, 4 GB Ram, Optimized build (-O4 -march=native)</p>
<p>Experiment base line:</p>
<p>QuadTree&lt;float,32,1,1024&gt; with VGA bounds, containing 100K points uniformly distributed. for integers an upscaling factor of 32 is used: QuadTree&lt;int,32,32,1024&gt; with VGA bounds, containing 100K points uniformly distributed. Using no scale factor (SF = 1) does not lead to faster processing!</p>
<p>Tasks are:</p>
<p>insertion nearest neighbor search of 1000 random points approximate nearest neighbor search of 1000 random points query a huge region: Rect(100,100,500,350), containing 57% of all points</p>
<h2><a class="anchor" id="E1"></a>
Experiment 1 (Base line results)</h2>
<p>(numbers in round braces refer to the integer quadtree performance)</p>
<p>In particular the nearest neighbour search, that is dominated by comparing nodes and distances runs about 3 time faster for integers.</p>
<p>insertion: 5.8ms (5.4ms) nn-search: 3.6ms (1.2ms) approx. nn: 0.19ms (0.15ms) query: 1.7ms (1.7ms)</p>
<h2><a class="anchor" id="E2"></a>
Experiment 2 (Using smaller Nodes of CAPACITY 4)</h2>
<p>Smaller nodes implicate more structure and a deeper node hierarchy. This makes all parts significantly slower. In particular the nn-search is affecter. Here, the list of points in each node can be compared without using the square-root function, which is very time consuming.</p>
<p>The nearest neighbor search performance for integer processing is still about two times faster</p>
<p>insertion: 9.6ms (9.6ms) nn-search: 1.7ms (0.9ms) approx. nn: 0.16ms (0.12ms) query: 2.3ms (2.3ms)</p>
<h2><a class="anchor" id="E2b"></a>
Experiment 2b (Using larger Nodes of CAPACITY 128)</h2>
<p>Here, again, we can see that larger nodes speed up the insertion part, while the nn-search optimization is already saturated here.</p>
<p>insertion: 4.5ms (4.6ms) nn-search: 6.5ms (2.5ms) approx nn: 0.31ms (0.31ms) query: 1.73ms (1.72ms)</p>
<h2><a class="anchor" id="E3"></a>
Experiment 3 (Using 10K Points only)</h2>
<p>With less points, the whole system gets significantly faster. In particular insertion and query is more then 10-times as fast which can be explained by better caching properties. The nearest neighbour search has a logarithmic complexity and is sped up least.</p>
<p>insertion: 0.4ms (0.34ms) nn-search: 2.4ms (1.07ms) approx. nn: 0.16ms (0.287ms) query: 0.16ms (0.17ms)</p>
<h2><a class="anchor" id="E4"></a>
Experiment 4 (Using 1000K Points)</h2>
<p>Obviously, we face caching issues here: While 10K and even 100K points could easily be cached, the whole structure cannot be cached with 1000K points. Therefore, insertion gets significantly slower. The logarithmic complexity of the nn-search stays valid and make this part not become that much slower. The approximate nn-search is not affected so strongly because it majorly depends on the node capacity.</p>
<p>insertion: 130ms (123ms) nn-search: 8ms (1.5ms) approx. nn: 0.33ms (0.18ms) query: 26ms (27ms)</p>
<h2><a class="anchor" id="E5"></a>
Experiment 5 (Using 1000K Points, but with Node CAPACITY 128)</h2>
<p>Here, the insertion time gets smaller, because less nodes have to be created. On the other hand, the nn-search takes slightly longer</p>
<p>insertion: 87ms (85ms) nn-search: 9.8ms (3ms) approx. nn: 0.3ms (0.23ms) query: 23ms (24ms)</p>
<h2><a class="anchor" id="E6"></a>
Experiment 6 (Using 1000K Points, but with Node CAPACITY 1024)</h2>
<p>Same effect as before, but much stronger. The approximate nn-search becomes alot slower, because all CAPACITY points in the best matching cell must be checked. However, the approximate results are usually more accurate here</p>
<p>insertion: 55ms (54ms) nn-search: 41ms (17ms) approx. nn: 2.7ms (2.7ms) query: 22.8ms (22.8ms) </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae5287dca8d3ed9cb9aa67c9c86a7223e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5287dca8d3ed9cb9aa67c9c86a7223e">&#9670;&nbsp;</a></span>Pt</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VECTOR_TYPE <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::<a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a970576a6182e3e62a7aa9768ff7de8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970576a6182e3e62a7aa9768ff7de8e3">&#9670;&nbsp;</a></span>QuadTree() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::<a class="el" href="classicl_1_1math_1_1QuadTree.html">QuadTree</a> </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> for the given 2D rectangle </p>

</div>
</div>
<a id="acaa45f9ba387f794eb74f9c6f9b035ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaa45f9ba387f794eb74f9c6f9b035ab">&#9670;&nbsp;</a></span>QuadTree() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::<a class="el" href="classicl_1_1math_1_1QuadTree.html">QuadTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect32f.html">utils::Rect32f</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience constructor wrapper for given Rect32f bounds </p>

</div>
</div>
<a id="ad152e059ed5af392c6f957ca5474ef9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad152e059ed5af392c6f957ca5474ef9d">&#9670;&nbsp;</a></span>QuadTree() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::<a class="el" href="classicl_1_1math_1_1QuadTree.html">QuadTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience constructor wrapper for given Rect32f bounds </p>

</div>
</div>
<a id="a2af058996b5a8ac287dd7d732e1522fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af058996b5a8ac287dd7d732e1522fb">&#9670;&nbsp;</a></span>QuadTree() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::<a class="el" href="classicl_1_1math_1_1QuadTree.html">QuadTree</a> </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> for the given 2D Size (minX and minY are set to 0 here) </p>

</div>
</div>
<a id="a8cc6776e310f36823176932fb0b352e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc6776e310f36823176932fb0b352e8">&#9670;&nbsp;</a></span>QuadTree() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::<a class="el" href="classicl_1_1math_1_1QuadTree.html">QuadTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size32f.html">utils::Size32f</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper for given Size32f bounds </p>

</div>
</div>
<a id="a73b87447e49b8a640e40130f29918866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b87447e49b8a640e40130f29918866">&#9670;&nbsp;</a></span>QuadTree() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::<a class="el" href="classicl_1_1math_1_1QuadTree.html">QuadTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper for given Size bounds </p>

</div>
</div>
<a id="a2ee34be84c40e69ab90688b5b78bb539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee34be84c40e69ab90688b5b78bb539">&#9670;&nbsp;</a></span>~QuadTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::~<a class="el" href="classicl_1_1math_1_1QuadTree.html">QuadTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<p>Deletes the root node only, all other nodes are deleted by the allocator </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abf7066a8291da619925e7c1e3e14798f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7066a8291da619925e7c1e3e14798f">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes all contained points and nodes </p>
<p>The allocator will free all memory except for the first CHUNK </p>

</div>
</div>
<a id="a3e0e204985901c56ad5fb4c39ed86611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0e204985901c56ad5fb4c39ed86611">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &amp;&#160;</td>
          <td class="paramname"><em>pIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts a node into the <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> </p>
<p>This method is also implemented in an iterative fashion for performance issues. 'insert' automatically uses the internal allocator if new nodes are needed. </p>

</div>
</div>
<a id="adabf63b6087d525575b4b5f034663f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabf63b6087d525575b4b5f034663f6d">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper for the Point instances </p>

</div>
</div>
<a id="ab888ce309285e0e5079cfa4459ba748a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab888ce309285e0e5079cfa4459ba748a">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper for the Point32f instances </p>

</div>
</div>
<a id="ac1cf537efbd0c88956cc1bfc8b15268d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cf537efbd0c88956cc1bfc8b15268d">&#9670;&nbsp;</a></span>nn() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::nn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &amp;&#160;</td>
          <td class="paramname"><em>pIn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds the nearest neighbor to the given node </p>
<p>The implementation of this method explicitly avoids recursion by using a run-time stack. This leads to a 4x speed factor in comparison to the recursive implementaiton of this function.</p>
<p>As an extra accelleration, the method initializes it's frist nearest neighbor guess using the nn_approx method, which gives an approximate speed up of factor two to four.</p>
<p>As a 2nd accelleration heuristic, all CAPACITY nodes' distances are are first calculated and compared in a squared version, which can be computed without an expensive square-root operation. However, once the closest point within a single node is found, its real euclidian minimum distance is computed and stored for further bounding box checks.</p>
<p>If no neighbour could be found, an exception is thown. This should actually only happen when nn is called on an empty <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> </p>

</div>
</div>
<a id="a6f912dbfb35a2a7d231c124a7020c4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f912dbfb35a2a7d231c124a7020c4c3">&#9670;&nbsp;</a></span>nn() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::nn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper for the Point32f type </p>

</div>
</div>
<a id="a849f1c3f14fa18c56b50c7b2698a7efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849f1c3f14fa18c56b50c7b2698a7efb">&#9670;&nbsp;</a></span>nn() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::nn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper for the Point32f type </p>

</div>
</div>
<a id="ad50d83e728805f9b095fe130f0178efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50d83e728805f9b095fe130f0178efa">&#9670;&nbsp;</a></span>nn_approx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::nn_approx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an approximated nearst neighbour </p>
<p>While the real nearst neighbour must not neccessarily be in the cell that would theoretically contain p, The approximated one is always assumed to be in that bottom layer cell. If, by chance, the optimal leaf node does not contain any points (because it was just created as empty leaf), the leaf's parent node, which must actually contain CAPACITY points, is used instead. The approximate nearest neighbour search can easily be 5 times as fast as the real nearest neighbor search. The result quality depends on the number of contained points, and on the <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a>'s template parameters </p>

</div>
</div>
<a id="a9d71660d7b5311e2d17289483e769a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d71660d7b5311e2d17289483e769a58">&#9670;&nbsp;</a></span>nn_approx_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a>&amp; <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::nn_approx_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>currMinDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a> *&amp;&#160;</td>
          <td class="paramname"><em>currNN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal utility method that is used to find an approximated nearest neighbour </p>

</div>
</div>
<a id="a06c0b2c0c3746a1cdf2b808792dd72d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c0b2c0c3746a1cdf2b808792dd72d3">&#9670;&nbsp;</a></span>printStructure()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::printStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints the quad-tree structure hierachically (for debug purpose) </p>

</div>
</div>
<a id="a384c8cf9201ba2ec497821cb49c6417c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384c8cf9201ba2ec497821cb49c6417c">&#9670;&nbsp;</a></span>query() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a>&gt; <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::query </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns all contained points within the given rectangle </p>

</div>
</div>
<a id="ae5c26f7ff2e30d0908b7119bdc6d995d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c26f7ff2e30d0908b7119bdc6d995d">&#9670;&nbsp;</a></span>query() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a>&gt; <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper for Rect class </p>

</div>
</div>
<a id="a88210a0fe056fd0ea1edd8cb83591b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88210a0fe056fd0ea1edd8cb83591b35">&#9670;&nbsp;</a></span>query() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a>&gt; <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect32f.html">utils::Rect32f</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper for Rect32f class </p>

</div>
</div>
<a id="ad86ed694ca1ba4c5fd67cced84afe1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86ed694ca1ba4c5fd67cced84afe1b5">&#9670;&nbsp;</a></span>queryAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classicl_1_1math_1_1QuadTree.html#ae5287dca8d3ed9cb9aa67c9c86a7223e">Pt</a>&gt; <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::queryAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns all contained points </p>

</div>
</div>
<a id="a34e61206860b0acfae1359760367b6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e61206860b0acfae1359760367b6e4">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of elments inserted </p>

</div>
</div>
<a id="a1d9be4f3c84f70c81c0513eeaa2101d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9be4f3c84f70c81c0513eeaa2101d0">&#9670;&nbsp;</a></span>vis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1VisualizationDescription.html">utils::VisualizationDescription</a> <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::vis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a visualization description for <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> structure (not for the contained points) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a26c95b9c67879398b39755b0cee33a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c95b9c67879398b39755b0cee33a87">&#9670;&nbsp;</a></span>alloc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1QuadTree_1_1Allocator.html">Allocator</a> <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>memory allocator for all children except for the root node </p>

</div>
</div>
<a id="a6a36863eeb4138ea6a6ec9740dfa5a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a36863eeb4138ea6a6ec9740dfa5a65">&#9670;&nbsp;</a></span>num</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal counter for the number of contained points </p>

</div>
</div>
<a id="a0792c4039ff88e91e4ecedd16d6871c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0792c4039ff88e91e4ecedd16d6871c1">&#9670;&nbsp;</a></span>root</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 4, int SF = 1, int ALLOC_CHUNK_SIZE = 1024, class VECTOR_TYPE  = FixedColVector&lt;Scalar,2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1QuadTree_1_1Node.html">Node</a>* <a class="el" href="classicl_1_1math_1_1QuadTree.html">icl::math::QuadTree</a>&lt; Scalar, CAPACITY, SF, ALLOC_CHUNK_SIZE, VECTOR_TYPE &gt;::root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>root node pointer </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/icl/icl/ICLMath/src/ICLMath/<a class="el" href="QuadTree_8h_source.html">QuadTree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 15:28:23 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
