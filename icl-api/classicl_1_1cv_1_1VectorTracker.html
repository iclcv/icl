<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::cv::VectorTracker Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1cv.html">cv</a></li><li class="navelem"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html">VectorTracker</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classicl_1_1cv_1_1VectorTracker-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icl::cv::VectorTracker Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Extension of the position tracker class for N-dimensional positions.  
 <a href="classicl_1_1cv_1_1VectorTracker.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="VectorTracker_8h_source.html">VectorTracker.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad1b100e1fd0cc9c841b6804bed9e26ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ad1b100e1fd0cc9c841b6804bed9e26ca">IDmode</a> { <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ad1b100e1fd0cc9c841b6804bed9e26caa4040397d06d7f81efad56e57ca738931">firstFree</a>, 
<a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ad1b100e1fd0cc9c841b6804bed9e26caa4c923b7facfe56036ea409d0347916c9">brandNew</a>
 }</td></tr>
<tr class="memdesc:ad1b100e1fd0cc9c841b6804bed9e26ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines how ids are allocated internally.  <a href="classicl_1_1cv_1_1VectorTracker.html#ad1b100e1fd0cc9c841b6804bed9e26ca">More...</a><br /></td></tr>
<tr class="separator:ad1b100e1fd0cc9c841b6804bed9e26ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc09bb75ed4693fba2468644435901a2"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#abc09bb75ed4693fba2468644435901a2">Vec</a></td></tr>
<tr class="memdesc:abc09bb75ed4693fba2468644435901a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector Type.  <a href="classicl_1_1cv_1_1VectorTracker.html#abc09bb75ed4693fba2468644435901a2">More...</a><br /></td></tr>
<tr class="separator:abc09bb75ed4693fba2468644435901a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe74d7225700e7b2b91f2ac754c8c11"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structicl_1_1utils_1_1Function.html">utils::Function</a>&lt; float, const <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#abc09bb75ed4693fba2468644435901a2">Vec</a> &amp;, const <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#abc09bb75ed4693fba2468644435901a2">Vec</a> &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a1fe74d7225700e7b2b91f2ac754c8c11">DistanceFunction</a></td></tr>
<tr class="separator:a1fe74d7225700e7b2b91f2ac754c8c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91ac5927c69420df501ef668f48d4173"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a91ac5927c69420df501ef668f48d4173">VectorTracker</a> ()</td></tr>
<tr class="memdesc:a91ac5927c69420df501ef668f48d4173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty (null) vector tracker (<a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a278bec4a45fbc930bdc49296fb29ee8e" title="returns whether VectorTracker instance is currently null (created with default constructor)">isNull()</a> returns true then)  <a href="classicl_1_1cv_1_1VectorTracker.html#a91ac5927c69420df501ef668f48d4173">More...</a><br /></td></tr>
<tr class="separator:a91ac5927c69420df501ef668f48d4173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6805e0505756a32dba5d57178e432b2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a6805e0505756a32dba5d57178e432b2f">VectorTracker</a> (int dim, float largeDistance, const std::vector&lt; float &gt; &amp;normFactors=std::vector&lt; float &gt;(), <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ad1b100e1fd0cc9c841b6804bed9e26ca">IDmode</a> idMode=<a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ad1b100e1fd0cc9c841b6804bed9e26caa4040397d06d7f81efad56e57ca738931">firstFree</a>, float distanceThreshold=0, bool tryOpt=true, <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a1fe74d7225700e7b2b91f2ac754c8c11">DistanceFunction</a> df=<a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a1fe74d7225700e7b2b91f2ac754c8c11">DistanceFunction</a>(), bool dfIsQualityFunction=false)</td></tr>
<tr class="memdesc:a6805e0505756a32dba5d57178e432b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new <a class="el" href="classicl_1_1cv_1_1VectorTracker.html" title="Extension of the position tracker class for N-dimensional positions.">VectorTracker</a> instance with given parameters.  <a href="classicl_1_1cv_1_1VectorTracker.html#a6805e0505756a32dba5d57178e432b2f">More...</a><br /></td></tr>
<tr class="separator:a6805e0505756a32dba5d57178e432b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20bdb4a55edda07396ef38d624e0b33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ae20bdb4a55edda07396ef38d624e0b33">VectorTracker</a> (const <a class="el" href="classicl_1_1cv_1_1VectorTracker.html">VectorTracker</a> &amp;other)</td></tr>
<tr class="memdesc:ae20bdb4a55edda07396ef38d624e0b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy constructor (all data and current state is copied deeply)  <a href="classicl_1_1cv_1_1VectorTracker.html#ae20bdb4a55edda07396ef38d624e0b33">More...</a><br /></td></tr>
<tr class="separator:ae20bdb4a55edda07396ef38d624e0b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae698218e21e6a949b9d6194e4101784a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html">VectorTracker</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ae698218e21e6a949b9d6194e4101784a">operator=</a> (const <a class="el" href="classicl_1_1cv_1_1VectorTracker.html">VectorTracker</a> &amp;other)</td></tr>
<tr class="memdesc:ae698218e21e6a949b9d6194e4101784a"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment (all data and current state is copied deeply)  <a href="classicl_1_1cv_1_1VectorTracker.html#ae698218e21e6a949b9d6194e4101784a">More...</a><br /></td></tr>
<tr class="separator:ae698218e21e6a949b9d6194e4101784a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7bf063ae155296cb61542912a1ec76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a2c7bf063ae155296cb61542912a1ec76">~VectorTracker</a> ()</td></tr>
<tr class="memdesc:a2c7bf063ae155296cb61542912a1ec76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classicl_1_1cv_1_1VectorTracker.html#a2c7bf063ae155296cb61542912a1ec76">More...</a><br /></td></tr>
<tr class="separator:a2c7bf063ae155296cb61542912a1ec76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3148a482690fa5f38e0fdb212ef0440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ab3148a482690fa5f38e0fdb212ef0440">pushData</a> (const std::vector&lt; <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#abc09bb75ed4693fba2468644435901a2">Vec</a> &gt; &amp;newData)</td></tr>
<tr class="memdesc:ab3148a482690fa5f38e0fdb212ef0440"><td class="mdescLeft">&#160;</td><td class="mdescRight">next step function most efficient version  <a href="classicl_1_1cv_1_1VectorTracker.html#ab3148a482690fa5f38e0fdb212ef0440">More...</a><br /></td></tr>
<tr class="separator:ab3148a482690fa5f38e0fdb212ef0440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e09b79d2a2513354c607129564f33e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a59e09b79d2a2513354c607129564f33e">getID</a> (int index, float *lastErrorOrScore=0) const</td></tr>
<tr class="memdesc:a59e09b79d2a2513354c607129564f33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns runtime id of last pushed data element index  <a href="classicl_1_1cv_1_1VectorTracker.html#a59e09b79d2a2513354c607129564f33e">More...</a><br /></td></tr>
<tr class="separator:a59e09b79d2a2513354c607129564f33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278bec4a45fbc930bdc49296fb29ee8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a278bec4a45fbc930bdc49296fb29ee8e">isNull</a> () const</td></tr>
<tr class="memdesc:a278bec4a45fbc930bdc49296fb29ee8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <a class="el" href="classicl_1_1cv_1_1VectorTracker.html" title="Extension of the position tracker class for N-dimensional positions.">VectorTracker</a> instance is currently null (created with default constructor)  <a href="classicl_1_1cv_1_1VectorTracker.html#a278bec4a45fbc930bdc49296fb29ee8e">More...</a><br /></td></tr>
<tr class="separator:a278bec4a45fbc930bdc49296fb29ee8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f38f287db04c60cdb1cf477cf91921b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a6f38f287db04c60cdb1cf477cf91921b">getDim</a> () const</td></tr>
<tr class="memdesc:a6f38f287db04c60cdb1cf477cf91921b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return current data dimension  <a href="classicl_1_1cv_1_1VectorTracker.html#a6f38f287db04c60cdb1cf477cf91921b">More...</a><br /></td></tr>
<tr class="separator:a6f38f287db04c60cdb1cf477cf91921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ad806720ed622f2b069ec82d1f9236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ad0ad806720ed622f2b069ec82d1f9236">setExtrapolationMask</a> (const std::vector&lt; bool &gt; &amp;mask)</td></tr>
<tr class="memdesc:ad0ad806720ed622f2b069ec82d1f9236"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally sets the extrapolation mask  <a href="classicl_1_1cv_1_1VectorTracker.html#ad0ad806720ed622f2b069ec82d1f9236">More...</a><br /></td></tr>
<tr class="separator:ad0ad806720ed622f2b069ec82d1f9236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17bda32774310efc36cf531110e5660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ab17bda32774310efc36cf531110e5660">setDistanceFunction</a> (<a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a1fe74d7225700e7b2b91f2ac754c8c11">DistanceFunction</a> df)</td></tr>
<tr class="memdesc:ab17bda32774310efc36cf531110e5660"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a custom distance function  <a href="classicl_1_1cv_1_1VectorTracker.html#ab17bda32774310efc36cf531110e5660">More...</a><br /></td></tr>
<tr class="separator:ab17bda32774310efc36cf531110e5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1941ac3ab44b52ee7764dff850ef18"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#aed1941ac3ab44b52ee7764dff850ef18">getExtrapolationMask</a> () const</td></tr>
<tr class="memdesc:aed1941ac3ab44b52ee7764dff850ef18"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current extrapolation mask  <a href="classicl_1_1cv_1_1VectorTracker.html#aed1941ac3ab44b52ee7764dff850ef18">More...</a><br /></td></tr>
<tr class="separator:aed1941ac3ab44b52ee7764dff850ef18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a67070f88e748a699052ef87faf278fa4"><td class="memItemLeft" align="right" valign="top">Data *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a67070f88e748a699052ef87faf278fa4">m_data</a></td></tr>
<tr class="memdesc:a67070f88e748a699052ef87faf278fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal data pointer  <a href="classicl_1_1cv_1_1VectorTracker.html#a67070f88e748a699052ef87faf278fa4">More...</a><br /></td></tr>
<tr class="separator:a67070f88e748a699052ef87faf278fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Extension of the position tracker class for N-dimensional positions. </p>
<p>Here's a copy of the <a class="el" href="classicl_1_1cv_1_1PositionTracker.html" title="Class for tracking 2D positions.">PositionTracker</a> documentation, which assumes 2D-input data:</p>
<p>Class for tracking 2D positions. </p>
<h1><a class="anchor" id="INTRO"></a>
Introduction</h1>
<p>The <a class="el" href="classicl_1_1cv_1_1PositionTracker.html" title="Class for tracking 2D positions.">PositionTracker</a> class provides functionalities for tracking 2D data points. Consider the output of a standard blob-detection algorithm: A list of 2D Positions of all found blobs. In a special case these positions are not labeled, e.g. because the used blob-detection-algorithm does not provide any kind of "tracking-mechanism" that pursues each single blob from one time step to the next. But although having only a list of firstly unassociated "2DPositions-snapshots", it is possible to track each blob very efficiently by proceeding form the assumption of slow or continously moving blobs. A simple brute-force approach would assign a blob at time t to the closest blob at time t-1. If the tracked blobs will move slow, and there is a margin between each blob that is <em>large enough</em>, this approach would give us good results at a complexity of O( <img class="formulaInl" alt="$n^2$" src="form_176.png"/>). But what happens if one of the assumptions was false? The answer is, that the algorithm will calculate false assignments (E.g. if a blob moves fast enough, to be closer to another blob at at time t-1, the blobs IDs may be swapped).<br  />
In addition to this, two cases must be tackled in a special way: What if some existing blobs are lost by the blob detector? And what if new blobs are found, that have no corresponding blob at time t-1?</p>
<h1><a class="anchor" id="ALGO"></a>
The Segmentation Algorithm</h1>
<p>The first adaption is quite obvious: Instead of expecting a blobs position at time t at its position at time t-1, we can predict its position regarding its history (positions at time t-1, t-2, ...). This will allow the blobs to move or accelerate (<b>but note:</b> an extrapolation of the blobs position at time t implies an implicit model-assumption, which is e.g. a quadratic one in case of regarding up to 3 former positions for each blob).<br  />
Another problem, not mentioned above, is the special case that at time t a single blob (or its extrapolated position for time t) is the nearest of more than one blob at time t-1. In this case, we have to decide which blob is assigned to the nearest, and we have to search another good match for the other one. This problem can be made arbitrary sophisticated, by factoring in further questions like "What if the next good match is already assigned to
third blob". So what we need is a general approach to minimize a kind of <em>costs</em> by assigning blobs at time t-1 (or their prediction for time t) to blobs at time t, which leads to the so called (well known) problem-class of the <b>Linear Assignment Problems</b>.<br  />
 </p>
<h1><a class="anchor" id="LAP"></a>
Linear Assignment Problems</h1>
<p>The "Assignment Problem class" is defined as follows: "There are a number of agents and a number of tasks. Any agent can be assigned to perform any task, incurring some cost that may vary depending on the agent-task assignment. It is required to perform all tasks by assigning exactly one agent to each task in such a way that the total cost of the assignment is minimized" (Wikipedia, <a href="http://en.wikipedia.org/wiki/Assignment_problem">http://en.wikipedia.org/wiki/Assignment_problem</a>).<br  />
An additional restriction leads to the class of <b>Linear</b> Assignment Problems: "If the numbers of agents and tasks are equal and the total cost of the assignment for all tasks is equal to the sum of the costs for each agent (or the sum of the costs for each task, which is the same thing in this case), then the problem is called the Linear assignment problem. Commonly, when speaking of the Assignment problem without any additional qualification, then the Linear assignment problem is meant"(Wikipedia).<br  />
 </p>
<h1><a class="anchor" id="HA"></a>
The "Hungarian Algorithm" for solving linear assignment Problems</h1>
<p>Linear assignment problems can be solved using the Hungarian Algorithm with a complexity of O( <img class="formulaInl" alt="$n^3$" src="form_177.png"/>), where n is the number of tasks as well as the number of agents. The Hungarian Algorithm is well analyzed and should not be described further here. More information is available e.g. at <a href="http://en.wikipedia.org/wiki/Hungarian_algorithm">http://en.wikipedia.org/wiki/Hungarian_algorithm</a>.<br  />
We finish this section retaining that the Hungarian Algorithm gets a NxN cost matrix C, where C(i,j) are the costs arising if blob i at t is assigned to blob j at time t-1 (or its pred.;s.o.), and it returns the N-dimensional assignment vector a, with a(i)=index of blob at time t-1 that is assigned to current blob i.</p>
<h1><a class="anchor" id="PROB"></a>
Problems</h1>
<p>As mentioned in sec. <a class="el" href="classicl_1_1cv_1_1PositionTracker.html#INTRO">Introduction</a>, we are confronted with additional compounding problems:</p><ul>
<li>New Blobs are detected, that did not exist before</li>
<li>Blobs that still existed at time t-1 are lost at time t</li>
</ul>
<p>To make use of the Hungarian Algorithm as described in sec. <a class="el" href="classicl_1_1cv_1_1PositionTracker.html#HA">The "Hungarian Algorithm" for solving linear assignment Problems</a>, we need a quadratic cost matrix, which can be emulated by inserting so called <em>blind values</em>. This values should be as different as possible from all other blob positions (e.g. MAX_INT). If blobs are lost since time t-1, we can fill up the vector of new blob positions with blind values, which has the result, that these indices are assigned to exactly these old blobs, that match worst to any new blob. In the other case, where more blobs have been found at time t as recorded at time t-1, we can fill up the vector that contains the predictions for the blobs at time t with blind values. This makes the Hungarian Algorithm assigning only <em>brand new</em> blobs to these blind ones.</p>
<h1><a class="anchor" id="DM"></a>
PositionTracker Data-Management</h1>
<p>The following ASCII illustration shows a sketch of the internally hold data: </p><pre>
data matrix scheme: | . . . . N |      (the "."-elements do not exist)
                    | I G H P D |</pre><pre>where H is the history matrix:     H = [ x(t-3) x(t-2) x(t-1) ]  and the x(T) are column vectors
                                                                 of all blob positions at time
                                                                 T, and each row r of H contains
                                                                 the history values of one blob.</pre><pre>P is the prediction vector for time t     and P(r) is the prediction result of the r-th row of the
                                          History matrix H</pre><pre>N is the vector of new data positions</pre><pre>D is the cost matrix                      where D(c,r) is the square root of the
                                          euclidian distance of P(r) and N(c)
                                          We have to use the square root and not the euclidian
                                          distnace itself, to avoid that new blobs are
                                          are mixed up with old ones (...)</pre><pre>G is the so called "good count matrix"    where G(r) is the number of valid history steps is the
                                          r-th row of H</pre><pre>I is the ID vector                        where I(r) hold a unique blob ID associated with the
                                          blob thats history complies the r-th row of H</pre><pre>detailed scheme:
                                    new data (N)
                              | o   o  x(t)  o   o
    --------------------------+-----------------------
       o      o     o      o  | d   d   d    d   d
                              |
       o      o     o      o  | d   ...
                              |
    x(t-3) x(t-2) x(t-1) x~(t)|     distances
                              |         (D)
       o      o     o      o  |
                              |
       o      o     o      o  |
                           .  |
           History        / \ |
             (H)           |
                       Prediction
                          (P)
</pre><h1><a class="anchor" id="ALGO"></a>
The Segmentation Algorithm</h1>
<p>All the work is done by calling the pushData function of a <a class="el" href="classicl_1_1cv_1_1PositionTracker.html" title="Class for tracking 2D positions.">PositionTracker</a> object. During the fist call the algorithm does not need to solve any assignment problem, so the H(t-1) is set to the new data vector N, the ID-vector is initialized with unique IDs at each position G(i)=i and the good count vector G is set up with 1 at each position.<br  />
Now a call to pushData can be described using the following pseudo code: </p><pre>
void pushData( vector newData){
  DIFF = currentDataCount - newData.dim()
  if(DIFF &lt;  0){
      push_data_diff_lower_then_zero(...)
  }else if(DIFF &gt; 0){
      push_data_diff_greater_then_zero(...)
  }else{
    push_data_diff_equal_zero(...)
  }
}</pre><pre>push_data_diff_lower_then_zero(...){
   &gt; add DIFF blind values to H(t-1)
   &gt; add DIFF ones to G
   &gt; calculate prediction vector P
   &gt; remove DIFF ones from G
   &gt; calculate the distance matrix D
   &gt; apply the Hungarian algorithm with resulting assignment vector a
   &gt; create a vector v_tmp containing only the new data points, that have been assigned to blind values
   &gt; assign the DIFF last rows of H (which were set to blind value) to this new values in
   &gt; give each of these rows a brand new id in I
   &gt; assign the good count vector at these rows to 1, increment all other good counts by one
   &gt; rearrange the new data using the assignment a
   &gt; push the rearranged new data to H from right, and pop the left-most column of H
}</pre><pre>push_data_diff_greater_then_zero(...){
   &gt; add DIFF blind values to the new data vector
   &gt; calculate prediction vector P
   &gt; calculate the distance matrix D
   &gt; apply the Hungarian algorithm with resulting assignment vector a
   &gt; rearrange the new data using the assignment a
   &gt; push the rearranged new data to H from right, and pop the left-most column of H
   &gt; create a vector v_del containing all rows, that have been assigned to blind values
   &gt; use v_del to remove no longer used rows form H, I and G
   &gt; increment all remaining elements of G
}</pre><pre>push_data_diff_equal_zero(...){
   &gt; calculate prediction vector P
   &gt; calculate the distance matrix D
   &gt; apply the Hungarian algorithm with resulting assignment vector a
   &gt; rearrange the new data using the assignment a
   &gt; increment all elements of G
}
</pre><h1><a class="anchor" id="PERFORMANCE"></a>
Performance</h1>
<p>The Hungarian algorithm has a worst case complexity of O( <img class="formulaInl" alt="$n^3$" src="form_177.png"/>), which gives the algorithm a poor performance when the Blob count is about 100 or more. The <img class="formulaInl" alt="$n^3$" src="form_177.png"/> grows very fast: 20 Blobs can be tracked in about one milli second, 200 Blobs already need about 200ms. The following two diagrams illustrate the performance: </p><div class="image">
<img src="bench1.jpg" alt="" width="4cm"/>
<div class="caption">
Performance for 2-20 Blobs</div></div>
 <div class="image">
<img src="bench2.jpg" alt="" width="4cm"/>
<div class="caption">
Performance for 0-500 Blobs (the green line is show an O(n^2) approximation, the red on is O(n^3)</div></div>
<pre class="fragment">\section OPT_ Optimization
If the optimized flag and a valid threshold is given to the constructor, the pushData function is implemented as follows:
Because in real applications, there are many successive time steps, where pushData gets the nearly equal data, pushData
trys to associate old and new data with a trivial min-distance matching: If the data dimension has not changed, for each
old data item (without extrapolation), the nearest new data item is chosen. If no conflicts arise (one old center is the
nearest to more then one new center and if all minimum distances are below the given threshold, this trivial assignment is
used. Otherwise the default algorithm is applied, and the optimization has no effect. &lt;b&gt;Note:&lt;/b&gt; If the given threshold
is smaller or equal to zero or the data dimension changes from on push call to another, no optimization is performed.
</pre> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1fe74d7225700e7b2b91f2ac754c8c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe74d7225700e7b2b91f2ac754c8c11">&#9670;&nbsp;</a></span>DistanceFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structicl_1_1utils_1_1Function.html">utils::Function</a>&lt;float,const <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#abc09bb75ed4693fba2468644435901a2">Vec</a>&amp;,const <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#abc09bb75ed4693fba2468644435901a2">Vec</a>&amp;&gt; <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a1fe74d7225700e7b2b91f2ac754c8c11">icl::cv::VectorTracker::DistanceFunction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc09bb75ed4693fba2468644435901a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc09bb75ed4693fba2468644435901a2">&#9670;&nbsp;</a></span>Vec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;float&gt; <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#abc09bb75ed4693fba2468644435901a2">icl::cv::VectorTracker::Vec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector Type. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad1b100e1fd0cc9c841b6804bed9e26ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b100e1fd0cc9c841b6804bed9e26ca">&#9670;&nbsp;</a></span>IDmode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ad1b100e1fd0cc9c841b6804bed9e26ca">icl::cv::VectorTracker::IDmode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines how ids are allocated internally. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad1b100e1fd0cc9c841b6804bed9e26caa4040397d06d7f81efad56e57ca738931"></a>firstFree&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad1b100e1fd0cc9c841b6804bed9e26caa4c923b7facfe56036ea409d0347916c9"></a>brandNew&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a91ac5927c69420df501ef668f48d4173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ac5927c69420df501ef668f48d4173">&#9670;&nbsp;</a></span>VectorTracker() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icl::cv::VectorTracker::VectorTracker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an empty (null) vector tracker (<a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a278bec4a45fbc930bdc49296fb29ee8e" title="returns whether VectorTracker instance is currently null (created with default constructor)">isNull()</a> returns true then) </p>

</div>
</div>
<a id="a6805e0505756a32dba5d57178e432b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6805e0505756a32dba5d57178e432b2f">&#9670;&nbsp;</a></span>VectorTracker() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icl::cv::VectorTracker::VectorTracker </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>largeDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>normFactors</em> = <code>std::vector&lt;&#160;float&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ad1b100e1fd0cc9c841b6804bed9e26ca">IDmode</a>&#160;</td>
          <td class="paramname"><em>idMode</em> = <code><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#ad1b100e1fd0cc9c841b6804bed9e26caa4040397d06d7f81efad56e57ca738931">firstFree</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>distanceThreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tryOpt</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a1fe74d7225700e7b2b91f2ac754c8c11">DistanceFunction</a>&#160;</td>
          <td class="paramname"><em>df</em> = <code><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a1fe74d7225700e7b2b91f2ac754c8c11">DistanceFunction</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dfIsQualityFunction</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates new <a class="el" href="classicl_1_1cv_1_1VectorTracker.html" title="Extension of the position tracker class for N-dimensional positions.">VectorTracker</a> instance with given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>data dimension (this must not changed at runtime) </td></tr>
    <tr><td class="paramname">largeDistance</td><td>to tackle element count changes, the distance matrix is padded with largeDistnace values, this must be much (e.g. 100 times ) larger then the largest real distance, that can be expected from the data. We can't use some fixed value here, as too large values lead to numerical problems </td></tr>
    <tr><td class="paramname">normFactors</td><td>Internally the euclidian distance metric can be normalized in differenct dimensions seperately: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ d(a,b) = \sqrt{ \sum\limits_{i=1}^D \left( \frac{a_i - b_i}{\sigma_i}\right)^2 } \]" src="form_188.png"/>
</p>
 In literature this is norm is reference as normalized euclidian distance. Actually we use an adapted instance of this norm: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ d(a,b) = \sqrt[4]{ \sum\limits_{i=1}^D \left( \frac{a_i - b_i}{\sigma_i}\right)^2 } \]" src="form_189.png"/>
</p>
 As mentioned in the documentation of the <a class="el" href="classicl_1_1cv_1_1PositionTracker.html" title="Class for tracking 2D positions.">PositionTracker</a>, it's compulsory to use the root of the actual norm to avoid new entries are mixed up with old ones. The norm factor vector contains the <img class="formulaInl" alt="$\sigma_i$" src="form_190.png"/> that are used in the formula above. If norm-factor is empty or all entries are set to 1, the default euclidian norm (more precisely the square root of it) is used, which increases performance slightly. If normFactor contains zeros, div-0 errors would occur, so this is checked during initialization. </td></tr>
    <tr><td class="paramname">idMode</td><td>This feature is taken from the recent <a class="el" href="classicl_1_1cv_1_1PositionTracker.html" title="Class for tracking 2D positions.">PositionTracker</a> update. It decides whether to re-use old IDs, that got free again due to the disappearing of the associated entry or to assign a brand new ID each time a new entry is found </td></tr>
    <tr><td class="paramname">distanceThreshold</td><td>As a first optimization a trivial assignment is tested. If entry count hasn't changed and each old entry can be assigned indisputably to a single new entry and each distance between estimation and current observation is beyond that threshold, the trivial assignment is used. </td></tr>
    <tr><td class="paramname">tryOpt</td><td>enables/disables whether to test for trivial assignment. If a trivial assignment can be expected, this will increase performance significantly. If it's more likely, that trivial assignment will fail, this also reduce performance a little bit. </td></tr>
    <tr><td class="paramname">df</td><td>can be set to a custom function that is used to compute the distance value between two values by default a pearson distance is used, for the normalization factors, normFactors is used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae20bdb4a55edda07396ef38d624e0b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20bdb4a55edda07396ef38d624e0b33">&#9670;&nbsp;</a></span>VectorTracker() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icl::cv::VectorTracker::VectorTracker </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1cv_1_1VectorTracker.html">VectorTracker</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep copy constructor (all data and current state is copied deeply) </p>
<p>New instance is absolutely independent from the source instance </p>

</div>
</div>
<a id="a2c7bf063ae155296cb61542912a1ec76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7bf063ae155296cb61542912a1ec76">&#9670;&nbsp;</a></span>~VectorTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icl::cv::VectorTracker::~VectorTracker </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6f38f287db04c60cdb1cf477cf91921b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f38f287db04c60cdb1cf477cf91921b">&#9670;&nbsp;</a></span>getDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icl::cv::VectorTracker::getDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return current data dimension </p>

</div>
</div>
<a id="aed1941ac3ab44b52ee7764dff850ef18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1941ac3ab44b52ee7764dff850ef18">&#9670;&nbsp;</a></span>getExtrapolationMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;bool&gt;&amp; icl::cv::VectorTracker::getExtrapolationMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current extrapolation mask </p>

</div>
</div>
<a id="a59e09b79d2a2513354c607129564f33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e09b79d2a2513354c607129564f33e">&#9670;&nbsp;</a></span>getID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int icl::cv::VectorTracker::getID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>lastErrorOrScore</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns runtime id of last pushed data element index </p>

</div>
</div>
<a id="a278bec4a45fbc930bdc49296fb29ee8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278bec4a45fbc930bdc49296fb29ee8e">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool icl::cv::VectorTracker::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether <a class="el" href="classicl_1_1cv_1_1VectorTracker.html" title="Extension of the position tracker class for N-dimensional positions.">VectorTracker</a> instance is currently null (created with default constructor) </p>

</div>
</div>
<a id="ae698218e21e6a949b9d6194e4101784a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae698218e21e6a949b9d6194e4101784a">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html">VectorTracker</a>&amp; icl::cv::VectorTracker::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1cv_1_1VectorTracker.html">VectorTracker</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>assignment (all data and current state is copied deeply) </p>
<p>New instance is absolutely independent from the source instance </p>

</div>
</div>
<a id="ab3148a482690fa5f38e0fdb212ef0440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3148a482690fa5f38e0fdb212ef0440">&#9670;&nbsp;</a></span>pushData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icl::cv::VectorTracker::pushData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classicl_1_1cv_1_1VectorTracker.html#abc09bb75ed4693fba2468644435901a2">Vec</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>next step function most efficient version </p>

</div>
</div>
<a id="ab17bda32774310efc36cf531110e5660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17bda32774310efc36cf531110e5660">&#9670;&nbsp;</a></span>setDistanceFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icl::cv::VectorTracker::setDistanceFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1cv_1_1VectorTracker.html#a1fe74d7225700e7b2b91f2ac754c8c11">DistanceFunction</a>&#160;</td>
          <td class="paramname"><em>df</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets a custom distance function </p>

</div>
</div>
<a id="ad0ad806720ed622f2b069ec82d1f9236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ad806720ed622f2b069ec82d1f9236">&#9670;&nbsp;</a></span>setExtrapolationMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icl::cv::VectorTracker::setExtrapolationMask </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>internally sets the extrapolation mask </p>
<p>By default, the mask contains only true-entries. All dimensions of current date, that have a true-entry in the mask are extrapolated using a linear model before the internal cost-matrix is created (and if this entry has an age of at least 2 &ndash; so two former entries are available). Dimensions that have a false-entry in the given mask are not-extrapolated over time (which is identical to using a constant extrapolation model) </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a67070f88e748a699052ef87faf278fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67070f88e748a699052ef87faf278fa4">&#9670;&nbsp;</a></span>m_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Data* icl::cv::VectorTracker::m_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal data pointer </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/icl/icl/ICLCV/src/ICLCV/<a class="el" href="VectorTracker_8h_source.html">VectorTracker.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 14:54:51 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
