<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1utils.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">icl::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html">Any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple generic data type implementation that uses a string based data representation.  <a href="structicl_1_1utils_1_1Any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Array2D.html">Array2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 2D-Array class that provides shallow copy per default.  <a href="classicl_1_1utils_1_1Array2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1ArrayDelOp.html">ArrayDelOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array delete operation class for the <a class="el" href="structicl_1_1utils_1_1SmartPtr.html" title="Specialization of the SmartPtrBase class for Pointers.">SmartPtr</a> class.  <a href="structicl_1_1utils_1_1ArrayDelOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLBuffer.html">CLBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for an OpenCL Buffer.  <a href="classicl_1_1utils_1_1CLBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLBufferException.html">CLBufferException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for an OpenCL Exception associated with buffers.  <a href="classicl_1_1utils_1_1CLBufferException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLBuildException.html">CLBuildException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for an OpenCL Exception during kernel compiling.  <a href="classicl_1_1utils_1_1CLBuildException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLDeviceContext.html">CLDeviceContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classicl_1_1utils_1_1CLDeviceContext.html" title="The CLDeviceContext class allows preparation of the device used for CLPrograms.">CLDeviceContext</a> class allows preparation of the device used for CLPrograms.  <a href="classicl_1_1utils_1_1CLDeviceContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLException.html">CLException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for an OpenCL Exception.  <a href="classicl_1_1utils_1_1CLException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLImage2D.html">CLImage2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for an OpenCL Image2D.  <a href="classicl_1_1utils_1_1CLImage2D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLInitException.html">CLInitException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for an OpenCL Exception during initialization.  <a href="classicl_1_1utils_1_1CLInitException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLKernel.html">CLKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for an OpenCL Kernel.  <a href="classicl_1_1utils_1_1CLKernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLKernelException.html">CLKernelException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for an OpenCL Exception associated with kernels.  <a href="classicl_1_1utils_1_1CLKernelException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLMemory.html">CLMemory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classicl_1_1utils_1_1CLMemory.html" title="The CLMemory class is a base class for CLBuffer and CLImage2D.">CLMemory</a> class is a base class for <a class="el" href="classicl_1_1utils_1_1CLBuffer.html" title="Wrapper for an OpenCL Buffer.">CLBuffer</a> and <a class="el" href="classicl_1_1utils_1_1CLImage2D.html" title="Wrapper for an OpenCL Image2D.">CLImage2D</a>.  <a href="classicl_1_1utils_1_1CLMemory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLMemoryAssistant.html">CLMemoryAssistant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classicl_1_1utils_1_1CLMemoryAssistant.html" title="The CLMemoryAssistant class is a helper class to maintain buffers and images for opencl-program pipel...">CLMemoryAssistant</a> class is a helper class to maintain buffers and images for opencl-program pipelines.  <a href="classicl_1_1utils_1_1CLMemoryAssistant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1CLProgram.html">CLProgram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main class for OpenCL based accelleration.  <a href="classicl_1_1utils_1_1CLProgram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1ConfigFile.html">ConfigFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for creating and reading XML-based hierarchical configuration files.  <a href="classicl_1_1utils_1_1ConfigFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Configurable.html">Configurable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for classes that can be configured from configuration-files and GUI-Components.  <a href="classicl_1_1utils_1_1Configurable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1ConfigurableProxy.html">ConfigurableProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the getter and setter methods of an internally set <a class="el" href="classicl_1_1utils_1_1Configurable.html" title="Interface for classes that can be configured from configuration-files and GUI-Components.">Configurable</a>.  <a href="classicl_1_1utils_1_1ConfigurableProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1ConstFunctorFunctionImpl.html">ConstFunctorFunctionImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structicl_1_1utils_1_1FunctionImpl.html" title="General Implementation for binary functions.">FunctionImpl</a> implementation for functors of const objects.  <a href="structicl_1_1utils_1_1ConstFunctorFunctionImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1ConstMemberFunctionImpl.html">ConstMemberFunctionImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structicl_1_1utils_1_1FunctionImpl.html" title="General Implementation for binary functions.">FunctionImpl</a> implementation for const member functions.  <a href="structicl_1_1utils_1_1ConstMemberFunctionImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1DelOpBase.html">DelOpBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure Interface class for DelOps.  <a href="classicl_1_1utils_1_1DelOpBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1FastMedianList.html">FastMedianList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for fast calculation of a median (calculating a median in O(N))  <a href="classicl_1_1utils_1_1FastMedianList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1File.html">File</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for file handling (reading files is buffered)  <a href="classicl_1_1utils_1_1File.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1FileNotFoundException.html">FileNotFoundException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown if a file could not be found.  <a href="classicl_1_1utils_1_1FileNotFoundException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1FileOpenException.html">FileOpenException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown if a file could not be opend.  <a href="classicl_1_1utils_1_1FileOpenException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FixedArray.html">FixedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed C++-array wrapper class for data handling.  <a href="structicl_1_1utils_1_1FixedArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FixedArray_3_01T_00_011u_01_4.html">FixedArray&lt; T, 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for 1D-vectors providing a value x.  <a href="structicl_1_1utils_1_1FixedArray_3_01T_00_011u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FixedArray_3_01T_00_012u_01_4.html">FixedArray&lt; T, 2u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for 2D-matrics providing direct access to values x, y.  <a href="structicl_1_1utils_1_1FixedArray_3_01T_00_012u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FixedArray_3_01T_00_013u_01_4.html">FixedArray&lt; T, 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for 3D-matrics providing direct access to values x, y, z.  <a href="structicl_1_1utils_1_1FixedArray_3_01T_00_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FixedArray_3_01T_00_014u_01_4.html">FixedArray&lt; T, 4u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for 4D-matrics providing direct access to values x, y, z and h.  <a href="structicl_1_1utils_1_1FixedArray_3_01T_00_014u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1FPSEstimator.html">FPSEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility clas for online FPS estimation.  <a href="classicl_1_1utils_1_1FPSEstimator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1FPSLimiter.html">FPSLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An fps limiter can be used to limit online applications FPS.  <a href="classicl_1_1utils_1_1FPSLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FreeDelOp.html">FreeDelOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-Style delete operation class for the <a class="el" href="structicl_1_1utils_1_1SmartPtr.html" title="Specialization of the SmartPtrBase class for Pointers.">SmartPtr</a> class.  <a href="structicl_1_1utils_1_1FreeDelOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The General <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> Template.  <a href="structicl_1_1utils_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FunctionImpl.html">FunctionImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General Implementation for binary functions.  <a href="structicl_1_1utils_1_1FunctionImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FunctionImpl_3_01R_00_01A_00_01B_00_01NO__ARG_01_4.html">FunctionImpl&lt; R, A, B, NO_ARG &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special Implementation for unary functions.  <a href="structicl_1_1utils_1_1FunctionImpl_3_01R_00_01A_00_01B_00_01NO__ARG_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FunctionImpl_3_01R_00_01A_00_01NO__ARG_01_4.html">FunctionImpl&lt; R, A, NO_ARG &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special Implementation for unary functions.  <a href="structicl_1_1utils_1_1FunctionImpl_3_01R_00_01A_00_01NO__ARG_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FunctionImpl_3_01R_00_01NO__ARG_01_4.html">FunctionImpl&lt; R, NO_ARG &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special Implementation for void functions.  <a href="structicl_1_1utils_1_1FunctionImpl_3_01R_00_01NO__ARG_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1FunctorFunctionImpl.html">FunctorFunctionImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structicl_1_1utils_1_1FunctionImpl.html" title="General Implementation for binary functions.">FunctionImpl</a> implementation for Functors.  <a href="structicl_1_1utils_1_1FunctorFunctionImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1GlobalFunctionImpl.html">GlobalFunctionImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structicl_1_1utils_1_1FunctionImpl.html" title="General Implementation for binary functions.">FunctionImpl</a> implementation for global functions.  <a href="structicl_1_1utils_1_1GlobalFunctionImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1GRand.html">GRand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">lightweight Random generator class for gaussian distributed numbers  <a href="classicl_1_1utils_1_1GRand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1GRandClip.html">GRandClip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">lightweight Random generator class for gaussian distributed numbers clipped to a given range  <a href="classicl_1_1utils_1_1GRandClip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1ICLDynamicFunctionLoadException.html">ICLDynamicFunctionLoadException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1ICLDynamicLibLoadException.html">ICLDynamicLibLoadException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1ICLException.html">ICLException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for Exception handling in the ICL.  <a href="classicl_1_1utils_1_1ICLException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1InvalidDepthException.html">InvalidDepthException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown if a function should process an unsupported image depth.  <a href="classicl_1_1utils_1_1InvalidDepthException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1InvalidFileException.html">InvalidFileException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown if a file could not be read properly.  <a href="classicl_1_1utils_1_1InvalidFileException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1InvalidFileFormatException.html">InvalidFileFormatException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for invalid file formats.  <a href="classicl_1_1utils_1_1InvalidFileFormatException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1InvalidFormatException.html">InvalidFormatException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown if a function should process an unsupported image format.  <a href="classicl_1_1utils_1_1InvalidFormatException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1InvalidImgParamException.html">InvalidImgParamException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception called if an image gets invalid params.  <a href="classicl_1_1utils_1_1InvalidImgParamException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1InvalidNumChannelException.html">InvalidNumChannelException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown if a function should process an unsupported image depth.  <a href="classicl_1_1utils_1_1InvalidNumChannelException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1InvalidRegularExpressionException.html">InvalidRegularExpressionException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown by iclStringUtils::match if regular Expression is not valid.  <a href="classicl_1_1utils_1_1InvalidRegularExpressionException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1InvalidSizeException.html">InvalidSizeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown if a function should process an unsupported sizes (e.g. with negative dim..)  <a href="classicl_1_1utils_1_1InvalidSizeException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1IppInterface.html">IppInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Lockable.html">Lockable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for objects, that can be locked using an internal mutex.  <a href="classicl_1_1utils_1_1Lockable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1MatchResult.html">MatchResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility structure for matching results.  <a href="structicl_1_1utils_1_1MatchResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1MemberFunctionImpl.html">MemberFunctionImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structicl_1_1utils_1_1FunctionImpl.html" title="General Implementation for binary functions.">FunctionImpl</a> implementation for member functions.  <a href="structicl_1_1utils_1_1MemberFunctionImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1MultiThreader.html">MultiThreader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for parallelizing algorithms.  <a href="classicl_1_1utils_1_1MultiThreader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1MultiTypeMap.html">MultiTypeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract and associative Data Container for Data of different types.  <a href="classicl_1_1utils_1_1MultiTypeMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Mutex.html">Mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classicl_1_1utils_1_1Mutex.html" title="Mutex class of the ICL.">Mutex</a> class of the ICL.  <a href="classicl_1_1utils_1_1Mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1ParamList.html">ParamList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility structure that utilizes an std::map as parameter list.  <a href="structicl_1_1utils_1_1ParamList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1ParseException.html">ParseException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown if a string is parsed into a specific type (or something)  <a href="classicl_1_1utils_1_1ParseException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1PluginRegister.html">PluginRegister</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for plugin registration.  <a href="classicl_1_1utils_1_1PluginRegister.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Point.html">Point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classicl_1_1utils_1_1Point.html" title="Point class of the ICL used e.g. for the Images ROI offset.">Point</a> class of the ICL used e.g. for the Images ROI offset.  <a href="classicl_1_1utils_1_1Point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Point32f.html">Point32f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single precission 3D Vectors <a class="el" href="classicl_1_1utils_1_1Point.html" title="Point class of the ICL used e.g. for the Images ROI offset.">Point</a> class of the ICL.  <a href="classicl_1_1utils_1_1Point32f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1PointerDelOp.html">PointerDelOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer delete operation class for the <a class="el" href="structicl_1_1utils_1_1SmartPtr.html" title="Specialization of the SmartPtrBase class for Pointers.">SmartPtr</a> class.  <a href="structicl_1_1utils_1_1PointerDelOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1ProcessMonitor.html">ProcessMonitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classicl_1_1utils_1_1ProcessMonitor.html" title="The ProcessMonitor class grants access to processes memory and CPU usage.">ProcessMonitor</a> class grants access to processes memory and CPU usage.  <a href="classicl_1_1utils_1_1ProcessMonitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programm argument utility class.  <a href="classicl_1_1utils_1_1ProgArg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1ProgArgException.html">ProgArgException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programm argument environment exception type.  <a href="structicl_1_1utils_1_1ProgArgException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1RandomSeeder.html">RandomSeeder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object based random seed caller.  <a href="structicl_1_1utils_1_1RandomSeeder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class representing a range defined by min and max value  <a href="structicl_1_1utils_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Rect.html">Rect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rectangle class of the ICL used e.g. for the Images ROI-rect.  <a href="classicl_1_1utils_1_1Rect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Rect32f.html">Rect32f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floating point precision implementation of the <a class="el" href="classicl_1_1utils_1_1Rect.html" title="Rectangle class of the ICL used e.g. for the Images ROI-rect.">Rect</a> class.  <a href="classicl_1_1utils_1_1Rect32f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty utility template that can be used to select a special functor.  <a href="structicl_1_1utils_1_1SelectFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Semaphore.html">Semaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple <a class="el" href="classicl_1_1utils_1_1Semaphore.html" title="Simple Semaphore implementation wrapping the standard linux &quot;sem_t&quot;-struct.">Semaphore</a> implementation wrapping the standard linux "sem_t"-struct.  <a href="classicl_1_1utils_1_1Semaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1ShallowCopyable.html">ShallowCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for cheap copyable classes using a smart ptr.  <a href="classicl_1_1utils_1_1ShallowCopyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SignalHandler.html">SignalHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">C++ Signal-Handler interface class.  <a href="classicl_1_1utils_1_1SignalHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Size.html">Size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classicl_1_1utils_1_1Size.html" title="Size class of the ICL.">Size</a> class of the ICL.  <a href="classicl_1_1utils_1_1Size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Size32f.html">Size32f</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classicl_1_1utils_1_1Size32f.html" title="Size32f class of the ICL (float valued)">Size32f</a> class of the ICL (float valued)  <a href="classicl_1_1utils_1_1Size32f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1SmartArray.html">SmartArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a> class for Arrays.  <a href="structicl_1_1utils_1_1SmartArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1SmartPtr.html">SmartPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a> class for Pointers.  <a href="structicl_1_1utils_1_1SmartPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for reference counting smart-pointers.  <a href="classicl_1_1utils_1_1SmartPtrBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1StackTimer.html">StackTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tool for benchmarking method calls.  <a href="classicl_1_1utils_1_1StackTimer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1SteppingRange.html">SteppingRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class representing a range with defined stepping  <a href="structicl_1_1utils_1_1SteppingRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1StrTok.html">StrTok</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String Tokenizer Utility class.  <a href="classicl_1_1utils_1_1StrTok.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1TextTable.html">TextTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for pretty console output.  <a href="classicl_1_1utils_1_1TextTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Thread.html">Thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple object oriented thread class wrapping the pthread library.  <a href="classicl_1_1utils_1_1Thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Time.html">Time</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ICL <a class="el" href="classicl_1_1utils_1_1Time.html" title="ICL Time class (taken from the Ice lib)">Time</a> class (taken from the Ice lib)  <a href="classicl_1_1utils_1_1Time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Timer.html">Timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1UncopiedInstance.html">UncopiedInstance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for class instances that are created brand new on copy.  <a href="classicl_1_1utils_1_1UncopiedInstance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1Uncopyable.html">Uncopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class interface for un-copyable classes.  <a href="classicl_1_1utils_1_1Uncopyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1URand.html">URand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">lightweight Random generator class for uniform random distributions  <a href="classicl_1_1utils_1_1URand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1URandI.html">URandI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">lightweight Random generator class for uniform random distributions in positive integer domain  <a href="classicl_1_1utils_1_1URandI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1VisualizationDescription.html">VisualizationDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class for visualization tasks.  <a href="classicl_1_1utils_1_1VisualizationDescription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1102918d7e68a93745e7f74a7078adfe"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a1102918d7e68a93745e7f74a7078adfe">XMLNodeType</a></td></tr>
<tr class="memdesc:a1102918d7e68a93745e7f74a7078adfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node type.  <a href="namespaceicl_1_1utils.html#a1102918d7e68a93745e7f74a7078adfe">More...</a><br /></td></tr>
<tr class="separator:a1102918d7e68a93745e7f74a7078adfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5a74ab49c4ecf729ff79f4a1398d9"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_encoding&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ac1b5a74ab49c4ecf729ff79f4a1398d9">XMLEncoding</a></td></tr>
<tr class="memdesc:ac1b5a74ab49c4ecf729ff79f4a1398d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">XML encoding type.  <a href="namespaceicl_1_1utils.html#ac1b5a74ab49c4ecf729ff79f4a1398d9">More...</a><br /></td></tr>
<tr class="separator:ac1b5a74ab49c4ecf729ff79f4a1398d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558f49bca0dd7b0820e920f2768038a1"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_writer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a558f49bca0dd7b0820e920f2768038a1">XMLWriter</a></td></tr>
<tr class="memdesc:a558f49bca0dd7b0820e920f2768038a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">XML writer interface.  <a href="namespaceicl_1_1utils.html#a558f49bca0dd7b0820e920f2768038a1">More...</a><br /></td></tr>
<tr class="separator:a558f49bca0dd7b0820e920f2768038a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac537c8425e9914956ac3bd975041d9bf"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_writer_stream&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ac537c8425e9914956ac3bd975041d9bf">XMLStreamWriter</a></td></tr>
<tr class="memdesc:ac537c8425e9914956ac3bd975041d9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">XML writer implementation for streams.  <a href="namespaceicl_1_1utils.html#ac537c8425e9914956ac3bd975041d9bf">More...</a><br /></td></tr>
<tr class="separator:ac537c8425e9914956ac3bd975041d9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9494b9da22b01577face049e1d6ed859"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_writer_file&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a9494b9da22b01577face049e1d6ed859">XMLFileWriter</a></td></tr>
<tr class="memdesc:a9494b9da22b01577face049e1d6ed859"><td class="mdescLeft">&#160;</td><td class="mdescRight">XML writer implementation for files.  <a href="namespaceicl_1_1utils.html#a9494b9da22b01577face049e1d6ed859">More...</a><br /></td></tr>
<tr class="separator:a9494b9da22b01577face049e1d6ed859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d18b49744914a02335100a7e1acf5c"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_attribute&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#af2d18b49744914a02335100a7e1acf5c">XMLAttribute</a></td></tr>
<tr class="memdesc:af2d18b49744914a02335100a7e1acf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">XML Attribute class.  <a href="namespaceicl_1_1utils.html#af2d18b49744914a02335100a7e1acf5c">More...</a><br /></td></tr>
<tr class="separator:af2d18b49744914a02335100a7e1acf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b55b75b9f3e8c98a942b66fede26d4"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#af9b55b75b9f3e8c98a942b66fede26d4">XMLNode</a></td></tr>
<tr class="memdesc:af9b55b75b9f3e8c98a942b66fede26d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">XML Node class.  <a href="namespaceicl_1_1utils.html#af9b55b75b9f3e8c98a942b66fede26d4">More...</a><br /></td></tr>
<tr class="separator:af9b55b75b9f3e8c98a942b66fede26d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936d775ea623faa19fc928a3cd1f4921"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_node_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a936d775ea623faa19fc928a3cd1f4921">XMLNodeIterator</a></td></tr>
<tr class="memdesc:a936d775ea623faa19fc928a3cd1f4921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for XMLNodes.  <a href="namespaceicl_1_1utils.html#a936d775ea623faa19fc928a3cd1f4921">More...</a><br /></td></tr>
<tr class="separator:a936d775ea623faa19fc928a3cd1f4921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98a2f1040f08ad89b6f37bd622d5540"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_attribute_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ad98a2f1040f08ad89b6f37bd622d5540">XMLAttributeIterator</a></td></tr>
<tr class="memdesc:ad98a2f1040f08ad89b6f37bd622d5540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for XMLAttributes.  <a href="namespaceicl_1_1utils.html#ad98a2f1040f08ad89b6f37bd622d5540">More...</a><br /></td></tr>
<tr class="separator:ad98a2f1040f08ad89b6f37bd622d5540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddeca973de95d682cf38a847e6c8367"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_tree_walker&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a1ddeca973de95d682cf38a847e6c8367">XMLTreeWalker</a></td></tr>
<tr class="memdesc:a1ddeca973de95d682cf38a847e6c8367"><td class="mdescLeft">&#160;</td><td class="mdescRight">XML-Treewalker class.  <a href="namespaceicl_1_1utils.html#a1ddeca973de95d682cf38a847e6c8367">More...</a><br /></td></tr>
<tr class="separator:a1ddeca973de95d682cf38a847e6c8367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7380cda56e95de92f70f252948b0f5fa"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_parse_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a7380cda56e95de92f70f252948b0f5fa">XMLParseStatus</a></td></tr>
<tr class="memdesc:a7380cda56e95de92f70f252948b0f5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsing status enumeration.  <a href="namespaceicl_1_1utils.html#a7380cda56e95de92f70f252948b0f5fa">More...</a><br /></td></tr>
<tr class="separator:a7380cda56e95de92f70f252948b0f5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412cc9cf6083d6333c78604ef94727e1"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_parse_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a412cc9cf6083d6333c78604ef94727e1">XMLParseResult</a></td></tr>
<tr class="memdesc:a412cc9cf6083d6333c78604ef94727e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsing status class.  <a href="namespaceicl_1_1utils.html#a412cc9cf6083d6333c78604ef94727e1">More...</a><br /></td></tr>
<tr class="separator:a412cc9cf6083d6333c78604ef94727e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6617258b64b3c5d2c8c46097c1a9a2"><td class="memItemLeft" align="right" valign="top">typedef pugi::xml_document&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a2c6617258b64b3c5d2c8c46097c1a9a2">XMLDocument</a></td></tr>
<tr class="memdesc:a2c6617258b64b3c5d2c8c46097c1a9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main XML Document class.  <a href="namespaceicl_1_1utils.html#a2c6617258b64b3c5d2c8c46097c1a9a2">More...</a><br /></td></tr>
<tr class="separator:a2c6617258b64b3c5d2c8c46097c1a9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc62da0e115ef9098359e111dda5d826"><td class="memItemLeft" align="right" valign="top">typedef pugi::xpath_value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#acc62da0e115ef9098359e111dda5d826">XPathValueType</a></td></tr>
<tr class="memdesc:acc62da0e115ef9098359e111dda5d826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type enumeration for xpath values.  <a href="namespaceicl_1_1utils.html#acc62da0e115ef9098359e111dda5d826">More...</a><br /></td></tr>
<tr class="separator:acc62da0e115ef9098359e111dda5d826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a99ed31a06bd85f8b74bccc73bc572"><td class="memItemLeft" align="right" valign="top">typedef pugi::xpath_parse_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a09a99ed31a06bd85f8b74bccc73bc572">XPathParseResult</a></td></tr>
<tr class="memdesc:a09a99ed31a06bd85f8b74bccc73bc572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse Result class for XPath expressions.  <a href="namespaceicl_1_1utils.html#a09a99ed31a06bd85f8b74bccc73bc572">More...</a><br /></td></tr>
<tr class="separator:a09a99ed31a06bd85f8b74bccc73bc572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4785745fdf04f2055ae5988ee7c57b0"><td class="memItemLeft" align="right" valign="top">typedef pugi::xpath_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aa4785745fdf04f2055ae5988ee7c57b0">XPathVariable</a></td></tr>
<tr class="memdesc:aa4785745fdf04f2055ae5988ee7c57b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable Type for XPath expressions.  <a href="namespaceicl_1_1utils.html#aa4785745fdf04f2055ae5988ee7c57b0">More...</a><br /></td></tr>
<tr class="separator:aa4785745fdf04f2055ae5988ee7c57b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61574457d6516d5fd846af570fb91e8"><td class="memItemLeft" align="right" valign="top">typedef pugi::xpath_variable_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aa61574457d6516d5fd846af570fb91e8">XPathVariableSet</a></td></tr>
<tr class="memdesc:aa61574457d6516d5fd846af570fb91e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of XPathVariables.  <a href="namespaceicl_1_1utils.html#aa61574457d6516d5fd846af570fb91e8">More...</a><br /></td></tr>
<tr class="separator:aa61574457d6516d5fd846af570fb91e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6956a77040284bb2ea42f36e56bbaa9"><td class="memItemLeft" align="right" valign="top">typedef pugi::xpath_query&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ab6956a77040284bb2ea42f36e56bbaa9">XPathQuery</a></td></tr>
<tr class="memdesc:ab6956a77040284bb2ea42f36e56bbaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precompiled XPath expression.  <a href="namespaceicl_1_1utils.html#ab6956a77040284bb2ea42f36e56bbaa9">More...</a><br /></td></tr>
<tr class="separator:ab6956a77040284bb2ea42f36e56bbaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1eb073e25057ab4d9eceb1a5f90ead"><td class="memItemLeft" align="right" valign="top">typedef pugi::xpath_exception&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a8b1eb073e25057ab4d9eceb1a5f90ead">XPathException</a></td></tr>
<tr class="memdesc:a8b1eb073e25057ab4d9eceb1a5f90ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type for xpath expressions.  <a href="namespaceicl_1_1utils.html#a8b1eb073e25057ab4d9eceb1a5f90ead">More...</a><br /></td></tr>
<tr class="separator:a8b1eb073e25057ab4d9eceb1a5f90ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399ad00aad235807a3b01d3d38d875a2"><td class="memItemLeft" align="right" valign="top">typedef pugi::xpath_node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a399ad00aad235807a3b01d3d38d875a2">XPathNode</a></td></tr>
<tr class="memdesc:a399ad00aad235807a3b01d3d38d875a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special node type for XPath query results.  <a href="namespaceicl_1_1utils.html#a399ad00aad235807a3b01d3d38d875a2">More...</a><br /></td></tr>
<tr class="separator:a399ad00aad235807a3b01d3d38d875a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab597c9951467f2207683348197293db7"><td class="memItemLeft" align="right" valign="top">typedef pugi::xpath_node_set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ab597c9951467f2207683348197293db7">XPathNodeSet</a></td></tr>
<tr class="memdesc:ab597c9951467f2207683348197293db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of XPath nodes.  <a href="namespaceicl_1_1utils.html#ab597c9951467f2207683348197293db7">More...</a><br /></td></tr>
<tr class="separator:ab597c9951467f2207683348197293db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga113ac7a499e7ff3d82a194af882ce973"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga113ac7a499e7ff3d82a194af882ce973"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__GENERAL.html#ga113ac7a499e7ff3d82a194af882ce973">clip</a> (T tX, T tMin, T tMax)</td></tr>
<tr class="memdesc:ga113ac7a499e7ff3d82a194af882ce973"><td class="mdescLeft">&#160;</td><td class="mdescRight">clips a value into the range [tMin,tMax]  <a href="group__GENERAL.html#ga113ac7a499e7ff3d82a194af882ce973">More...</a><br /></td></tr>
<tr class="separator:ga113ac7a499e7ff3d82a194af882ce973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8665f8777d045f3beb0d5b6c2f669142"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8665f8777d045f3beb0d5b6c2f669142"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a8665f8777d045f3beb0d5b6c2f669142">is_float_type</a> ()</td></tr>
<tr class="separator:a8665f8777d045f3beb0d5b6c2f669142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3578da47f6113f7fc23e8900b3db85"><td class="memTemplParams" colspan="2">template&lt;class S , class D &gt; </td></tr>
<tr class="memitem:a0e3578da47f6113f7fc23e8900b3db85"><td class="memTemplItemLeft" align="right" valign="top">D&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a0e3578da47f6113f7fc23e8900b3db85">clipped_cast</a> (S src)</td></tr>
<tr class="memdesc:a0e3578da47f6113f7fc23e8900b3db85"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility cast function wrapping the standard lib's numerical_limits template  <a href="namespaceicl_1_1utils.html#a0e3578da47f6113f7fc23e8900b3db85">More...</a><br /></td></tr>
<tr class="separator:a0e3578da47f6113f7fc23e8900b3db85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21056ba630da04e4627e98d18735dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ad21056ba630da04e4627e98d18735dc3">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classicl_1_1utils_1_1ConfigFile.html">ConfigFile</a> &amp;cf)</td></tr>
<tr class="memdesc:ad21056ba630da04e4627e98d18735dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default ostream operator to put a <a class="el" href="classicl_1_1utils_1_1ConfigFile.html" title="Utility class for creating and reading XML-based hierarchical configuration files.">ConfigFile</a> into a stream.  <a href="namespaceicl_1_1utils.html#ad21056ba630da04e4627e98d18735dc3">More...</a><br /></td></tr>
<tr class="separator:ad21056ba630da04e4627e98d18735dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d1b5ee1dbf6cb6b7fddce376290cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ab8d1b5ee1dbf6cb6b7fddce376290cd1">progress_init</a> (const std::string &amp;text=&quot;Creating LUT&quot;)</td></tr>
<tr class="memdesc:ab8d1b5ee1dbf6cb6b7fddce376290cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">static utility function for displaying some progress information in console  <a href="namespaceicl_1_1utils.html#ab8d1b5ee1dbf6cb6b7fddce376290cd1">More...</a><br /></td></tr>
<tr class="separator:ab8d1b5ee1dbf6cb6b7fddce376290cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab533046b2fb60baa1745b5237b8393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aeab533046b2fb60baa1745b5237b8393">progress_finish</a> ()</td></tr>
<tr class="memdesc:aeab533046b2fb60baa1745b5237b8393"><td class="mdescLeft">&#160;</td><td class="mdescRight">static utility function for displaying some progress information in console  <a href="namespaceicl_1_1utils.html#aeab533046b2fb60baa1745b5237b8393">More...</a><br /></td></tr>
<tr class="separator:aeab533046b2fb60baa1745b5237b8393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d594a726349207153d3f50c30f112db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a5d594a726349207153d3f50c30f112db">progress</a> (int curr, int max, const std::string &amp;extraText=&quot;&quot;)</td></tr>
<tr class="memdesc:a5d594a726349207153d3f50c30f112db"><td class="mdescLeft">&#160;</td><td class="mdescRight">static utility function for displaying some progress information in console  <a href="namespaceicl_1_1utils.html#a5d594a726349207153d3f50c30f112db">More...</a><br /></td></tr>
<tr class="separator:a5d594a726349207153d3f50c30f112db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade08b80a6f07c48da47366d83862ed39"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B , class C &gt; </td></tr>
<tr class="memitem:ade08b80a6f07c48da47366d83862ed39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ade08b80a6f07c48da47366d83862ed39">function</a> (Object &amp;obj, R(Object::*method)(A, B, C))</td></tr>
<tr class="memdesc:ade08b80a6f07c48da47366d83862ed39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member functions.  <a href="namespaceicl_1_1utils.html#ade08b80a6f07c48da47366d83862ed39">More...</a><br /></td></tr>
<tr class="separator:ade08b80a6f07c48da47366d83862ed39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0b18be142831b208ff94179abf83ae"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B &gt; </td></tr>
<tr class="memitem:a6d0b18be142831b208ff94179abf83ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a6d0b18be142831b208ff94179abf83ae">function</a> (Object &amp;obj, R(Object::*method)(A, B))</td></tr>
<tr class="memdesc:a6d0b18be142831b208ff94179abf83ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member functions.  <a href="namespaceicl_1_1utils.html#a6d0b18be142831b208ff94179abf83ae">More...</a><br /></td></tr>
<tr class="separator:a6d0b18be142831b208ff94179abf83ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b711869f762e42579988aaaec327269"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A &gt; </td></tr>
<tr class="memitem:a4b711869f762e42579988aaaec327269"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a4b711869f762e42579988aaaec327269">function</a> (Object &amp;obj, R(Object::*method)(A))</td></tr>
<tr class="memdesc:a4b711869f762e42579988aaaec327269"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member function  <a href="namespaceicl_1_1utils.html#a4b711869f762e42579988aaaec327269">More...</a><br /></td></tr>
<tr class="separator:a4b711869f762e42579988aaaec327269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f166bfffc5737cd30db1ae4eed4f48e"><td class="memTemplParams" colspan="2">template&lt;class Object , class R &gt; </td></tr>
<tr class="memitem:a0f166bfffc5737cd30db1ae4eed4f48e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a0f166bfffc5737cd30db1ae4eed4f48e">function</a> (Object &amp;obj, R(Object::*method)())</td></tr>
<tr class="memdesc:a0f166bfffc5737cd30db1ae4eed4f48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member function  <a href="namespaceicl_1_1utils.html#a0f166bfffc5737cd30db1ae4eed4f48e">More...</a><br /></td></tr>
<tr class="separator:a0f166bfffc5737cd30db1ae4eed4f48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7b24674899cb0950ba50a395819843"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B , class C &gt; </td></tr>
<tr class="memitem:a6b7b24674899cb0950ba50a395819843"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a6b7b24674899cb0950ba50a395819843">function</a> (const Object &amp;obj, R(Object::*method)(A a, B b, C c) const)</td></tr>
<tr class="memdesc:a6b7b24674899cb0950ba50a395819843"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function  <a href="namespaceicl_1_1utils.html#a6b7b24674899cb0950ba50a395819843">More...</a><br /></td></tr>
<tr class="separator:a6b7b24674899cb0950ba50a395819843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946fb6f0958e822c7cdba4623c7f1bc1"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B &gt; </td></tr>
<tr class="memitem:a946fb6f0958e822c7cdba4623c7f1bc1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a946fb6f0958e822c7cdba4623c7f1bc1">function</a> (const Object &amp;obj, R(Object::*method)(A a, B b) const)</td></tr>
<tr class="memdesc:a946fb6f0958e822c7cdba4623c7f1bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function  <a href="namespaceicl_1_1utils.html#a946fb6f0958e822c7cdba4623c7f1bc1">More...</a><br /></td></tr>
<tr class="separator:a946fb6f0958e822c7cdba4623c7f1bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c2a9c20a1b977f1f3f04c309167eb7"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A &gt; </td></tr>
<tr class="memitem:a14c2a9c20a1b977f1f3f04c309167eb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a14c2a9c20a1b977f1f3f04c309167eb7">function</a> (const Object &amp;obj, R(Object::*method)(A a) const)</td></tr>
<tr class="memdesc:a14c2a9c20a1b977f1f3f04c309167eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function  <a href="namespaceicl_1_1utils.html#a14c2a9c20a1b977f1f3f04c309167eb7">More...</a><br /></td></tr>
<tr class="separator:a14c2a9c20a1b977f1f3f04c309167eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323cb5e86056fc5407811d6e8a260f38"><td class="memTemplParams" colspan="2">template&lt;class Object , class R &gt; </td></tr>
<tr class="memitem:a323cb5e86056fc5407811d6e8a260f38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a323cb5e86056fc5407811d6e8a260f38">function</a> (const Object &amp;obj, R(Object::*method)() const)</td></tr>
<tr class="memdesc:a323cb5e86056fc5407811d6e8a260f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function  <a href="namespaceicl_1_1utils.html#a323cb5e86056fc5407811d6e8a260f38">More...</a><br /></td></tr>
<tr class="separator:a323cb5e86056fc5407811d6e8a260f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc1d4f899ea4dc818bdda2d1c1fad40"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B , class C &gt; </td></tr>
<tr class="memitem:accc1d4f899ea4dc818bdda2d1c1fad40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#accc1d4f899ea4dc818bdda2d1c1fad40">function</a> (Object *obj, R(Object::*method)(A, B, C))</td></tr>
<tr class="memdesc:accc1d4f899ea4dc818bdda2d1c1fad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member functions.  <a href="namespaceicl_1_1utils.html#accc1d4f899ea4dc818bdda2d1c1fad40">More...</a><br /></td></tr>
<tr class="separator:accc1d4f899ea4dc818bdda2d1c1fad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51c05734a1d8ee4ca1857a7675d3dc8"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B &gt; </td></tr>
<tr class="memitem:ad51c05734a1d8ee4ca1857a7675d3dc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ad51c05734a1d8ee4ca1857a7675d3dc8">function</a> (Object *obj, R(Object::*method)(A, B))</td></tr>
<tr class="memdesc:ad51c05734a1d8ee4ca1857a7675d3dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member functions.  <a href="namespaceicl_1_1utils.html#ad51c05734a1d8ee4ca1857a7675d3dc8">More...</a><br /></td></tr>
<tr class="separator:ad51c05734a1d8ee4ca1857a7675d3dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b3a2c8d248ca6c62b404930429b7b2"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A &gt; </td></tr>
<tr class="memitem:ae2b3a2c8d248ca6c62b404930429b7b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ae2b3a2c8d248ca6c62b404930429b7b2">function</a> (Object *obj, R(Object::*method)(A))</td></tr>
<tr class="memdesc:ae2b3a2c8d248ca6c62b404930429b7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member function  <a href="namespaceicl_1_1utils.html#ae2b3a2c8d248ca6c62b404930429b7b2">More...</a><br /></td></tr>
<tr class="separator:ae2b3a2c8d248ca6c62b404930429b7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f5cb7b2b0cc5c5203ccc9e0d8326a7"><td class="memTemplParams" colspan="2">template&lt;class Object , class R &gt; </td></tr>
<tr class="memitem:ad0f5cb7b2b0cc5c5203ccc9e0d8326a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ad0f5cb7b2b0cc5c5203ccc9e0d8326a7">function</a> (Object *obj, R(Object::*method)())</td></tr>
<tr class="memdesc:ad0f5cb7b2b0cc5c5203ccc9e0d8326a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member function  <a href="namespaceicl_1_1utils.html#ad0f5cb7b2b0cc5c5203ccc9e0d8326a7">More...</a><br /></td></tr>
<tr class="separator:ad0f5cb7b2b0cc5c5203ccc9e0d8326a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1de98706efef18af604b84f3f6ef77"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B , class C &gt; </td></tr>
<tr class="memitem:aba1de98706efef18af604b84f3f6ef77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aba1de98706efef18af604b84f3f6ef77">function</a> (const Object *obj, R(Object::*method)(A, B, C) const)</td></tr>
<tr class="memdesc:aba1de98706efef18af604b84f3f6ef77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member functions.  <a href="namespaceicl_1_1utils.html#aba1de98706efef18af604b84f3f6ef77">More...</a><br /></td></tr>
<tr class="separator:aba1de98706efef18af604b84f3f6ef77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a77124bd81143616f631b9fd44824a"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B &gt; </td></tr>
<tr class="memitem:aa2a77124bd81143616f631b9fd44824a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aa2a77124bd81143616f631b9fd44824a">function</a> (const Object *obj, R(Object::*method)(A, B) const)</td></tr>
<tr class="memdesc:aa2a77124bd81143616f631b9fd44824a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member functions.  <a href="namespaceicl_1_1utils.html#aa2a77124bd81143616f631b9fd44824a">More...</a><br /></td></tr>
<tr class="separator:aa2a77124bd81143616f631b9fd44824a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcccfb090e1c675713df0a5d4a542d5"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A &gt; </td></tr>
<tr class="memitem:a4dcccfb090e1c675713df0a5d4a542d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a4dcccfb090e1c675713df0a5d4a542d5">function</a> (const Object *obj, R(Object::*method)(A) const)</td></tr>
<tr class="memdesc:a4dcccfb090e1c675713df0a5d4a542d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function  <a href="namespaceicl_1_1utils.html#a4dcccfb090e1c675713df0a5d4a542d5">More...</a><br /></td></tr>
<tr class="separator:a4dcccfb090e1c675713df0a5d4a542d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f05b13ddb6fe0c123fbc3607b8d9cd8"><td class="memTemplParams" colspan="2">template&lt;class Object , class R &gt; </td></tr>
<tr class="memitem:a0f05b13ddb6fe0c123fbc3607b8d9cd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a0f05b13ddb6fe0c123fbc3607b8d9cd8">function</a> (const Object *obj, R(Object::*method)() const)</td></tr>
<tr class="memdesc:a0f05b13ddb6fe0c123fbc3607b8d9cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function  <a href="namespaceicl_1_1utils.html#a0f05b13ddb6fe0c123fbc3607b8d9cd8">More...</a><br /></td></tr>
<tr class="separator:a0f05b13ddb6fe0c123fbc3607b8d9cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f3522cf4c08cf77a05f8a9295f2c07"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B , class C &gt; </td></tr>
<tr class="memitem:a58f3522cf4c08cf77a05f8a9295f2c07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a58f3522cf4c08cf77a05f8a9295f2c07">function</a> (Object &amp;obj, <a class="el" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor</a>&lt; R, A, B, C &gt;)</td></tr>
<tr class="memdesc:a58f3522cf4c08cf77a05f8a9295f2c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from given object-functor  <a href="namespaceicl_1_1utils.html#a58f3522cf4c08cf77a05f8a9295f2c07">More...</a><br /></td></tr>
<tr class="separator:a58f3522cf4c08cf77a05f8a9295f2c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498d8a1dd020b651ffa043522aba2f83"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B , class C &gt; </td></tr>
<tr class="memitem:a498d8a1dd020b651ffa043522aba2f83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a498d8a1dd020b651ffa043522aba2f83">function</a> (const Object &amp;obj, <a class="el" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor</a>&lt; R, A, B, C &gt;)</td></tr>
<tr class="memdesc:a498d8a1dd020b651ffa043522aba2f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from given object-functor (const version)  <a href="namespaceicl_1_1utils.html#a498d8a1dd020b651ffa043522aba2f83">More...</a><br /></td></tr>
<tr class="separator:a498d8a1dd020b651ffa043522aba2f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c550aeacbc66702c7f7fe12d0d6c6d"><td class="memTemplParams" colspan="2">template&lt;class Object &gt; </td></tr>
<tr class="memitem:ab1c550aeacbc66702c7f7fe12d0d6c6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ab1c550aeacbc66702c7f7fe12d0d6c6d">function</a> (Object &amp;obj)</td></tr>
<tr class="memdesc:ab1c550aeacbc66702c7f7fe12d0d6c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> to wrap an objects parameter-less function operator  <a href="namespaceicl_1_1utils.html#ab1c550aeacbc66702c7f7fe12d0d6c6d">More...</a><br /></td></tr>
<tr class="separator:ab1c550aeacbc66702c7f7fe12d0d6c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bb2190a81f806aed37321b15d7305f"><td class="memTemplParams" colspan="2">template&lt;class Object &gt; </td></tr>
<tr class="memitem:ae2bb2190a81f806aed37321b15d7305f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ae2bb2190a81f806aed37321b15d7305f">function</a> (const Object &amp;obj)</td></tr>
<tr class="memdesc:ae2bb2190a81f806aed37321b15d7305f"><td class="mdescLeft">&#160;</td><td class="mdescRight">shortcut create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> to wrap a const objects parameter-less function operator  <a href="namespaceicl_1_1utils.html#ae2bb2190a81f806aed37321b15d7305f">More...</a><br /></td></tr>
<tr class="separator:ae2bb2190a81f806aed37321b15d7305f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2099a7b8280d73b8972f588f2fde2bed"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B , class C &gt; </td></tr>
<tr class="memitem:a2099a7b8280d73b8972f588f2fde2bed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a2099a7b8280d73b8972f588f2fde2bed">function</a> (Object *obj, <a class="el" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor</a>&lt; R, A, B, C &gt; selector)</td></tr>
<tr class="memdesc:a2099a7b8280d73b8972f588f2fde2bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from given object-functor  <a href="namespaceicl_1_1utils.html#a2099a7b8280d73b8972f588f2fde2bed">More...</a><br /></td></tr>
<tr class="separator:a2099a7b8280d73b8972f588f2fde2bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd679590d93869fe7312e09eb3067c7"><td class="memTemplParams" colspan="2">template&lt;class Object , class R , class A , class B , class C &gt; </td></tr>
<tr class="memitem:addd679590d93869fe7312e09eb3067c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#addd679590d93869fe7312e09eb3067c7">function</a> (const Object *obj, <a class="el" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor</a>&lt; R, A, B, C &gt; selector)</td></tr>
<tr class="memdesc:addd679590d93869fe7312e09eb3067c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from given object-functor (const version)  <a href="namespaceicl_1_1utils.html#addd679590d93869fe7312e09eb3067c7">More...</a><br /></td></tr>
<tr class="separator:addd679590d93869fe7312e09eb3067c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe05f20eeb973e69f3609186d45db5e"><td class="memTemplParams" colspan="2">template&lt;class R , class A , class B , class C &gt; </td></tr>
<tr class="memitem:a1fe05f20eeb973e69f3609186d45db5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a1fe05f20eeb973e69f3609186d45db5e">function</a> (R(*global_function)(A a, B b, C c))</td></tr>
<tr class="memdesc:a1fe05f20eeb973e69f3609186d45db5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> creator function from given binary global function.  <a href="namespaceicl_1_1utils.html#a1fe05f20eeb973e69f3609186d45db5e">More...</a><br /></td></tr>
<tr class="separator:a1fe05f20eeb973e69f3609186d45db5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d60c714a80dd12bec0bb9b21e735b5"><td class="memTemplParams" colspan="2">template&lt;class R , class A , class B &gt; </td></tr>
<tr class="memitem:a35d60c714a80dd12bec0bb9b21e735b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a35d60c714a80dd12bec0bb9b21e735b5">function</a> (R(*global_function)(A a, B b))</td></tr>
<tr class="memdesc:a35d60c714a80dd12bec0bb9b21e735b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> creator function from given binary global function.  <a href="namespaceicl_1_1utils.html#a35d60c714a80dd12bec0bb9b21e735b5">More...</a><br /></td></tr>
<tr class="separator:a35d60c714a80dd12bec0bb9b21e735b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21d22fb013c1b1e8d05b69c8821c3ad"><td class="memTemplParams" colspan="2">template&lt;class R , class A &gt; </td></tr>
<tr class="memitem:ac21d22fb013c1b1e8d05b69c8821c3ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ac21d22fb013c1b1e8d05b69c8821c3ad">function</a> (R(*global_function)(A a))</td></tr>
<tr class="memdesc:ac21d22fb013c1b1e8d05b69c8821c3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> creator function from given unary global function.  <a href="namespaceicl_1_1utils.html#ac21d22fb013c1b1e8d05b69c8821c3ad">More...</a><br /></td></tr>
<tr class="separator:ac21d22fb013c1b1e8d05b69c8821c3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8e01016489f91e3b3ba651cbbfb44f"><td class="memTemplParams" colspan="2">template&lt;class R &gt; </td></tr>
<tr class="memitem:a3a8e01016489f91e3b3ba651cbbfb44f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a3a8e01016489f91e3b3ba651cbbfb44f">function</a> (R(*global_function)())</td></tr>
<tr class="memdesc:a3a8e01016489f91e3b3ba651cbbfb44f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> creator function from given parameter less global function.  <a href="namespaceicl_1_1utils.html#a3a8e01016489f91e3b3ba651cbbfb44f">More...</a><br /></td></tr>
<tr class="separator:a3a8e01016489f91e3b3ba651cbbfb44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4702fc3afc839be28c693c54c12339da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4702fc3afc839be28c693c54c12339da"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a4702fc3afc839be28c693c54c12339da">sqr</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a4702fc3afc839be28c693c54c12339da"><td class="mdescLeft">&#160;</td><td class="mdescRight">square template (faster than pow(x,2)  <a href="namespaceicl_1_1utils.html#a4702fc3afc839be28c693c54c12339da">More...</a><br /></td></tr>
<tr class="separator:a4702fc3afc839be28c693c54c12339da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f6a9b4d8f395166b3b1c46e2d78fd2"><td class="memTemplParams" colspan="2">template&lt;class T , unsigned int N&gt; </td></tr>
<tr class="memitem:a86f6a9b4d8f395166b3b1c46e2d78fd2"><td class="memTemplItemLeft" align="right" valign="top">static T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a86f6a9b4d8f395166b3b1c46e2d78fd2">power</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a86f6a9b4d8f395166b3b1c46e2d78fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">power template  <a href="namespaceicl_1_1utils.html#a86f6a9b4d8f395166b3b1c46e2d78fd2">More...</a><br /></td></tr>
<tr class="separator:a86f6a9b4d8f395166b3b1c46e2d78fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790f07b4c393f081bf2c895e4331a28f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a790f07b4c393f081bf2c895e4331a28f">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classicl_1_1utils_1_1Point.html">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a790f07b4c393f081bf2c895e4331a28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator (x,y)  <a href="namespaceicl_1_1utils.html#a790f07b4c393f081bf2c895e4331a28f">More...</a><br /></td></tr>
<tr class="separator:a790f07b4c393f081bf2c895e4331a28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d023b64e5c63cabcbcb8f143019523"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ae6d023b64e5c63cabcbcb8f143019523">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classicl_1_1utils_1_1Point.html">Point</a> &amp;p)</td></tr>
<tr class="memdesc:ae6d023b64e5c63cabcbcb8f143019523"><td class="mdescLeft">&#160;</td><td class="mdescRight">istream operator  <a href="namespaceicl_1_1utils.html#ae6d023b64e5c63cabcbcb8f143019523">More...</a><br /></td></tr>
<tr class="separator:ae6d023b64e5c63cabcbcb8f143019523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fadd0ecded116674822ee97a9b96b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a03fadd0ecded116674822ee97a9b96b7">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classicl_1_1utils_1_1Point32f.html">Point32f</a> &amp;p)</td></tr>
<tr class="memdesc:a03fadd0ecded116674822ee97a9b96b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator (x,y)  <a href="namespaceicl_1_1utils.html#a03fadd0ecded116674822ee97a9b96b7">More...</a><br /></td></tr>
<tr class="separator:a03fadd0ecded116674822ee97a9b96b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e836b45c78886a72f59ec362d651844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a0e836b45c78886a72f59ec362d651844">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classicl_1_1utils_1_1Point32f.html">Point32f</a> &amp;p)</td></tr>
<tr class="memdesc:a0e836b45c78886a72f59ec362d651844"><td class="mdescLeft">&#160;</td><td class="mdescRight">istream operator  <a href="namespaceicl_1_1utils.html#a0e836b45c78886a72f59ec362d651844">More...</a><br /></td></tr>
<tr class="separator:a0e836b45c78886a72f59ec362d651844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ecced219e00aa40891d56945b32fd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ab0ecced219e00aa40891d56945b32fd9">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structicl_1_1utils_1_1ProcessMonitor_1_1Info.html">ProcessMonitor::Info</a> &amp;info)</td></tr>
<tr class="memdesc:ab0ecced219e00aa40891d56945b32fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded ostream operator for the <a class="el" href="classicl_1_1utils_1_1ProcessMonitor.html" title="The ProcessMonitor class grants access to processes memory and CPU usage.">ProcessMonitor</a>'s Info data type  <a href="namespaceicl_1_1utils.html#ab0ecced219e00aa40891d56945b32fd9">More...</a><br /></td></tr>
<tr class="separator:ab0ecced219e00aa40891d56945b32fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a659069cc5f2083dbba906ad7d0e22"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ad3a659069cc5f2083dbba906ad7d0e22">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;<a class="el" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>)</td></tr>
<tr class="memdesc:ad3a659069cc5f2083dbba906ad7d0e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">just puts the referenced argument value as string into the lvalue-stream  <a href="namespaceicl_1_1utils.html#ad3a659069cc5f2083dbba906ad7d0e22">More...</a><br /></td></tr>
<tr class="separator:ad3a659069cc5f2083dbba906ad7d0e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823ac1a418cb157cfe4f2c2feb8581ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a823ac1a418cb157cfe4f2c2feb8581ce">operator&amp;&amp;</a> (const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;a, const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;b)</td></tr>
<tr class="memdesc:a823ac1a418cb157cfe4f2c2feb8581ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">this allows to check if two progargs are defined  <a href="namespaceicl_1_1utils.html#a823ac1a418cb157cfe4f2c2feb8581ce">More...</a><br /></td></tr>
<tr class="separator:a823ac1a418cb157cfe4f2c2feb8581ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad13a6ff53a27c5e5e598acf2ce774a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#adad13a6ff53a27c5e5e598acf2ce774a">operator&amp;&amp;</a> (const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;a, bool b)</td></tr>
<tr class="memdesc:adad13a6ff53a27c5e5e598acf2ce774a"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to check more than two <a class="el" href="classicl_1_1utils_1_1ProgArg.html" title="Programm argument utility class.">ProgArg</a> instances at once  <a href="namespaceicl_1_1utils.html#adad13a6ff53a27c5e5e598acf2ce774a">More...</a><br /></td></tr>
<tr class="separator:adad13a6ff53a27c5e5e598acf2ce774a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eaf41f5f332bc47b14f597a7b672c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aa0eaf41f5f332bc47b14f597a7b672c2">operator&amp;&amp;</a> (bool &amp;b, const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;a)</td></tr>
<tr class="memdesc:aa0eaf41f5f332bc47b14f597a7b672c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to check more than two <a class="el" href="classicl_1_1utils_1_1ProgArg.html" title="Programm argument utility class.">ProgArg</a> instances at once  <a href="namespaceicl_1_1utils.html#aa0eaf41f5f332bc47b14f597a7b672c2">More...</a><br /></td></tr>
<tr class="separator:aa0eaf41f5f332bc47b14f597a7b672c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d67ca9915ccb4d6721374735fcc4bd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a5d67ca9915ccb4d6721374735fcc4bd8">operator||</a> (const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;a, const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;b)</td></tr>
<tr class="memdesc:a5d67ca9915ccb4d6721374735fcc4bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">this allows to check if either of two progargs are defined  <a href="namespaceicl_1_1utils.html#a5d67ca9915ccb4d6721374735fcc4bd8">More...</a><br /></td></tr>
<tr class="separator:a5d67ca9915ccb4d6721374735fcc4bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaabc2afb6cf4dbca9475e7d9d1fd79c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#afaabc2afb6cf4dbca9475e7d9d1fd79c">operator||</a> (const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;a, bool b)</td></tr>
<tr class="memdesc:afaabc2afb6cf4dbca9475e7d9d1fd79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to check if either of more than two <a class="el" href="classicl_1_1utils_1_1ProgArg.html" title="Programm argument utility class.">ProgArg</a> instances is defined  <a href="namespaceicl_1_1utils.html#afaabc2afb6cf4dbca9475e7d9d1fd79c">More...</a><br /></td></tr>
<tr class="separator:afaabc2afb6cf4dbca9475e7d9d1fd79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678fec87681af38b957a16fb5b1dfe27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a678fec87681af38b957a16fb5b1dfe27">operator||</a> (bool &amp;b, const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;a)</td></tr>
<tr class="memdesc:a678fec87681af38b957a16fb5b1dfe27"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows to check if either of more than two <a class="el" href="classicl_1_1utils_1_1ProgArg.html" title="Programm argument utility class.">ProgArg</a> instances is defined  <a href="namespaceicl_1_1utils.html#a678fec87681af38b957a16fb5b1dfe27">More...</a><br /></td></tr>
<tr class="separator:a678fec87681af38b957a16fb5b1dfe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c1a1e771ecc0681b8f277040cc2c99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a> (const std::string &amp;id, unsigned int subargidx=0)</td></tr>
<tr class="memdesc:ac1c1a1e771ecc0681b8f277040cc2c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns given program argument  <a href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">More...</a><br /></td></tr>
<tr class="separator:ac1c1a1e771ecc0681b8f277040cc2c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2262f412cdc83b5e049015fbfc5476"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aab2262f412cdc83b5e049015fbfc5476">pa</a> (unsigned int idx, bool danglingOnly=true)</td></tr>
<tr class="memdesc:aab2262f412cdc83b5e049015fbfc5476"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns given program argument at given index  <a href="namespaceicl_1_1utils.html#aab2262f412cdc83b5e049015fbfc5476">More...</a><br /></td></tr>
<tr class="separator:aab2262f412cdc83b5e049015fbfc5476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a518df3feec5bfc3b75d7b75361e5f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a00a518df3feec5bfc3b75d7b75361e5f"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a00a518df3feec5bfc3b75d7b75361e5f">pa_def</a> (const std::string &amp;id, unsigned int subargidx, const T &amp;def)</td></tr>
<tr class="memdesc:a00a518df3feec5bfc3b75d7b75361e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function that allows to use a default value, if given argument was not defined  <a href="namespaceicl_1_1utils.html#a00a518df3feec5bfc3b75d7b75361e5f">More...</a><br /></td></tr>
<tr class="separator:a00a518df3feec5bfc3b75d7b75361e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b29bd24b6b27b3204d373eb5de55137"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9b29bd24b6b27b3204d373eb5de55137"><td class="memTemplItemLeft" align="right" valign="top">const T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a9b29bd24b6b27b3204d373eb5de55137">pa_def</a> (const std::string &amp;id, const T &amp;def)</td></tr>
<tr class="memdesc:a9b29bd24b6b27b3204d373eb5de55137"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function that allows to use a default value, if given argument was not defined  <a href="namespaceicl_1_1utils.html#a9b29bd24b6b27b3204d373eb5de55137">More...</a><br /></td></tr>
<tr class="separator:a9b29bd24b6b27b3204d373eb5de55137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d10d5cbc5c151413efea2bf9cd4abaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a9d10d5cbc5c151413efea2bf9cd4abaf">pa_get_count</a> (bool danglingOnly=true)</td></tr>
<tr class="memdesc:a9d10d5cbc5c151413efea2bf9cd4abaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of actually given args given  <a href="namespaceicl_1_1utils.html#a9d10d5cbc5c151413efea2bf9cd4abaf">More...</a><br /></td></tr>
<tr class="separator:a9d10d5cbc5c151413efea2bf9cd4abaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979ac322cfa110abe66a2ef7a4a14bc9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a979ac322cfa110abe66a2ef7a4a14bc9">pa_get_progname</a> (bool fullpath=false)</td></tr>
<tr class="memdesc:a979ac322cfa110abe66a2ef7a4a14bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns application name (full command line)  <a href="namespaceicl_1_1utils.html#a979ac322cfa110abe66a2ef7a4a14bc9">More...</a><br /></td></tr>
<tr class="separator:a979ac322cfa110abe66a2ef7a4a14bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae63f3f971b97b90a910e77f66c77c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aae63f3f971b97b90a910e77f66c77c78">pa_show_usage</a> (const std::string &amp;msg=&quot;&quot;)</td></tr>
<tr class="memdesc:aae63f3f971b97b90a910e77f66c77c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">shows current available programm arguments  <a href="namespaceicl_1_1utils.html#aae63f3f971b97b90a910e77f66c77c78">More...</a><br /></td></tr>
<tr class="separator:aae63f3f971b97b90a910e77f66c77c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46ed3e5fd9ea82a1a91f9c6a43690dd"><td class="memItemLeft" align="right" valign="top">PAEX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aa46ed3e5fd9ea82a1a91f9c6a43690dd">pa_explain</a> (const std::string &amp;<a class="el" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>, const std::string &amp;ex)</td></tr>
<tr class="memdesc:aa46ed3e5fd9ea82a1a91f9c6a43690dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be used to provide additional information for certain program arguments.  <a href="namespaceicl_1_1utils.html#aa46ed3e5fd9ea82a1a91f9c6a43690dd">More...</a><br /></td></tr>
<tr class="separator:aa46ed3e5fd9ea82a1a91f9c6a43690dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3aca94cda923d51cae6dbc51384d52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ade3aca94cda923d51cae6dbc51384d52">pa_init</a> (int n, char **ppc, const std::string &amp;init, bool allowDanglingArgs=false)</td></tr>
<tr class="memdesc:ade3aca94cda923d51cae6dbc51384d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialization function for ICL's program argument evaluation framework  <a href="namespaceicl_1_1utils.html#ade3aca94cda923d51cae6dbc51384d52">More...</a><br /></td></tr>
<tr class="separator:ade3aca94cda923d51cae6dbc51384d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb3a3fa44371c9e62d2524932fad1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#accb3a3fa44371c9e62d2524932fad1e4">pa_show</a> ()</td></tr>
<tr class="memdesc:accb3a3fa44371c9e62d2524932fad1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">shows all given program arguments  <a href="namespaceicl_1_1utils.html#accb3a3fa44371c9e62d2524932fad1e4">More...</a><br /></td></tr>
<tr class="separator:accb3a3fa44371c9e62d2524932fad1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdab0a33af75906c566f5319254989d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#acfdab0a33af75906c566f5319254989d">pa_set_license</a> (const std::string &amp;newLicenseText)</td></tr>
<tr class="memdesc:acfdab0a33af75906c566f5319254989d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a license text, that is used when applications are run with &ndash;version or -v.  <a href="namespaceicl_1_1utils.html#acfdab0a33af75906c566f5319254989d">More...</a><br /></td></tr>
<tr class="separator:acfdab0a33af75906c566f5319254989d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd26fa1dc3b675e9ce15fbd4b146ef2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#abd26fa1dc3b675e9ce15fbd4b146ef2a">pa_set_help_text</a> (const std::string &amp;newHelpText)</td></tr>
<tr class="memdesc:abd26fa1dc3b675e9ce15fbd4b146ef2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a applications help text that is used when applications are run with &ndash;help or with unknown arguments.  <a href="namespaceicl_1_1utils.html#abd26fa1dc3b675e9ce15fbd4b146ef2a">More...</a><br /></td></tr>
<tr class="separator:abd26fa1dc3b675e9ce15fbd4b146ef2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700761c022812d1069c7bcdf85837a7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a700761c022812d1069c7bcdf85837a7f">pa_get_license</a> ()</td></tr>
<tr class="memdesc:a700761c022812d1069c7bcdf85837a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current license text  <a href="namespaceicl_1_1utils.html#a700761c022812d1069c7bcdf85837a7f">More...</a><br /></td></tr>
<tr class="separator:a700761c022812d1069c7bcdf85837a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef20f39ea918ae71d815e596ceb8b783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aef20f39ea918ae71d815e596ceb8b783">pa_get_help_text</a> ()</td></tr>
<tr class="memdesc:aef20f39ea918ae71d815e596ceb8b783"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current help text (which is empty, if it was not set)  <a href="namespaceicl_1_1utils.html#aef20f39ea918ae71d815e596ceb8b783">More...</a><br /></td></tr>
<tr class="separator:aef20f39ea918ae71d815e596ceb8b783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfb87ed7d85b4890a959205f19ebc43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a9bfb87ed7d85b4890a959205f19ebc43">randomSeed</a> (long int seedval)</td></tr>
<tr class="memdesc:a9bfb87ed7d85b4890a959205f19ebc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initilaize the random number generator.  <a href="namespaceicl_1_1utils.html#a9bfb87ed7d85b4890a959205f19ebc43">More...</a><br /></td></tr>
<tr class="separator:a9bfb87ed7d85b4890a959205f19ebc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ab68322f5454016e93a0046573225c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a01ab68322f5454016e93a0046573225c">randomSeed</a> ()</td></tr>
<tr class="memdesc:a01ab68322f5454016e93a0046573225c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initilaize the random number generator (with <a class="el" href="classicl_1_1utils_1_1Time.html#a7a8c4c9f59e0edaa2bbced0e3d92f28b">Time::now()</a>.toMicroSeconds()).  <a href="namespaceicl_1_1utils.html#a01ab68322f5454016e93a0046573225c">More...</a><br /></td></tr>
<tr class="separator:a01ab68322f5454016e93a0046573225c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720d47364065e33e3c8c6806bf101492"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a720d47364065e33e3c8c6806bf101492">random</a> (double max=1)</td></tr>
<tr class="memdesc:a720d47364065e33e3c8c6806bf101492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates random numbers in range [0,1].  <a href="namespaceicl_1_1utils.html#a720d47364065e33e3c8c6806bf101492">More...</a><br /></td></tr>
<tr class="separator:a720d47364065e33e3c8c6806bf101492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92af36514c9aa380dc355d84bb1c522d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a92af36514c9aa380dc355d84bb1c522d">random</a> (double min, double max)</td></tr>
<tr class="memdesc:a92af36514c9aa380dc355d84bb1c522d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random number in range [min,max].  <a href="namespaceicl_1_1utils.html#a92af36514c9aa380dc355d84bb1c522d">More...</a><br /></td></tr>
<tr class="separator:a92af36514c9aa380dc355d84bb1c522d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a2af0b4fc9ba9b6b3c01f29fe50f76"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a41a2af0b4fc9ba9b6b3c01f29fe50f76"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a41a2af0b4fc9ba9b6b3c01f29fe50f76">random</a> (const <a class="el" href="structicl_1_1utils_1_1Range.html">Range</a>&lt; T &gt; &amp;r)</td></tr>
<tr class="memdesc:a41a2af0b4fc9ba9b6b3c01f29fe50f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to random (r.minVal,r.maxVal)  <a href="namespaceicl_1_1utils.html#a41a2af0b4fc9ba9b6b3c01f29fe50f76">More...</a><br /></td></tr>
<tr class="separator:a41a2af0b4fc9ba9b6b3c01f29fe50f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cfb0421b98a59254648127952df060"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a08cfb0421b98a59254648127952df060">random</a> (unsigned int max)</td></tr>
<tr class="memdesc:a08cfb0421b98a59254648127952df060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a non-negative random number in range [0,max].  <a href="namespaceicl_1_1utils.html#a08cfb0421b98a59254648127952df060">More...</a><br /></td></tr>
<tr class="separator:a08cfb0421b98a59254648127952df060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd5c572f28873aaaddd13692c099465"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a9cd5c572f28873aaaddd13692c099465">gaussRandom</a> (double mean, double var)</td></tr>
<tr class="memdesc:a9cd5c572f28873aaaddd13692c099465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a gaussian random number with given mean and variance.  <a href="namespaceicl_1_1utils.html#a9cd5c572f28873aaaddd13692c099465">More...</a><br /></td></tr>
<tr class="separator:a9cd5c572f28873aaaddd13692c099465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd21725893b78f862cce6a2300f7420"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a2fd21725893b78f862cce6a2300f7420">gaussRandom</a> (double mean, double var, const <a class="el" href="structicl_1_1utils_1_1Range.html">Range</a>&lt; double &gt; &amp;range)</td></tr>
<tr class="memdesc:a2fd21725893b78f862cce6a2300f7420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a gaussian random number with given mean and variance and clips the result to a range.  <a href="namespaceicl_1_1utils.html#a2fd21725893b78f862cce6a2300f7420">More...</a><br /></td></tr>
<tr class="separator:a2fd21725893b78f862cce6a2300f7420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5299d2647ee0fc428899596673d21ea8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a5299d2647ee0fc428899596673d21ea8">get_random_index_subset</a> (int containerSize, int subsetSize)</td></tr>
<tr class="separator:a5299d2647ee0fc428899596673d21ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6078568b9787fd6bba0c5193c621459"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad6078568b9787fd6bba0c5193c621459"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ad6078568b9787fd6bba0c5193c621459">get_random_subset</a> (const std::vector&lt; T &gt; &amp;s, int subsetSize)</td></tr>
<tr class="separator:ad6078568b9787fd6bba0c5193c621459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce8648b6ef34d5b06b1b5d3ff9067a6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5ce8648b6ef34d5b06b1b5d3ff9067a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a5ce8648b6ef34d5b06b1b5d3ff9067a6">get_random_subset</a> (const std::vector&lt; T &gt; &amp;s, int subsetSize, std::vector&lt; T &gt; &amp;subset)</td></tr>
<tr class="separator:a5ce8648b6ef34d5b06b1b5d3ff9067a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fbec929b95b6795d99eb747e066026"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a42fbec929b95b6795d99eb747e066026"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a42fbec929b95b6795d99eb747e066026">get_random_subset</a> (const std::vector&lt; T &gt; &amp;s, int subsetSize, std::vector&lt; T &gt; &amp;subset, std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="separator:a42fbec929b95b6795d99eb747e066026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ccc6c00187cf56571b34deb35a8530"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae2ccc6c00187cf56571b34deb35a8530"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Macros_8h.html#a7456583716d11c38193deeb09c7396a3">ICL_INSTANTIATE_ALL_DEPTHS</a> <a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ae2ccc6c00187cf56571b34deb35a8530">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structicl_1_1utils_1_1Range.html">Range</a>&lt; T &gt; &amp;range)</td></tr>
<tr class="memdesc:ae2ccc6c00187cf56571b34deb35a8530"><td class="mdescLeft">&#160;</td><td class="mdescRight">puts a string representation [min,max] of given range into the given stream  <a href="namespaceicl_1_1utils.html#ae2ccc6c00187cf56571b34deb35a8530">More...</a><br /></td></tr>
<tr class="separator:ae2ccc6c00187cf56571b34deb35a8530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35535c88517e5a6d9d4f3e48494926b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac35535c88517e5a6d9d4f3e48494926b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ac35535c88517e5a6d9d4f3e48494926b">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="structicl_1_1utils_1_1Range.html">Range</a>&lt; T &gt; &amp;range)</td></tr>
<tr class="memdesc:ac35535c88517e5a6d9d4f3e48494926b"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses a range argument into a std::string  <a href="namespaceicl_1_1utils.html#ac35535c88517e5a6d9d4f3e48494926b">More...</a><br /></td></tr>
<tr class="separator:ac35535c88517e5a6d9d4f3e48494926b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4999ee5b18066bfa5dda32dbd717976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ae4999ee5b18066bfa5dda32dbd717976">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classicl_1_1utils_1_1Rect.html">Rect</a> &amp;r)</td></tr>
<tr class="memdesc:ae4999ee5b18066bfa5dda32dbd717976"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator (x,y)wxy  <a href="namespaceicl_1_1utils.html#ae4999ee5b18066bfa5dda32dbd717976">More...</a><br /></td></tr>
<tr class="separator:ae4999ee5b18066bfa5dda32dbd717976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c46acf9d9675287079a31840a68619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a45c46acf9d9675287079a31840a68619">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classicl_1_1utils_1_1Rect.html">Rect</a> &amp;r)</td></tr>
<tr class="memdesc:a45c46acf9d9675287079a31840a68619"><td class="mdescLeft">&#160;</td><td class="mdescRight">istream operator  <a href="namespaceicl_1_1utils.html#a45c46acf9d9675287079a31840a68619">More...</a><br /></td></tr>
<tr class="separator:a45c46acf9d9675287079a31840a68619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ec750a00006864b78d9901663f2c4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a31ec750a00006864b78d9901663f2c4e">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classicl_1_1utils_1_1Rect32f.html">Rect32f</a> &amp;r)</td></tr>
<tr class="memdesc:a31ec750a00006864b78d9901663f2c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator (x,y)wxy  <a href="namespaceicl_1_1utils.html#a31ec750a00006864b78d9901663f2c4e">More...</a><br /></td></tr>
<tr class="separator:a31ec750a00006864b78d9901663f2c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f468d7e9c8c2f31fe15d18cb43ce47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a06f468d7e9c8c2f31fe15d18cb43ce47">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="classicl_1_1utils_1_1Rect32f.html">Rect32f</a> &amp;r)</td></tr>
<tr class="memdesc:a06f468d7e9c8c2f31fe15d18cb43ce47"><td class="mdescLeft">&#160;</td><td class="mdescRight">istream operator  <a href="namespaceicl_1_1utils.html#a06f468d7e9c8c2f31fe15d18cb43ce47">More...</a><br /></td></tr>
<tr class="separator:a06f468d7e9c8c2f31fe15d18cb43ce47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6628d877a9fecb8109b41410f24e3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aaa6628d877a9fecb8109b41410f24e3b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classicl_1_1utils_1_1Size.html">Size</a> &amp;s)</td></tr>
<tr class="memdesc:aaa6628d877a9fecb8109b41410f24e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator WIDTHxHEIGHT  <a href="namespaceicl_1_1utils.html#aaa6628d877a9fecb8109b41410f24e3b">More...</a><br /></td></tr>
<tr class="separator:aaa6628d877a9fecb8109b41410f24e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e255851234f59e8d05191b12526e9d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a7e255851234f59e8d05191b12526e9d5">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classicl_1_1utils_1_1Size.html">Size</a> &amp;s)</td></tr>
<tr class="memdesc:a7e255851234f59e8d05191b12526e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">istream operator parses a size from a string  <a href="namespaceicl_1_1utils.html#a7e255851234f59e8d05191b12526e9d5">More...</a><br /></td></tr>
<tr class="separator:a7e255851234f59e8d05191b12526e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f91a4b111d4b2f2cb004e139656b350"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a5f91a4b111d4b2f2cb004e139656b350">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classicl_1_1utils_1_1Size32f.html">Size32f</a> &amp;s)</td></tr>
<tr class="memdesc:a5f91a4b111d4b2f2cb004e139656b350"><td class="mdescLeft">&#160;</td><td class="mdescRight">ostream operator WIDTHxHEIGHT  <a href="namespaceicl_1_1utils.html#a5f91a4b111d4b2f2cb004e139656b350">More...</a><br /></td></tr>
<tr class="separator:a5f91a4b111d4b2f2cb004e139656b350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822af8e5702bcb616c47a966725dc01c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a822af8e5702bcb616c47a966725dc01c">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classicl_1_1utils_1_1Size32f.html">Size32f</a> &amp;s)</td></tr>
<tr class="memdesc:a822af8e5702bcb616c47a966725dc01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">istream operator  <a href="namespaceicl_1_1utils.html#a822af8e5702bcb616c47a966725dc01c">More...</a><br /></td></tr>
<tr class="separator:a822af8e5702bcb616c47a966725dc01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c90a75ecb1fdade4c984a99bbf30191"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c90a75ecb1fdade4c984a99bbf30191"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a6c90a75ecb1fdade4c984a99bbf30191">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structicl_1_1utils_1_1SteppingRange.html">SteppingRange</a>&lt; T &gt; &amp;range)</td></tr>
<tr class="memdesc:a6c90a75ecb1fdade4c984a99bbf30191"><td class="mdescLeft">&#160;</td><td class="mdescRight">puts a string representation [min,max]:step of given range into the given stream  <a href="namespaceicl_1_1utils.html#a6c90a75ecb1fdade4c984a99bbf30191">More...</a><br /></td></tr>
<tr class="separator:a6c90a75ecb1fdade4c984a99bbf30191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e517dfd2cfdcb4908d51b493b6248f2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e517dfd2cfdcb4908d51b493b6248f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a8e517dfd2cfdcb4908d51b493b6248f2">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="structicl_1_1utils_1_1SteppingRange.html">SteppingRange</a>&lt; T &gt; &amp;range)</td></tr>
<tr class="memdesc:a8e517dfd2cfdcb4908d51b493b6248f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses a range argument into a std::string  <a href="namespaceicl_1_1utils.html#a8e517dfd2cfdcb4908d51b493b6248f2">More...</a><br /></td></tr>
<tr class="separator:a8e517dfd2cfdcb4908d51b493b6248f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511adecee62c1cfece562a7088d3df41"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a511adecee62c1cfece562a7088d3df41"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a511adecee62c1cfece562a7088d3df41">icl_to_stream</a> (std::ostream &amp;s, T t)</td></tr>
<tr class="memdesc:a511adecee62c1cfece562a7088d3df41"><td class="mdescLeft">&#160;</td><td class="mdescRight">compatibility function that writes a datatype instance into a stream  <a href="namespaceicl_1_1utils.html#a511adecee62c1cfece562a7088d3df41">More...</a><br /></td></tr>
<tr class="separator:a511adecee62c1cfece562a7088d3df41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b921c2c6858bc0c784b7a8981da951"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af0b921c2c6858bc0c784b7a8981da951"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#af0b921c2c6858bc0c784b7a8981da951">icl_from_stream</a> (std::istream &amp;s, T &amp;t)</td></tr>
<tr class="memdesc:af0b921c2c6858bc0c784b7a8981da951"><td class="mdescLeft">&#160;</td><td class="mdescRight">compability function that reads a datatype instance from a stream  <a href="namespaceicl_1_1utils.html#af0b921c2c6858bc0c784b7a8981da951">More...</a><br /></td></tr>
<tr class="separator:af0b921c2c6858bc0c784b7a8981da951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068f9696659c2b957cb31151804ce01d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a068f9696659c2b957cb31151804ce01d">toLowerI</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:a068f9696659c2b957cb31151804ce01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace lower case conversion  <a href="namespaceicl_1_1utils.html#a068f9696659c2b957cb31151804ce01d">More...</a><br /></td></tr>
<tr class="separator:a068f9696659c2b957cb31151804ce01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af370594db3688b5d14c8ae9cf5125e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#af370594db3688b5d14c8ae9cf5125e28">toUpperI</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:af370594db3688b5d14c8ae9cf5125e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace upper case conversion  <a href="namespaceicl_1_1utils.html#af370594db3688b5d14c8ae9cf5125e28">More...</a><br /></td></tr>
<tr class="separator:af370594db3688b5d14c8ae9cf5125e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5654dd531ad1e22358e040c7a35fc71e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a5654dd531ad1e22358e040c7a35fc71e">toLower</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a5654dd531ad1e22358e040c7a35fc71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">lower case conversion  <a href="namespaceicl_1_1utils.html#a5654dd531ad1e22358e040c7a35fc71e">More...</a><br /></td></tr>
<tr class="separator:a5654dd531ad1e22358e040c7a35fc71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b6270b70846184ebde6c6b0f949b99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a53b6270b70846184ebde6c6b0f949b99">toUpper</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a53b6270b70846184ebde6c6b0f949b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">upper case conversion  <a href="namespaceicl_1_1utils.html#a53b6270b70846184ebde6c6b0f949b99">More...</a><br /></td></tr>
<tr class="separator:a53b6270b70846184ebde6c6b0f949b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad441f647a7e4f47e6789d5f5a382dceb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ad441f647a7e4f47e6789d5f5a382dceb">tok</a> (const std::string &amp;s, const std::string &amp;delims=&quot; &quot;, bool singleCharDelims=true, char escapeChar='\0')</td></tr>
<tr class="memdesc:ad441f647a7e4f47e6789d5f5a382dceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">tokenizes a string with given delimiters (internally using a temporary <a class="el" href="classicl_1_1utils_1_1StrTok.html" title="String Tokenizer Utility class.">StrTok</a> instance)  <a href="namespaceicl_1_1utils.html#ad441f647a7e4f47e6789d5f5a382dceb">More...</a><br /></td></tr>
<tr class="separator:ad441f647a7e4f47e6789d5f5a382dceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b71ded05def90d5b8941f203359503f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a4b71ded05def90d5b8941f203359503f">tok</a> (const std::string &amp;s, const std::string &amp;delim, std::vector&lt; std::string &gt; &amp;dst, bool singleCharDelims=true, char escapeChar='\0')</td></tr>
<tr class="memdesc:a4b71ded05def90d5b8941f203359503f"><td class="mdescLeft">&#160;</td><td class="mdescRight">tokenize a string with given delimiters into a result vector (optimized)  <a href="namespaceicl_1_1utils.html#a4b71ded05def90d5b8941f203359503f">More...</a><br /></td></tr>
<tr class="separator:a4b71ded05def90d5b8941f203359503f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1429a32f96ec90c4569b243d7a2020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#acc1429a32f96ec90c4569b243d7a2020">cat</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:acc1429a32f96ec90c4569b243d7a2020"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatinates at string-vector to a single string  <a href="namespaceicl_1_1utils.html#acc1429a32f96ec90c4569b243d7a2020">More...</a><br /></td></tr>
<tr class="separator:acc1429a32f96ec90c4569b243d7a2020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d152706acbfda12282611b1ab04a81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a98d152706acbfda12282611b1ab04a81">toStr</a> (int i, const char *format, char *buf=0)</td></tr>
<tr class="memdesc:a98d152706acbfda12282611b1ab04a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a string from a given integer  <a href="namespaceicl_1_1utils.html#a98d152706acbfda12282611b1ab04a81">More...</a><br /></td></tr>
<tr class="separator:a98d152706acbfda12282611b1ab04a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc319551262ad0298d05a02a31d25f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#afc319551262ad0298d05a02a31d25f43">toStr</a> (double d, const char *format, char *buf=0)</td></tr>
<tr class="memdesc:afc319551262ad0298d05a02a31d25f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a string from a given double/float  <a href="namespaceicl_1_1utils.html#afc319551262ad0298d05a02a31d25f43">More...</a><br /></td></tr>
<tr class="separator:afc319551262ad0298d05a02a31d25f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca6a4eddfcf75660ed5cd5df576face"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a3ca6a4eddfcf75660ed5cd5df576face">toStr</a> (int i, char *buf=0)</td></tr>
<tr class="memdesc:a3ca6a4eddfcf75660ed5cd5df576face"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a string from given integer using format string "%d"  <a href="namespaceicl_1_1utils.html#a3ca6a4eddfcf75660ed5cd5df576face">More...</a><br /></td></tr>
<tr class="separator:a3ca6a4eddfcf75660ed5cd5df576face"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81dde056ececa90ea99e20afe3431d2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a81dde056ececa90ea99e20afe3431d2a">toStr</a> (double d, char *buf=0)</td></tr>
<tr class="memdesc:a81dde056ececa90ea99e20afe3431d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a string from given float using format string "%f"  <a href="namespaceicl_1_1utils.html#a81dde056ececa90ea99e20afe3431d2a">More...</a><br /></td></tr>
<tr class="separator:a81dde056ececa90ea99e20afe3431d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5b026efe9b2f895c42bd124a2d3786"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2d5b026efe9b2f895c42bd124a2d3786"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a2d5b026efe9b2f895c42bd124a2d3786">str</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a2d5b026efe9b2f895c42bd124a2d3786"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a data type into a string using an std::ostringstream instance  <a href="namespaceicl_1_1utils.html#a2d5b026efe9b2f895c42bd124a2d3786">More...</a><br /></td></tr>
<tr class="separator:a2d5b026efe9b2f895c42bd124a2d3786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9f30735a5e9e55553863ccfa18ade9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7c9f30735a5e9e55553863ccfa18ade9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a7c9f30735a5e9e55553863ccfa18ade9">str</a> (const <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a> &amp;t)</td></tr>
<tr class="memdesc:a7c9f30735a5e9e55553863ccfa18ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialized for icl8u  <a href="namespaceicl_1_1utils.html#a7c9f30735a5e9e55553863ccfa18ade9">More...</a><br /></td></tr>
<tr class="separator:a7c9f30735a5e9e55553863ccfa18ade9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52716cac258b218a847285facabc8e61"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a52716cac258b218a847285facabc8e61"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a52716cac258b218a847285facabc8e61">str</a> (const bool &amp;b)</td></tr>
<tr class="memdesc:a52716cac258b218a847285facabc8e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialized for bool  <a href="namespaceicl_1_1utils.html#a52716cac258b218a847285facabc8e61">More...</a><br /></td></tr>
<tr class="separator:a52716cac258b218a847285facabc8e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f426d9a3c02f382e3e26ad862d665f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a70f426d9a3c02f382e3e26ad862d665f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a70f426d9a3c02f382e3e26ad862d665f">str</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a70f426d9a3c02f382e3e26ad862d665f"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialized for std::string input (this is quiet silly)  <a href="namespaceicl_1_1utils.html#a70f426d9a3c02f382e3e26ad862d665f">More...</a><br /></td></tr>
<tr class="separator:a70f426d9a3c02f382e3e26ad862d665f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626184c34b4c5bdaa6c2395b437aadc3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a626184c34b4c5bdaa6c2395b437aadc3"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a626184c34b4c5bdaa6c2395b437aadc3">str</a> (char *const &amp;pc)</td></tr>
<tr class="memdesc:a626184c34b4c5bdaa6c2395b437aadc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialized for char const pointers  <a href="namespaceicl_1_1utils.html#a626184c34b4c5bdaa6c2395b437aadc3">More...</a><br /></td></tr>
<tr class="separator:a626184c34b4c5bdaa6c2395b437aadc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4a1b3013689097db6b0a6895770c3c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4d4a1b3013689097db6b0a6895770c3c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a4d4a1b3013689097db6b0a6895770c3c">str</a> (const char *const &amp;pc)</td></tr>
<tr class="memdesc:a4d4a1b3013689097db6b0a6895770c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialized for const char const pointers  <a href="namespaceicl_1_1utils.html#a4d4a1b3013689097db6b0a6895770c3c">More...</a><br /></td></tr>
<tr class="separator:a4d4a1b3013689097db6b0a6895770c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bbb8f49fd51e557f8826ccc6d196ab"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a39bbb8f49fd51e557f8826ccc6d196ab"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a39bbb8f49fd51e557f8826ccc6d196ab">cat</a> (const std::vector&lt; T &gt; &amp;v, const std::string &amp;delim=&quot;,&quot;)</td></tr>
<tr class="memdesc:a39bbb8f49fd51e557f8826ccc6d196ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a delim-separated string of str'ed values of given vector  <a href="namespaceicl_1_1utils.html#a39bbb8f49fd51e557f8826ccc6d196ab">More...</a><br /></td></tr>
<tr class="separator:a39bbb8f49fd51e557f8826ccc6d196ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf625b3751a1fef84be84459fc3f7c15"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acf625b3751a1fef84be84459fc3f7c15"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#acf625b3751a1fef84be84459fc3f7c15">parse</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:acf625b3751a1fef84be84459fc3f7c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses a string into template parameter (defined for iclXX and std::string)  <a href="namespaceicl_1_1utils.html#acf625b3751a1fef84be84459fc3f7c15">More...</a><br /></td></tr>
<tr class="separator:acf625b3751a1fef84be84459fc3f7c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df21a9e3eaa5f045c2e3cc06bb79524"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2df21a9e3eaa5f045c2e3cc06bb79524"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a2df21a9e3eaa5f045c2e3cc06bb79524">parse</a> (const std::string &amp;s)</td></tr>
<tr class="separator:a2df21a9e3eaa5f045c2e3cc06bb79524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada12c5a77960b8adcbbfcf0e653020be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ada12c5a77960b8adcbbfcf0e653020be">to8u</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ada12c5a77960b8adcbbfcf0e653020be"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast a string to an icl8u (parse)  <a href="namespaceicl_1_1utils.html#ada12c5a77960b8adcbbfcf0e653020be">More...</a><br /></td></tr>
<tr class="separator:ada12c5a77960b8adcbbfcf0e653020be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c07338ec802e96bc3a3217aae91cd3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#a79af5b84ad2c6e4acf44ae0530d89269">icl16s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a7c07338ec802e96bc3a3217aae91cd3a">to16s</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a7c07338ec802e96bc3a3217aae91cd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast a string to an icl16s (parse)  <a href="namespaceicl_1_1utils.html#a7c07338ec802e96bc3a3217aae91cd3a">More...</a><br /></td></tr>
<tr class="separator:a7c07338ec802e96bc3a3217aae91cd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d5c6471b2c29e7988cd8987e68a4d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ac6d5c6471b2c29e7988cd8987e68a4d1">to32s</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ac6d5c6471b2c29e7988cd8987e68a4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast a string to an icl32ss (parse)  <a href="namespaceicl_1_1utils.html#ac6d5c6471b2c29e7988cd8987e68a4d1">More...</a><br /></td></tr>
<tr class="separator:ac6d5c6471b2c29e7988cd8987e68a4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a2cd45fb2d0d6971a5faaf18299988"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a61a2cd45fb2d0d6971a5faaf18299988">to32f</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a61a2cd45fb2d0d6971a5faaf18299988"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast a string to an icl32f (parse)  <a href="namespaceicl_1_1utils.html#a61a2cd45fb2d0d6971a5faaf18299988">More...</a><br /></td></tr>
<tr class="separator:a61a2cd45fb2d0d6971a5faaf18299988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70d2c79cd466261a34ef0ee6be2fafa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#ac70d2c79cd466261a34ef0ee6be2fafa">to64f</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ac70d2c79cd466261a34ef0ee6be2fafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast a string to an icl64f (parse)  <a href="namespaceicl_1_1utils.html#ac70d2c79cd466261a34ef0ee6be2fafa">More...</a><br /></td></tr>
<tr class="separator:ac70d2c79cd466261a34ef0ee6be2fafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bd6e2fe3524e2f327aaab0da023e25"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a09bd6e2fe3524e2f327aaab0da023e25"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a09bd6e2fe3524e2f327aaab0da023e25">parseVec</a> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a09bd6e2fe3524e2f327aaab0da023e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a vector of strings into a vector of T's  <a href="namespaceicl_1_1utils.html#a09bd6e2fe3524e2f327aaab0da023e25">More...</a><br /></td></tr>
<tr class="separator:a09bd6e2fe3524e2f327aaab0da023e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae6b955625941851ba5803bc2b6b7ed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2ae6b955625941851ba5803bc2b6b7ed"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a2ae6b955625941851ba5803bc2b6b7ed">parseVecStr</a> (const std::string &amp;vecStr, const std::string &amp;delims=&quot;,&quot;)</td></tr>
<tr class="memdesc:a2ae6b955625941851ba5803bc2b6b7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">parse a delims seperated string into a vector of T's  <a href="namespaceicl_1_1utils.html#a2ae6b955625941851ba5803bc2b6b7ed">More...</a><br /></td></tr>
<tr class="separator:a2ae6b955625941851ba5803bc2b6b7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e9b401f0f61d6a3454e5d44f737e15"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a31e9b401f0f61d6a3454e5d44f737e15"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a31e9b401f0f61d6a3454e5d44f737e15">strVec</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a31e9b401f0f61d6a3454e5d44f737e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a vector of T's into a vector of strings  <a href="namespaceicl_1_1utils.html#a31e9b401f0f61d6a3454e5d44f737e15">More...</a><br /></td></tr>
<tr class="separator:a31e9b401f0f61d6a3454e5d44f737e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac982322467e18245362b025410d8654"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="structicl_1_1utils_1_1MatchResult.html">MatchResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aac982322467e18245362b025410d8654">match</a> (const std::string &amp;text, const std::string &amp;regex, int numSubMatches=0)</td></tr>
<tr class="memdesc:aac982322467e18245362b025410d8654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a regular expression match on given text and regex pattern (internally using regex.h)  <a href="namespaceicl_1_1utils.html#aac982322467e18245362b025410d8654">More...</a><br /></td></tr>
<tr class="separator:aac982322467e18245362b025410d8654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ef89bd72737381461b9989fde3a6d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a15ef89bd72737381461b9989fde3a6d9">time2str</a> (<a class="el" href="classicl_1_1utils_1_1Time.html#accb09f29ecb73fc67cb7d5c3b548a193">Time::value_type</a> x)</td></tr>
<tr class="memdesc:a15ef89bd72737381461b9989fde3a6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a <a class="el" href="classicl_1_1utils_1_1Time.html#accb09f29ecb73fc67cb7d5c3b548a193" title="internal data type (64Bit integer)">Time::value_type</a> (long int) into a string  <a href="namespaceicl_1_1utils.html#a15ef89bd72737381461b9989fde3a6d9">More...</a><br /></td></tr>
<tr class="separator:a15ef89bd72737381461b9989fde3a6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496808514e6e574c855804f0de857f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a496808514e6e574c855804f0de857f43">skipWhitespaces</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a496808514e6e574c855804f0de857f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">crops trailing whitespaces of a string  <a href="namespaceicl_1_1utils.html#a496808514e6e574c855804f0de857f43">More...</a><br /></td></tr>
<tr class="separator:a496808514e6e574c855804f0de857f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db7c551cfde3abfc5e7680a3c2c0a23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a1db7c551cfde3abfc5e7680a3c2c0a23">endsWith</a> (const std::string &amp;s, const std::string &amp;suffix)</td></tr>
<tr class="memdesc:a1db7c551cfde3abfc5e7680a3c2c0a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether a given string ends with a given suffix  <a href="namespaceicl_1_1utils.html#a1db7c551cfde3abfc5e7680a3c2c0a23">More...</a><br /></td></tr>
<tr class="separator:a1db7c551cfde3abfc5e7680a3c2c0a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44635de59c2c51ed966aa4345ade29b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a44635de59c2c51ed966aa4345ade29b0">startsWith</a> (const std::string &amp;s, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:a44635de59c2c51ed966aa4345ade29b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether a given string begins with a given prefix  <a href="namespaceicl_1_1utils.html#a44635de59c2c51ed966aa4345ade29b0">More...</a><br /></td></tr>
<tr class="separator:a44635de59c2c51ed966aa4345ade29b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a9c64a81224a9eb4b1889843faaf79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a27a9c64a81224a9eb4b1889843faaf79">analyseHashes</a> (const std::string &amp;sFileName, unsigned int &amp;nHashes, std::string::size_type &amp;iPostfixPos)</td></tr>
<tr class="memdesc:a27a9c64a81224a9eb4b1889843faaf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">analyses a file pattern with hash-characters  <a href="namespaceicl_1_1utils.html#a27a9c64a81224a9eb4b1889843faaf79">More...</a><br /></td></tr>
<tr class="separator:a27a9c64a81224a9eb4b1889843faaf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76582c40992146adb82e92cc1d47972"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aa76582c40992146adb82e92cc1d47972">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="classicl_1_1utils_1_1TextTable.html">TextTable</a> &amp;t)</td></tr>
<tr class="memdesc:aa76582c40992146adb82e92cc1d47972"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded ostream-operator that uses the <a class="el" href="classicl_1_1utils_1_1TextTable.html" title="Utility class for pretty console output.">TextTable</a>'s toString method for serialization  <a href="namespaceicl_1_1utils.html#aa76582c40992146adb82e92cc1d47972">More...</a><br /></td></tr>
<tr class="separator:aa76582c40992146adb82e92cc1d47972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b491cddfe07995ee2d61b8204ba9f61"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1b491cddfe07995ee2d61b8204ba9f61"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a1b491cddfe07995ee2d61b8204ba9f61">saveDelete</a> (T *&amp;pointer)</td></tr>
<tr class="memdesc:a1b491cddfe07995ee2d61b8204ba9f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">static utility function which deletes a pointer and sets it to NULL  <a href="namespaceicl_1_1utils.html#a1b491cddfe07995ee2d61b8204ba9f61">More...</a><br /></td></tr>
<tr class="separator:a1b491cddfe07995ee2d61b8204ba9f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fe536b27f8bb6d4943225c85a7d31c"><td class="memTemplParams" colspan="2">template&lt;class T , void(T::*)() func&gt; </td></tr>
<tr class="memitem:a74fe536b27f8bb6d4943225c85a7d31c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a74fe536b27f8bb6d4943225c85a7d31c">saveCall</a> (T *obj)</td></tr>
<tr class="memdesc:a74fe536b27f8bb6d4943225c85a7d31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">static utility function which ensures Thread-safety for object functions  <a href="namespaceicl_1_1utils.html#a74fe536b27f8bb6d4943225c85a7d31c">More...</a><br /></td></tr>
<tr class="separator:a74fe536b27f8bb6d4943225c85a7d31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a28c3807c297690ce0787a155b5d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aa1a28c3807c297690ce0787a155b5d22">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="classicl_1_1utils_1_1Time.html">Time</a> &amp;)</td></tr>
<tr class="memdesc:aa1a28c3807c297690ce0787a155b5d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes <a class="el" href="classicl_1_1utils_1_1Time.html" title="ICL Time class (taken from the Ice lib)">Time</a> instances value type into the stream  <a href="namespaceicl_1_1utils.html#aa1a28c3807c297690ce0787a155b5d22">More...</a><br /></td></tr>
<tr class="separator:aa1a28c3807c297690ce0787a155b5d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1b5259c48885bef66ffac9d2496585"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#abc1b5259c48885bef66ffac9d2496585">operator&gt;&gt;</a> (std::istream &amp;, <a class="el" href="classicl_1_1utils_1_1Time.html">Time</a> &amp;)</td></tr>
<tr class="memdesc:abc1b5259c48885bef66ffac9d2496585"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads <a class="el" href="classicl_1_1utils_1_1Time.html" title="ICL Time class (taken from the Ice lib)">Time</a> instances value type from the stream  <a href="namespaceicl_1_1utils.html#abc1b5259c48885bef66ffac9d2496585">More...</a><br /></td></tr>
<tr class="separator:abc1b5259c48885bef66ffac9d2496585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a89bd2d940f8ffe29b66ccbe3d1d8d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a81a89bd2d940f8ffe29b66ccbe3d1d8d">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Text.html">VisualizationDescription::Text</a> &amp;t)</td></tr>
<tr class="separator:a81a89bd2d940f8ffe29b66ccbe3d1d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd347ee1912151acde96bdc37af7f76a"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#acd347ee1912151acde96bdc37af7f76a">operator&gt;&gt;</a> (std::istream &amp;stream, <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Text.html">VisualizationDescription::Text</a> &amp;t)</td></tr>
<tr class="separator:acd347ee1912151acde96bdc37af7f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7429c8c8aae964a8c8fedc7f8c067679"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#a7429c8c8aae964a8c8fedc7f8c067679">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Color.html">VisualizationDescription::Color</a> &amp;c)</td></tr>
<tr class="memdesc:a7429c8c8aae964a8c8fedc7f8c067679"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded ostream operator for <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Color.html" title="Utility Color class.">VisualizationDescription::Color</a>  <a href="namespaceicl_1_1utils.html#a7429c8c8aae964a8c8fedc7f8c067679">More...</a><br /></td></tr>
<tr class="separator:a7429c8c8aae964a8c8fedc7f8c067679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae812a5e21784b62c94eb3b9f90f5c89"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicl_1_1utils.html#aae812a5e21784b62c94eb3b9f90f5c89">operator&gt;&gt;</a> (std::istream &amp;stream, <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Color.html">VisualizationDescription::Color</a> &amp;c)</td></tr>
<tr class="memdesc:aae812a5e21784b62c94eb3b9f90f5c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded istream operator for <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Color.html" title="Utility Color class.">VisualizationDescription::Color</a>  <a href="namespaceicl_1_1utils.html#aae812a5e21784b62c94eb3b9f90f5c89">More...</a><br /></td></tr>
<tr class="separator:aae812a5e21784b62c94eb3b9f90f5c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af2d18b49744914a02335100a7e1acf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d18b49744914a02335100a7e1acf5c">&#9670;&nbsp;</a></span>XMLAttribute</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_attribute <a class="el" href="namespaceicl_1_1utils.html#af2d18b49744914a02335100a7e1acf5c">icl::utils::XMLAttribute</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XML Attribute class. </p>

</div>
</div>
<a id="ad98a2f1040f08ad89b6f37bd622d5540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98a2f1040f08ad89b6f37bd622d5540">&#9670;&nbsp;</a></span>XMLAttributeIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_attribute_iterator <a class="el" href="namespaceicl_1_1utils.html#ad98a2f1040f08ad89b6f37bd622d5540">icl::utils::XMLAttributeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator for XMLAttributes. </p>

</div>
</div>
<a id="a2c6617258b64b3c5d2c8c46097c1a9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6617258b64b3c5d2c8c46097c1a9a2">&#9670;&nbsp;</a></span>XMLDocument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_document <a class="el" href="namespaceicl_1_1utils.html#a2c6617258b64b3c5d2c8c46097c1a9a2">icl::utils::XMLDocument</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main XML Document class. </p>

</div>
</div>
<a id="ac1b5a74ab49c4ecf729ff79f4a1398d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b5a74ab49c4ecf729ff79f4a1398d9">&#9670;&nbsp;</a></span>XMLEncoding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_encoding <a class="el" href="namespaceicl_1_1utils.html#ac1b5a74ab49c4ecf729ff79f4a1398d9">icl::utils::XMLEncoding</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XML encoding type. </p>

</div>
</div>
<a id="a9494b9da22b01577face049e1d6ed859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9494b9da22b01577face049e1d6ed859">&#9670;&nbsp;</a></span>XMLFileWriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_writer_file <a class="el" href="namespaceicl_1_1utils.html#a9494b9da22b01577face049e1d6ed859">icl::utils::XMLFileWriter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XML writer implementation for files. </p>

</div>
</div>
<a id="af9b55b75b9f3e8c98a942b66fede26d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b55b75b9f3e8c98a942b66fede26d4">&#9670;&nbsp;</a></span>XMLNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_node <a class="el" href="namespaceicl_1_1utils.html#af9b55b75b9f3e8c98a942b66fede26d4">icl::utils::XMLNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XML Node class. </p>

</div>
</div>
<a id="a936d775ea623faa19fc928a3cd1f4921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936d775ea623faa19fc928a3cd1f4921">&#9670;&nbsp;</a></span>XMLNodeIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_node_iterator <a class="el" href="namespaceicl_1_1utils.html#a936d775ea623faa19fc928a3cd1f4921">icl::utils::XMLNodeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator for XMLNodes. </p>

</div>
</div>
<a id="a1102918d7e68a93745e7f74a7078adfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1102918d7e68a93745e7f74a7078adfe">&#9670;&nbsp;</a></span>XMLNodeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_node_type <a class="el" href="namespaceicl_1_1utils.html#a1102918d7e68a93745e7f74a7078adfe">icl::utils::XMLNodeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Node type. </p>

</div>
</div>
<a id="a412cc9cf6083d6333c78604ef94727e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412cc9cf6083d6333c78604ef94727e1">&#9670;&nbsp;</a></span>XMLParseResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_parse_result <a class="el" href="namespaceicl_1_1utils.html#a412cc9cf6083d6333c78604ef94727e1">icl::utils::XMLParseResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parsing status class. </p>

</div>
</div>
<a id="a7380cda56e95de92f70f252948b0f5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7380cda56e95de92f70f252948b0f5fa">&#9670;&nbsp;</a></span>XMLParseStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_parse_status <a class="el" href="namespaceicl_1_1utils.html#a7380cda56e95de92f70f252948b0f5fa">icl::utils::XMLParseStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parsing status enumeration. </p>

</div>
</div>
<a id="ac537c8425e9914956ac3bd975041d9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac537c8425e9914956ac3bd975041d9bf">&#9670;&nbsp;</a></span>XMLStreamWriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_writer_stream <a class="el" href="namespaceicl_1_1utils.html#ac537c8425e9914956ac3bd975041d9bf">icl::utils::XMLStreamWriter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XML writer implementation for streams. </p>

</div>
</div>
<a id="a1ddeca973de95d682cf38a847e6c8367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ddeca973de95d682cf38a847e6c8367">&#9670;&nbsp;</a></span>XMLTreeWalker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_tree_walker <a class="el" href="namespaceicl_1_1utils.html#a1ddeca973de95d682cf38a847e6c8367">icl::utils::XMLTreeWalker</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XML-Treewalker class. </p>

</div>
</div>
<a id="a558f49bca0dd7b0820e920f2768038a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558f49bca0dd7b0820e920f2768038a1">&#9670;&nbsp;</a></span>XMLWriter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xml_writer <a class="el" href="namespaceicl_1_1utils.html#a558f49bca0dd7b0820e920f2768038a1">icl::utils::XMLWriter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XML writer interface. </p>

</div>
</div>
<a id="a8b1eb073e25057ab4d9eceb1a5f90ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1eb073e25057ab4d9eceb1a5f90ead">&#9670;&nbsp;</a></span>XPathException</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xpath_exception <a class="el" href="namespaceicl_1_1utils.html#a8b1eb073e25057ab4d9eceb1a5f90ead">icl::utils::XPathException</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exception type for xpath expressions. </p>

</div>
</div>
<a id="a399ad00aad235807a3b01d3d38d875a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399ad00aad235807a3b01d3d38d875a2">&#9670;&nbsp;</a></span>XPathNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xpath_node <a class="el" href="namespaceicl_1_1utils.html#a399ad00aad235807a3b01d3d38d875a2">icl::utils::XPathNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special node type for XPath query results. </p>

</div>
</div>
<a id="ab597c9951467f2207683348197293db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab597c9951467f2207683348197293db7">&#9670;&nbsp;</a></span>XPathNodeSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xpath_node_set <a class="el" href="namespaceicl_1_1utils.html#ab597c9951467f2207683348197293db7">icl::utils::XPathNodeSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of XPath nodes. </p>

</div>
</div>
<a id="a09a99ed31a06bd85f8b74bccc73bc572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a99ed31a06bd85f8b74bccc73bc572">&#9670;&nbsp;</a></span>XPathParseResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xpath_parse_result <a class="el" href="namespaceicl_1_1utils.html#a09a99ed31a06bd85f8b74bccc73bc572">icl::utils::XPathParseResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse Result class for XPath expressions. </p>

</div>
</div>
<a id="ab6956a77040284bb2ea42f36e56bbaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6956a77040284bb2ea42f36e56bbaa9">&#9670;&nbsp;</a></span>XPathQuery</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xpath_query <a class="el" href="namespaceicl_1_1utils.html#ab6956a77040284bb2ea42f36e56bbaa9">icl::utils::XPathQuery</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precompiled XPath expression. </p>

</div>
</div>
<a id="acc62da0e115ef9098359e111dda5d826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc62da0e115ef9098359e111dda5d826">&#9670;&nbsp;</a></span>XPathValueType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xpath_value_type <a class="el" href="namespaceicl_1_1utils.html#acc62da0e115ef9098359e111dda5d826">icl::utils::XPathValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type enumeration for xpath values. </p>

</div>
</div>
<a id="aa4785745fdf04f2055ae5988ee7c57b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4785745fdf04f2055ae5988ee7c57b0">&#9670;&nbsp;</a></span>XPathVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xpath_variable <a class="el" href="namespaceicl_1_1utils.html#aa4785745fdf04f2055ae5988ee7c57b0">icl::utils::XPathVariable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable Type for XPath expressions. </p>

</div>
</div>
<a id="aa61574457d6516d5fd846af570fb91e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61574457d6516d5fd846af570fb91e8">&#9670;&nbsp;</a></span>XPathVariableSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef pugi::xpath_variable_set <a class="el" href="namespaceicl_1_1utils.html#aa61574457d6516d5fd846af570fb91e8">icl::utils::XPathVariableSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of XPathVariables. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a27a9c64a81224a9eb4b1889843faaf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a9c64a81224a9eb4b1889843faaf79">&#9670;&nbsp;</a></span>analyseHashes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void icl::utils::analyseHashes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>nHashes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type &amp;&#160;</td>
          <td class="paramname"><em>iPostfixPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>analyses a file pattern with hash-characters </p>
<p>This function is e.g. used by the FilennameGenerator to extract a patterns hash count e.g. the pattern "image_###.ppm" shall be used to generate filenames like "image_000.ppm", "image_001.ppm" and so on. This function returns the count of found hashes and the position in the string where the suffix begins. E.g. if the pattern is "image_##.ppm.gz", the hash-count is 2 and the suffix-pos becomes 8. </p>

</div>
</div>
<a id="acc1429a32f96ec90c4569b243d7a2020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc1429a32f96ec90c4569b243d7a2020">&#9670;&nbsp;</a></span>cat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::cat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>concatinates at string-vector to a single string </p>

</div>
</div>
<a id="a39bbb8f49fd51e557f8826ccc6d196ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bbb8f49fd51e557f8826ccc6d196ab">&#9670;&nbsp;</a></span>cat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string icl::utils::cat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a delim-separated string of str'ed values of given vector </p>
<p>e.g. if v is {1,2,3} and delim is '-' the resulting string will be "1-2-3" </p>

</div>
</div>
<a id="a0e3578da47f6113f7fc23e8900b3db85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3578da47f6113f7fc23e8900b3db85">&#9670;&nbsp;</a></span>clipped_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">D icl::utils::clipped_cast </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility cast function wrapping the standard lib's numerical_limits template </p>

</div>
</div>
<a id="a1db7c551cfde3abfc5e7680a3c2c0a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db7c551cfde3abfc5e7680a3c2c0a23">&#9670;&nbsp;</a></span>endsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> bool icl::utils::endsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether a given string ends with a given suffix </p>

</div>
</div>
<a id="ae2bb2190a81f806aed37321b15d7305f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bb2190a81f806aed37321b15d7305f">&#9670;&nbsp;</a></span>function() <span class="overload">[1/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a> icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shortcut create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> to wrap a const objects parameter-less function operator </p>
<dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a323cb5e86056fc5407811d6e8a260f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323cb5e86056fc5407811d6e8a260f38">&#9670;&nbsp;</a></span>function() <span class="overload">[2/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)() const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given parameter-less member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a14c2a9c20a1b977f1f3f04c309167eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c2a9c20a1b977f1f3f04c309167eb7">&#9670;&nbsp;</a></span>function() <span class="overload">[3/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A a) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given unary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a946fb6f0958e822c7cdba4623c7f1bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946fb6f0958e822c7cdba4623c7f1bc1">&#9670;&nbsp;</a></span>function() <span class="overload">[4/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A a, B b) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given unary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a6b7b24674899cb0950ba50a395819843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7b24674899cb0950ba50a395819843">&#9670;&nbsp;</a></span>function() <span class="overload">[5/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B, C&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A a, B b, C c) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given unary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a498d8a1dd020b651ffa043522aba2f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498d8a1dd020b651ffa043522aba2f83">&#9670;&nbsp;</a></span>function() <span class="overload">[6/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor</a>&lt; R, A, B, C &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from given object-functor (const version) </p>
<p>In constrast to functions, a pointer to an objects overloaded functor can only be defined hardly. Therefore this version of the <a class="el" href="namespaceicl_1_1utils.html#ade08b80a6f07c48da47366d83862ed39" title="Create Function instances from member functions.">icl::utils::function</a>-template allows to pick a functor from a given object </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a0f05b13ddb6fe0c123fbc3607b8d9cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f05b13ddb6fe0c123fbc3607b8d9cd8">&#9670;&nbsp;</a></span>function() <span class="overload">[7/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)() const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given parameter-less member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a4dcccfb090e1c675713df0a5d4a542d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcccfb090e1c675713df0a5d4a542d5">&#9670;&nbsp;</a></span>function() <span class="overload">[8/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given unary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="aa2a77124bd81143616f631b9fd44824a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a77124bd81143616f631b9fd44824a">&#9670;&nbsp;</a></span>function() <span class="overload">[9/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A, B) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member functions. </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given binary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="aba1de98706efef18af604b84f3f6ef77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1de98706efef18af604b84f3f6ef77">&#9670;&nbsp;</a></span>function() <span class="overload">[10/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B, C&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A, B, C) const&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from const member functions. </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given binary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="addd679590d93869fe7312e09eb3067c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd679590d93869fe7312e09eb3067c7">&#9670;&nbsp;</a></span>function() <span class="overload">[11/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B, C&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">const Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor</a>&lt; R, A, B, C &gt;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from given object-functor (const version) </p>
<p>In constrast to functions, a pointer to an objects overloaded functor can only be defined hardly. Therefore this version of the <a class="el" href="namespaceicl_1_1utils.html#ade08b80a6f07c48da47366d83862ed39" title="Create Function instances from member functions.">icl::utils::function</a>-template allows to pick a functor from a given object </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="ab1c550aeacbc66702c7f7fe12d0d6c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c550aeacbc66702c7f7fe12d0d6c6d">&#9670;&nbsp;</a></span>function() <span class="overload">[12/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a> icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shortcut create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> to wrap an objects parameter-less function operator </p>
<dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a0f166bfffc5737cd30db1ae4eed4f48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f166bfffc5737cd30db1ae4eed4f48e">&#9670;&nbsp;</a></span>function() <span class="overload">[13/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)()&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given parameter-less member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a4b711869f762e42579988aaaec327269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b711869f762e42579988aaaec327269">&#9670;&nbsp;</a></span>function() <span class="overload">[14/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given unary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a6d0b18be142831b208ff94179abf83ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0b18be142831b208ff94179abf83ae">&#9670;&nbsp;</a></span>function() <span class="overload">[15/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A, B)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member functions. </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given binary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="ade08b80a6f07c48da47366d83862ed39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade08b80a6f07c48da47366d83862ed39">&#9670;&nbsp;</a></span>function() <span class="overload">[16/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B, C&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A, B, C)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member functions. </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given binary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a58f3522cf4c08cf77a05f8a9295f2c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f3522cf4c08cf77a05f8a9295f2c07">&#9670;&nbsp;</a></span>function() <span class="overload">[17/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B, C&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor</a>&lt; R, A, B, C &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from given object-functor </p>
<p>In constrast to functions, a pointer to an objects overloaded functor can only be defined hardly. Therefore this version of the <a class="el" href="namespaceicl_1_1utils.html#ade08b80a6f07c48da47366d83862ed39" title="Create Function instances from member functions.">icl::utils::function</a>-template allows to pick a functor from a given object </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="ad0f5cb7b2b0cc5c5203ccc9e0d8326a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f5cb7b2b0cc5c5203ccc9e0d8326a7">&#9670;&nbsp;</a></span>function() <span class="overload">[18/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)()&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given parameter-less member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="ae2b3a2c8d248ca6c62b404930429b7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b3a2c8d248ca6c62b404930429b7b2">&#9670;&nbsp;</a></span>function() <span class="overload">[19/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member function </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given unary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="ad51c05734a1d8ee4ca1857a7675d3dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51c05734a1d8ee4ca1857a7675d3dc8">&#9670;&nbsp;</a></span>function() <span class="overload">[20/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A, B)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member functions. </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given binary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="accc1d4f899ea4dc818bdda2d1c1fad40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc1d4f899ea4dc818bdda2d1c1fad40">&#9670;&nbsp;</a></span>function() <span class="overload">[21/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B, C&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(Object::*)(A, B, C)&#160;</td>
          <td class="paramname"><em>method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from member functions. </p>
<p>This version of function allows to create a <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instance from a given object instance (passed by reference) and a given binary member function </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a2099a7b8280d73b8972f588f2fde2bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2099a7b8280d73b8972f588f2fde2bed">&#9670;&nbsp;</a></span>function() <span class="overload">[22/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Object , class R , class A , class B , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B, C&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">Object *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1utils_1_1SelectFunctor.html">SelectFunctor</a>&lt; R, A, B, C &gt;&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create <a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> instances from given object-functor </p>
<p>In constrast to functions, a pointer to an objects overloaded functor can only be defined hardly. Therefore this version of the <a class="el" href="namespaceicl_1_1utils.html#ade08b80a6f07c48da47366d83862ed39" title="Create Function instances from member functions.">icl::utils::function</a>-template allows to pick a functor from a given object </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a3a8e01016489f91e3b3ba651cbbfb44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8e01016489f91e3b3ba651cbbfb44f">&#9670;&nbsp;</a></span>function() <span class="overload">[23/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">R(*)()&#160;</td>
          <td class="paramname"><em>global_function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> creator function from given parameter less global function. </p>
<p>In contrast to the constructor, this method can automatically detect the parameter types (like std::make_pair) </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="ac21d22fb013c1b1e8d05b69c8821c3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21d22fb013c1b1e8d05b69c8821c3ad">&#9670;&nbsp;</a></span>function() <span class="overload">[24/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">R(*)(A a)&#160;</td>
          <td class="paramname"><em>global_function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> creator function from given unary global function. </p>
<p>In contrast to the constructor, this method can automatically detect the parameter types (like std::make_pair) </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a35d60c714a80dd12bec0bb9b21e735b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d60c714a80dd12bec0bb9b21e735b5">&#9670;&nbsp;</a></span>function() <span class="overload">[25/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class A , class B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">R(*)(A a, B b)&#160;</td>
          <td class="paramname"><em>global_function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> creator function from given binary global function. </p>
<p>In contrast to the constructor, this method can automatically detect the parameter types (like std::make_pair) </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a1fe05f20eeb973e69f3609186d45db5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe05f20eeb973e69f3609186d45db5e">&#9670;&nbsp;</a></span>function() <span class="overload">[26/26]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class A , class B , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1Function.html">Function</a>&lt;R, A, B, C&gt; icl::utils::function </td>
          <td>(</td>
          <td class="paramtype">R(*)(A a, B b, C c)&#160;</td>
          <td class="paramname"><em>global_function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structicl_1_1utils_1_1Function.html" title="The General Function Template.">Function</a> creator function from given binary global function. </p>
<p>In contrast to the constructor, this method can automatically detect the parameter types (like std::make_pair) </p><dl class="section see"><dt>See also</dt><dd>FUNCTION_SECTION </dd></dl>

</div>
</div>
<a id="a9cd5c572f28873aaaddd13692c099465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd5c572f28873aaaddd13692c099465">&#9670;&nbsp;</a></span>gaussRandom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> double icl::utils::gaussRandom </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a gaussian random number with given mean and variance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>mode of the gaussian </td></tr>
    <tr><td class="paramname">var</td><td>variance of the gaussian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gaussian distributed variable </dd></dl>
<dl class="section see"><dt>See also</dt><dd>double(double,double,const Range&lt;double&gt;&amp;), </dd></dl>

</div>
</div>
<a id="a2fd21725893b78f862cce6a2300f7420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd21725893b78f862cce6a2300f7420">&#9670;&nbsp;</a></span>gaussRandom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double icl::utils::gaussRandom </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">Range</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a gaussian random number with given mean and variance and clips the result to a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>mode of the gaussian </td></tr>
    <tr><td class="paramname">var</td><td>variance of the gaussian </td></tr>
    <tr><td class="paramname">range</td><td>clipping range for the returned value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gaussian distributed variable clipped to range range </dd></dl>
<dl class="section see"><dt>See also</dt><dd>double(double,double,const Range&lt;double&gt;&amp;), </dd></dl>

</div>
</div>
<a id="a5299d2647ee0fc428899596673d21ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5299d2647ee0fc428899596673d21ea8">&#9670;&nbsp;</a></span>get_random_index_subset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; icl::utils::get_random_index_subset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>containerSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subsetSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6078568b9787fd6bba0c5193c621459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6078568b9787fd6bba0c5193c621459">&#9670;&nbsp;</a></span>get_random_subset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; icl::utils::get_random_subset </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subsetSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ce8648b6ef34d5b06b1b5d3ff9067a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce8648b6ef34d5b06b1b5d3ff9067a6">&#9670;&nbsp;</a></span>get_random_subset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icl::utils::get_random_subset </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subsetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>subset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a42fbec929b95b6795d99eb747e066026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fbec929b95b6795d99eb747e066026">&#9670;&nbsp;</a></span>get_random_subset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icl::utils::get_random_subset </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subsetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0b921c2c6858bc0c784b7a8981da951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b921c2c6858bc0c784b7a8981da951">&#9670;&nbsp;</a></span>icl_from_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; icl::utils::icl_from_stream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compability function that reads a datatype instance from a stream </p>
<p>This must be used, to ensure, icl8u data is read as (int) rather as char </p>

</div>
</div>
<a id="a511adecee62c1cfece562a7088d3df41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511adecee62c1cfece562a7088d3df41">&#9670;&nbsp;</a></span>icl_to_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; icl::utils::icl_to_stream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compatibility function that writes a datatype instance into a stream </p>
<p>This must be used, to ensure, icl8u data is shown as (int) rather as char </p>

</div>
</div>
<a id="a8665f8777d045f3beb0d5b6c2f669142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8665f8777d045f3beb0d5b6c2f669142">&#9670;&nbsp;</a></span>is_float_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icl::utils::is_float_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac982322467e18245362b025410d8654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac982322467e18245362b025410d8654">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="structicl_1_1utils_1_1MatchResult.html">MatchResult</a> icl::utils::match </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSubMatches</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a regular expression match on given text and regex pattern (internally using regex.h) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>source string </td></tr>
    <tr><td class="paramname">regex</td><td>regular expression to search in text </td></tr>
    <tr><td class="paramname">numSubMatches</td><td>If 0 (which is default, result contains only an information whether the match was successful or not. Sub matches can be recorded optionally using a numSubMatches value &gt; 0. Please note, that the whole pattern match is submatches[0] in the resulting <a class="el" href="structicl_1_1utils_1_1MatchResult.html" title="Utility structure for matching results.">MatchResult</a> if numSubMatches is at least 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0eaf41f5f332bc47b14f597a7b672c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0eaf41f5f332bc47b14f597a7b672c2">&#9670;&nbsp;</a></span>operator&amp;&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icl::utils::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allows to check more than two <a class="el" href="classicl_1_1utils_1_1ProgArg.html" title="Programm argument utility class.">ProgArg</a> instances at once </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-size&quot;</span>) &amp;&amp; <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-scale&quot;</span>) &amp;&amp; <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-format&quot;</span>)){ ... }</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adad13a6ff53a27c5e5e598acf2ce774a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad13a6ff53a27c5e5e598acf2ce774a">&#9670;&nbsp;</a></span>operator&amp;&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icl::utils::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allows to check more than two <a class="el" href="classicl_1_1utils_1_1ProgArg.html" title="Programm argument utility class.">ProgArg</a> instances at once </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-size&quot;</span>) &amp;&amp; <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-scale&quot;</span>) &amp;&amp; <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-format&quot;</span>)){ ... }</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a823ac1a418cb157cfe4f2c2feb8581ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823ac1a418cb157cfe4f2c2feb8581ce">&#9670;&nbsp;</a></span>operator&amp;&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icl::utils::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this allows to check if two progargs are defined </p>
<p>this allows you to write: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-size&quot;</span>) &amp;&amp; <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-scale&quot;</span>)){</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa1a28c3807c297690ce0787a155b5d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a28c3807c297690ce0787a155b5d22">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Time.html">Time</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writes <a class="el" href="classicl_1_1utils_1_1Time.html" title="ICL Time class (taken from the Ice lib)">Time</a> instances value type into the stream </p>

</div>
</div>
<a id="aaa6628d877a9fecb8109b41410f24e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa6628d877a9fecb8109b41410f24e3b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ostream operator WIDTHxHEIGHT </p>

</div>
</div>
<a id="a5f91a4b111d4b2f2cb004e139656b350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f91a4b111d4b2f2cb004e139656b350">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size32f.html">Size32f</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ostream operator WIDTHxHEIGHT </p>

</div>
</div>
<a id="ad21056ba630da04e4627e98d18735dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21056ba630da04e4627e98d18735dc3">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ConfigFile.html">ConfigFile</a> &amp;&#160;</td>
          <td class="paramname"><em>cf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default ostream operator to put a <a class="el" href="classicl_1_1utils_1_1ConfigFile.html" title="Utility class for creating and reading XML-based hierarchical configuration files.">ConfigFile</a> into a stream. </p>
<p>ostream operator is allowed to access privat members </p>

</div>
</div>
<a id="a790f07b4c393f081bf2c895e4331a28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790f07b4c393f081bf2c895e4331a28f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ostream operator (x,y) </p>

</div>
</div>
<a id="a03fadd0ecded116674822ee97a9b96b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03fadd0ecded116674822ee97a9b96b7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point32f.html">Point32f</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ostream operator (x,y) </p>

</div>
</div>
<a id="ab0ecced219e00aa40891d56945b32fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ecced219e00aa40891d56945b32fd9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1ProcessMonitor_1_1Info.html">ProcessMonitor::Info</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overloaded ostream operator for the <a class="el" href="classicl_1_1utils_1_1ProcessMonitor.html" title="The ProcessMonitor class grants access to processes memory and CPU usage.">ProcessMonitor</a>'s Info data type </p>

</div>
</div>
<a id="ad3a659069cc5f2083dbba906ad7d0e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a659069cc5f2083dbba906ad7d0e22">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>just puts the referenced argument value as string into the lvalue-stream </p>

</div>
</div>
<a id="ae2ccc6c00187cf56571b34deb35a8530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ccc6c00187cf56571b34deb35a8530">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Macros_8h.html#a7456583716d11c38193deeb09c7396a3">ICL_INSTANTIATE_ALL_DEPTHS</a> <a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>puts a string representation [min,max] of given range into the given stream </p>
<p>Available for all icl-Types (icl8u,icl16s, icl32s, icl32f and icl64f and for unsigned int </p>

</div>
</div>
<a id="ae4999ee5b18066bfa5dda32dbd717976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4999ee5b18066bfa5dda32dbd717976">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ostream operator (x,y)wxy </p>

</div>
</div>
<a id="a31ec750a00006864b78d9901663f2c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ec750a00006864b78d9901663f2c4e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect32f.html">Rect32f</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ostream operator (x,y)wxy </p>

</div>
</div>
<a id="a6c90a75ecb1fdade4c984a99bbf30191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c90a75ecb1fdade4c984a99bbf30191">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1SteppingRange.html">SteppingRange</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>puts a string representation [min,max]:step of given range into the given stream </p>
<p>Available for all icl-Types (icl8u,icl16s, icl32s, icl32f and icl64f and for unsigned int </p>

</div>
</div>
<a id="aa76582c40992146adb82e92cc1d47972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76582c40992146adb82e92cc1d47972">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1TextTable.html">TextTable</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overloaded ostream-operator that uses the <a class="el" href="classicl_1_1utils_1_1TextTable.html" title="Utility class for pretty console output.">TextTable</a>'s toString method for serialization </p>

</div>
</div>
<a id="a7429c8c8aae964a8c8fedc7f8c067679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7429c8c8aae964a8c8fedc7f8c067679">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Color.html">VisualizationDescription::Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overloaded ostream operator for <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Color.html" title="Utility Color class.">VisualizationDescription::Color</a> </p>

</div>
</div>
<a id="a81a89bd2d940f8ffe29b66ccbe3d1d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a89bd2d940f8ffe29b66ccbe3d1d8d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; icl::utils::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Text.html">VisualizationDescription::Text</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>overloaded ostream operator for <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Text.html" title="Utility class for Text.">VisualizationDescription::Text</a> syntax: (x,y)text </p>

</div>
</div>
<a id="abc1b5259c48885bef66ffac9d2496585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b5259c48885bef66ffac9d2496585">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Time.html">Time</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reads <a class="el" href="classicl_1_1utils_1_1Time.html" title="ICL Time class (taken from the Ice lib)">Time</a> instances value type from the stream </p>

</div>
</div>
<a id="a7e255851234f59e8d05191b12526e9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e255851234f59e8d05191b12526e9d5">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>istream operator parses a size from a string </p>
<p>also called in <a class="el" href="classicl_1_1utils_1_1Size.html#aae1d4c5ed356e7c4800675923c4c8a16" title="creates a size from given string (e.g. VGA, CIF, or 1024x768)">Size::Size(const std::string&amp;)</a> </p>

</div>
</div>
<a id="a822af8e5702bcb616c47a966725dc01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822af8e5702bcb616c47a966725dc01c">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Size32f.html">Size32f</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>istream operator </p>

</div>
</div>
<a id="ae6d023b64e5c63cabcbcb8f143019523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d023b64e5c63cabcbcb8f143019523">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>istream operator </p>

</div>
</div>
<a id="a0e836b45c78886a72f59ec362d651844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e836b45c78886a72f59ec362d651844">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Point32f.html">Point32f</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>istream operator </p>

</div>
</div>
<a id="ac35535c88517e5a6d9d4f3e48494926b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35535c88517e5a6d9d4f3e48494926b">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1utils_1_1Range.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses a range argument into a std::string </p>

</div>
</div>
<a id="a45c46acf9d9675287079a31840a68619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c46acf9d9675287079a31840a68619">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>istream operator </p>

</div>
</div>
<a id="a06f468d7e9c8c2f31fe15d18cb43ce47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f468d7e9c8c2f31fe15d18cb43ce47">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Rect32f.html">Rect32f</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>istream operator </p>

</div>
</div>
<a id="a8e517dfd2cfdcb4908d51b493b6248f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e517dfd2cfdcb4908d51b493b6248f2">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1utils_1_1SteppingRange.html">SteppingRange</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses a range argument into a std::string </p>

</div>
</div>
<a id="aae812a5e21784b62c94eb3b9f90f5c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae812a5e21784b62c94eb3b9f90f5c89">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Color.html">VisualizationDescription::Color</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overloaded istream operator for <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Color.html" title="Utility Color class.">VisualizationDescription::Color</a> </p>

</div>
</div>
<a id="acd347ee1912151acde96bdc37af7f76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd347ee1912151acde96bdc37af7f76a">&#9670;&nbsp;</a></span>operator&gt;&gt;() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; icl::utils::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Text.html">VisualizationDescription::Text</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>overloaded istream operator for <a class="el" href="structicl_1_1utils_1_1VisualizationDescription_1_1Text.html" title="Utility class for Text.">VisualizationDescription::Text</a> syntax: (x,y)text (text must be single lined) </p>

</div>
</div>
<a id="a678fec87681af38b957a16fb5b1dfe27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678fec87681af38b957a16fb5b1dfe27">&#9670;&nbsp;</a></span>operator||() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icl::utils::operator|| </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allows to check if either of more than two <a class="el" href="classicl_1_1utils_1_1ProgArg.html" title="Programm argument utility class.">ProgArg</a> instances is defined </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-size&quot;</span>) || <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-scale&quot;</span>) || <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-format&quot;</span>)){ ... }</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afaabc2afb6cf4dbca9475e7d9d1fd79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaabc2afb6cf4dbca9475e7d9d1fd79c">&#9670;&nbsp;</a></span>operator||() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icl::utils::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allows to check if either of more than two <a class="el" href="classicl_1_1utils_1_1ProgArg.html" title="Programm argument utility class.">ProgArg</a> instances is defined </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-size&quot;</span>) || <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-scale&quot;</span>) || <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-format&quot;</span>)){ ... }</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5d67ca9915ccb4d6721374735fcc4bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d67ca9915ccb4d6721374735fcc4bd8">&#9670;&nbsp;</a></span>operator||() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icl::utils::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this allows to check if either of two progargs are defined </p>
<p>this allows you to write: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-size&quot;</span>) || <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-scale&quot;</span>)){</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac1c1a1e771ecc0681b8f277040cc2c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c1a1e771ecc0681b8f277040cc2c99">&#9670;&nbsp;</a></span>pa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> icl::utils::pa </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>subargidx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns given program argument </p>
<p>The pa-function is the main interface for extracting information about given program arguments and/or their default values at run-time.</p>
<p>The returned <a class="el" href="classicl_1_1utils_1_1ProgArg.html" title="Programm argument utility class.">icl::utils::ProgArg</a> instance is always automatically parsed from its internal string representation into the expressions lvalue-type (this can easily be implemented with a <em>templated</em> version of the implicit cast operator of a class). Here are some examples:</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceicl_1_1utils.html#ade3aca94cda923d51cae6dbc51384d52">pa_init</a>(n,ppc,<span class="stringliteral">&quot;-size|-s(Size=VGA) -index(int) -files(...)&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// extract the first sub-argument of argument</span></div>
<div class="line"><span class="comment">// &#39;-index&#39; and convert it into an int value</span></div>
<div class="line"><span class="keywordtype">int</span> i = <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-index&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// extract the first sub-argument of argument &#39;-size&#39;</span></div>
<div class="line"><span class="comment">// if &#39;-s&#39; is the shortcut for &#39;-size&#39;</span></div>
<div class="line">Size s = <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-s&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// extract the 2nd sub-argument of argument &#39;-input&#39;</span></div>
<div class="line"><span class="keywordtype">int</span> = <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-input&quot;</span>,1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// check if argument -size was actually given</span></div>
<div class="line"><span class="keywordflow">if</span>(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-size&quot;</span>)){ ... }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// read a list of files from the arbitrary sub-argument</span></div>
<div class="line"><span class="comment">// arg &#39;-files&#39;. Note: it is not recommended to use</span></div>
<div class="line"><span class="comment">// pa(&quot;-files&quot;) within a loop, as internally the argument hash-</span></div>
<div class="line"><span class="comment">// map must always be searched</span></div>
<div class="line"><span class="keywordtype">int</span> nFiles = <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-files&quot;</span>).<a class="code" href="classicl_1_1utils_1_1ProgArg.html#af2d70c0fa1d696fe7b11c2194ef58afd">n</a>();</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;nFiles;++i){</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;file &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-files&quot;</span>,i) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// alternatively, the &quot;-files&quot; prog-arg can be extracted</span></div>
<div class="line">ProgArg f = <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-files&quot;</span>);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;f.n();++i){</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;file &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; f[i] &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// list all given arguments and subarguments</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;all arguments &quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="namespaceicl_1_1utils.html#a9d10d5cbc5c151413efea2bf9cd4abaf">pa_get_count</a>(<span class="keyword">false</span>);++i){</div>
<div class="line">  std::cout &lt;&lt; <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(i,<span class="keyword">false</span>) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// in case of having dangling arguments allowed in</span></div>
<div class="line"><span class="comment">// painit-call: list all dangling arguments</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;all dangling arguments &quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="namespaceicl_1_1utils.html#a9d10d5cbc5c151413efea2bf9cd4abaf">pa_get_count</a>();++i){</div>
<div class="line">  std::cout &lt;&lt; <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(i) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// using ProgArg instances as std::strings is sometimes</span></div>
<div class="line"><span class="comment">// a bit complicated as conversion to std::string is</span></div>
<div class="line"><span class="comment">// sometimes ambiguous</span></div>
<div class="line"><span class="keyword">struct </span>Test{</div>
<div class="line">   Test(<span class="keywordtype">int</span> i){...}</div>
<div class="line">   Test(<span class="keyword">const</span> std::string &amp;s){ .. }</div>
<div class="line">};</div>
<div class="line">...</div>
<div class="line">Test t(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-x&quot;</span>)); <span class="comment">// ambiguous -&gt; int | std::string</span></div>
<div class="line">Test t((std::string)<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-x&quot;</span>)); <span class="comment">// also ambiguous</span></div>
<div class="line"><span class="comment">// due to different available std::string constructors</span></div>
<div class="line"> </div>
<div class="line">Test t(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-x&quot;</span>).as&lt;std::string&gt;()); <span class="comment">// works, but long</span></div>
<div class="line"> </div>
<div class="line">Test t(*<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-x&quot;</span>)); <span class="comment">// much shorter, but only for using</span></div>
<div class="line"><span class="comment">// a program argument as std::string</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceicl_1_1utils.html#ade3aca94cda923d51cae6dbc51384d52" title="initialization function for ICL&#39;s program argument evaluation framework">icl::utils::pa_init(int,char**,const std::string&amp;,bool)</a> </dd></dl>

</div>
</div>
<a id="aab2262f412cdc83b5e049015fbfc5476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2262f412cdc83b5e049015fbfc5476">&#9670;&nbsp;</a></span>pa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1utils_1_1ProgArg.html">ProgArg</a> icl::utils::pa </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>danglingOnly</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns given program argument at given index </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99" title="returns given program argument">icl::utils::pa(const std::string&amp;,unsigned int)</a> </dd></dl>

</div>
</div>
<a id="a9b29bd24b6b27b3204d373eb5de55137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b29bd24b6b27b3204d373eb5de55137">&#9670;&nbsp;</a></span>pa_def() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T icl::utils::pa_def </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility function that allows to use a default value, if given argument was not defined </p>

</div>
</div>
<a id="a00a518df3feec5bfc3b75d7b75361e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a518df3feec5bfc3b75d7b75361e5f">&#9670;&nbsp;</a></span>pa_def() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T icl::utils::pa_def </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>subargidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility function that allows to use a default value, if given argument was not defined </p>

</div>
</div>
<a id="aa46ed3e5fd9ea82a1a91f9c6a43690dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46ed3e5fd9ea82a1a91f9c6a43690dd">&#9670;&nbsp;</a></span>pa_explain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PAEX icl::utils::pa_explain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function can be used to provide additional information for certain program arguments. </p>
<p>Due to the use of a special but hidden utility structure called icl::PAEX, this function can be called in a 'stacked' manner. This mean, that the function can be called several times without repeating the function name. Example: </p><div class="fragment"><div class="line">paex(<span class="stringliteral">&quot;-size&quot;</span>,<span class="stringliteral">&quot;defines the input image size&quot;</span>)</div>
<div class="line">    (<span class="stringliteral">&quot;-input&quot;</span>,<span class="stringliteral">&quot;defines input device id and parameters&quot;</span>)</div>
<div class="line">    (<span class="stringliteral">&quot;-format&quot;</span>,<span class="stringliteral">&quot;define input image format&quot;</span>);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99" title="returns given program argument">icl::utils::pa(const std::string&amp;,unsigned int)</a> </dd></dl>

</div>
</div>
<a id="a9d10d5cbc5c151413efea2bf9cd4abaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d10d5cbc5c151413efea2bf9cd4abaf">&#9670;&nbsp;</a></span>pa_get_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> unsigned int icl::utils::pa_get_count </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>danglingOnly</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns number of actually given args given </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99" title="returns given program argument">icl::utils::pa(const std::string&amp;,unsigned int)</a> </dd></dl>

</div>
</div>
<a id="aef20f39ea918ae71d815e596ceb8b783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef20f39ea918ae71d815e596ceb8b783">&#9670;&nbsp;</a></span>pa_get_help_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::pa_get_help_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current help text (which is empty, if it was not set) </p>

</div>
</div>
<a id="a700761c022812d1069c7bcdf85837a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700761c022812d1069c7bcdf85837a7f">&#9670;&nbsp;</a></span>pa_get_license()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::pa_get_license </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the current license text </p>

</div>
</div>
<a id="a979ac322cfa110abe66a2ef7a4a14bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979ac322cfa110abe66a2ef7a4a14bc9">&#9670;&nbsp;</a></span>pa_get_progname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&amp; icl::utils::pa_get_progname </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fullpath</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns application name (full command line) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullpath</td><td>if this is set to true, the complete first argument of main is returned, which may be something like <code>/usr/bin/icl-create</code>. If fullpath is false, which is default, just the program name is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99" title="returns given program argument">icl::utils::pa(const std::string&amp;,unsigned int)</a> </dd></dl>

</div>
</div>
<a id="ade3aca94cda923d51cae6dbc51384d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3aca94cda923d51cae6dbc51384d52">&#9670;&nbsp;</a></span>pa_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void icl::utils::pa_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ppc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDanglingArgs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialization function for ICL's program argument evaluation framework </p>
<p>painit always receives your program's <code>main</code>-functions arguments as <code>n</code> and <code>ppc</code>. The actual definition of the underlying program argument evaluation framework is given by the <code>init</code>- argument.<br  />
The following rules define the syntax for the <code>init</code>-string:<br  />
</p><ul>
<li>The init string consists of space-separated tokens of single program argument definitions. Necessary space-characters within these tokens must be escaped using a back-slash character.</li>
<li>Each single argument definition token consists of a pipe-separated list of argument name alternatives (e.g. <code>-size|-s</code> followed by an optional parameter list in round braces.</li>
<li>Each argument is allowed to have 0, N or unlimited sub-arguments.</li>
<li>If the argument has no sub arguments it is a flag, which implicitly has the value true if it was given and false otherwise. Zero sub- arguments can be forced by using no parameter list, i.e., no round braces, an empty parameter list <code>()</code> or a parameter list with a zero argument count <code>(0)</code>.</li>
<li>An arbitrary sub-argument count can be reached by using the special parameter list <code>(...)</code>.</li>
<li>Otherwise, the parameter-list is a comma separated list of type, type=default-value, or argument-count tokens. Examples:<ul>
<li><code>(int,int)</code> defines two integer sub-arguments</li>
<li><code>(5)</code> defines 5 sub-arguments with no type information</li>
<li><code>(float,2,int) defines 4 sub-arguments of type float, any, any and int</code></li>
<li><code><code>(int=4,<a class="el" href="classicl_1_1utils_1_1Size.html" title="Size class of the ICL.">Size</a>=VGA) defines two sub-arguments of type int and <a class="el" href="classicl_1_1utils_1_1Size.html" title="Size class of the ICL.">Size</a> with given default values 4 and VGA Note: if an int-type is used to define several arguments together, no defaults can be given. If you don't want to define the type, but only the default values, the special type string <code>*</code> should be used e.g., <code>(*=foo,*=bar)</code></code></code></li>
</ul>
</li>
</ul>
<p><code><code>Furthermore, it is worth to mention, that the defined types are always just hints for the user. Internally all parameters are treated as strings.</code></code></p>
<p><code><code>Here are some further complete example calls for painit. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> n, <span class="keywordtype">char</span> **ppc){</div>
<div class="line">  <a class="code" href="namespaceicl_1_1utils.html#ade3aca94cda923d51cae6dbc51384d52">icl::utils::pa_init</a>(n,ppc,<span class="stringliteral">&quot;-size|-s(Size=VGA) -format|-f(format-string)&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> n, <span class="keywordtype">char</span> **ppc){</div>
<div class="line">  <a class="code" href="namespaceicl_1_1utils.html#ade3aca94cda923d51cae6dbc51384d52">icl::utils::pa_init</a>(n,ppc,<span class="stringliteral">&quot;-input|-i(device-type=dc,device-params=0)&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></code></p>
<p><code><code></code></code></p>
<h1><a class="anchor" id="Dangling"></a>
Arguments</h1>
<p><code><code>Sometimes, certain arguments shall be used directly without defining arguments and sub-arguments. E.g. if you have a converter application that gets an input and an output file only (e.g., program call: <code>myConvert image.ppm converted-image.ppm</code> rather than something like <code>myConvert -i image.ppm -o converted-image.ppm</code>). Dangling arguments are these arguments that do not match defined arguments or sub-arguments of these. Usually, given arguments that do not match primary arguments or sub-arguments lead to a <a class="el" href="structicl_1_1utils_1_1ProgArgException.html" title="Programm argument environment exception type.">ProgArgException</a>. You can explicitly allow these <em>dangling</em> arguments by setting allowDanglingArgs to 'true'. <br  />
Dangling arguments can then be obtained simply using the functions <a class="el" href="namespaceicl_1_1utils.html#a9d10d5cbc5c151413efea2bf9cd4abaf" title="returns number of actually given args given">icl::utils::pa_get_count</a> and <a class="el" href="namespaceicl_1_1utils.html#aab2262f412cdc83b5e049015fbfc5476" title="returns given program argument at given index">icl::utils::pa(unsigned int,bool)</a>.</code></code></p>
<p><code><code>To list all dangling arguments, the followed code can be used: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="namespaceicl_1_1utils.html#a9d10d5cbc5c151413efea2bf9cd4abaf">icl::utils::pa_get_count</a>();++i){</div>
<div class="line">  std::cout &lt;&lt; <a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">icl::utils::pa</a>(i) &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p></code></code></p>
<p><code><code></code></code></p>
<h1><a class="anchor" id="Optional"></a>
and Mandatory Arguments</h1>
<p><code><code> As default, all arguments are optional. If you want to define an argument to be mandatory, simply prepend a '[m]'-prefix to the argument name alternative list. Example: </p><div class="fragment"><div class="line"><span class="comment">// -size and -format are optional; -input or -i is mandatory</span></div>
<div class="line"><a class="code" href="namespaceicl_1_1utils.html#ade3aca94cda923d51cae6dbc51384d52">icl::utils::pa_init</a>(n,ppc,<span class="stringliteral">&quot;-size(Size=VGA) -format(format=RGB) &quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;[m]-input|-i(string,string)&quot;</span>);</div>
</div><!-- fragment --><p></code></code></p>
<p><code><code>If mandatory arguments are not actually given to the program, a <a class="el" href="structicl_1_1utils_1_1ProgArgException.html" title="Programm argument environment exception type.">ProgArgException</a> is thrown. As it does not make sense to define default values for mandatory arguments, a <a class="el" href="structicl_1_1utils_1_1ProgArgException.html" title="Programm argument environment exception type.">ProgArgException</a> is thrown in this case as well. Furthermore, mandatory arguments must have sub-arguments (which is also sensible if you think about it). </code></code></p>

</div>
</div>
<a id="abd26fa1dc3b675e9ce15fbd4b146ef2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd26fa1dc3b675e9ce15fbd4b146ef2a">&#9670;&nbsp;</a></span>pa_set_help_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void icl::utils::pa_set_help_text </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newHelpText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a applications help text that is used when applications are run with &ndash;help or with unknown arguments. </p>
<p>pasethelp has to be called before painit is called. </p>

</div>
</div>
<a id="acfdab0a33af75906c566f5319254989d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfdab0a33af75906c566f5319254989d">&#9670;&nbsp;</a></span>pa_set_license()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void icl::utils::pa_set_license </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newLicenseText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a license text, that is used when applications are run with &ndash;version or -v. </p>
<p>pasetlic has to be called before painit is called. Otherwise, only the default licese text is shown. </p>

</div>
</div>
<a id="accb3a3fa44371c9e62d2524932fad1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb3a3fa44371c9e62d2524932fad1e4">&#9670;&nbsp;</a></span>pa_show()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void icl::utils::pa_show </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shows all given program arguments </p>

</div>
</div>
<a id="aae63f3f971b97b90a910e77f66c77c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae63f3f971b97b90a910e77f66c77c78">&#9670;&nbsp;</a></span>pa_show_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void icl::utils::pa_show_usage </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shows current available programm arguments </p>

</div>
</div>
<a id="acf625b3751a1fef84be84459fc3f7c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf625b3751a1fef84be84459fc3f7c15">&#9670;&nbsp;</a></span>parse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T icl::utils::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parses a string into template parameter (defined for iclXX and std::string) </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceicl_1_1utils.html#ada12c5a77960b8adcbbfcf0e653020be" title="cast a string to an icl8u (parse)">to8u</a> <a class="el" href="namespaceicl_1_1utils.html#a7c07338ec802e96bc3a3217aae91cd3a" title="cast a string to an icl16s (parse)">to16s</a> <a class="el" href="namespaceicl_1_1utils.html#ac6d5c6471b2c29e7988cd8987e68a4d1" title="cast a string to an icl32ss (parse)">to32s</a> <a class="el" href="namespaceicl_1_1utils.html#a61a2cd45fb2d0d6971a5faaf18299988" title="cast a string to an icl32f (parse)">to32f</a> <a class="el" href="namespaceicl_1_1utils.html#ac70d2c79cd466261a34ef0ee6be2fafa" title="cast a string to an icl64f (parse)">to64f</a> ( </dd></dl>

</div>
</div>
<a id="a2df21a9e3eaa5f045c2e3cc06bb79524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df21a9e3eaa5f045c2e3cc06bb79524">&#9670;&nbsp;</a></span>parse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* icl::utils::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09bd6e2fe3524e2f327aaab0da023e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bd6e2fe3524e2f327aaab0da023e25">&#9670;&nbsp;</a></span>parseVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; icl::utils::parseVec </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse a vector of strings into a vector of T's </p>

</div>
</div>
<a id="a2ae6b955625941851ba5803bc2b6b7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae6b955625941851ba5803bc2b6b7ed">&#9670;&nbsp;</a></span>parseVecStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; icl::utils::parseVecStr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vecStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parse a delims seperated string into a vector of T's </p>

</div>
</div>
<a id="a86f6a9b4d8f395166b3b1c46e2d78fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f6a9b4d8f395166b3b1c46e2d78fd2">&#9670;&nbsp;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , unsigned int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T icl::utils::power </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>power template </p>

</div>
</div>
<a id="a5d594a726349207153d3f50c30f112db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d594a726349207153d3f50c30f112db">&#9670;&nbsp;</a></span>progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void icl::utils::progress </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extraText</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>static utility function for displaying some progress information in console </p>
<p>Extra text is show behind the progress bar </p>

</div>
</div>
<a id="aeab533046b2fb60baa1745b5237b8393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab533046b2fb60baa1745b5237b8393">&#9670;&nbsp;</a></span>progress_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void icl::utils::progress_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>static utility function for displaying some progress information in console </p>

</div>
</div>
<a id="ab8d1b5ee1dbf6cb6b7fddce376290cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d1b5ee1dbf6cb6b7fddce376290cd1">&#9670;&nbsp;</a></span>progress_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> void icl::utils::progress_init </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em> = <code>&quot;Creating&#160;LUT&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>static utility function for displaying some progress information in console </p>

</div>
</div>
<a id="a41a2af0b4fc9ba9b6b3c01f29fe50f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a2af0b4fc9ba9b6b3c01f29fe50f76">&#9670;&nbsp;</a></span>random() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double icl::utils::random </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">Range</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equivalent to random (r.minVal,r.maxVal) </p>

</div>
</div>
<a id="a720d47364065e33e3c8c6806bf101492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720d47364065e33e3c8c6806bf101492">&#9670;&nbsp;</a></span>random() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double icl::utils::random </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates random numbers in range [0,1]. </p>

</div>
</div>
<a id="a92af36514c9aa380dc355d84bb1c522d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92af36514c9aa380dc355d84bb1c522d">&#9670;&nbsp;</a></span>random() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double icl::utils::random </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a random number in range [min,max]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>a float argument. The lower intervall bound </td></tr>
    <tr><td class="paramname">max</td><td>a float argument. The upper interval bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08cfb0421b98a59254648127952df060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cfb0421b98a59254648127952df060">&#9670;&nbsp;</a></span>random() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int icl::utils::random </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a non-negative random number in range [0,max]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The upper limit for the returned number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01ab68322f5454016e93a0046573225c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ab68322f5454016e93a0046573225c">&#9670;&nbsp;</a></span>randomSeed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icl::utils::randomSeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initilaize the random number generator (with <a class="el" href="classicl_1_1utils_1_1Time.html#a7a8c4c9f59e0edaa2bbced0e3d92f28b">Time::now()</a>.toMicroSeconds()). </p>

</div>
</div>
<a id="a9bfb87ed7d85b4890a959205f19ebc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfb87ed7d85b4890a959205f19ebc43">&#9670;&nbsp;</a></span>randomSeed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icl::utils::randomSeed </td>
          <td>(</td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>seedval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initilaize the random number generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seedval</td><td>The seed value (e.g. time(0) ...) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74fe536b27f8bb6d4943225c85a7d31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fe536b27f8bb6d4943225c85a7d31c">&#9670;&nbsp;</a></span>saveCall()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , void(T::*)() func&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void icl::utils::saveCall </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>static utility function which ensures Thread-safety for object functions </p>
<p>Internally this function template will create a specific mutex for the given class T and the given member function. When using the saveCall template to call an objects member-function from different threads, the function will automatically become Thread-save, as it is only executes once at one time. </p>

</div>
</div>
<a id="a1b491cddfe07995ee2d61b8204ba9f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b491cddfe07995ee2d61b8204ba9f61">&#9670;&nbsp;</a></span>saveDelete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void icl::utils::saveDelete </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>static utility function which deletes a pointer and sets it to NULL </p>
<p>Internally this function template will create a specific mutex for the given class T. All calls to the saveDelete function are protected by the static mutex. So saveDelete(XXX) can be called from different threads [but with the identical pointer reference] without the risk of segmentation violations or double free exceptions. </p>

</div>
</div>
<a id="a496808514e6e574c855804f0de857f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496808514e6e574c855804f0de857f43">&#9670;&nbsp;</a></span>skipWhitespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::skipWhitespaces </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>crops trailing whitespaces of a string </p>

</div>
</div>
<a id="a4702fc3afc839be28c693c54c12339da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4702fc3afc839be28c693c54c12339da">&#9670;&nbsp;</a></span>sqr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T icl::utils::sqr </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>square template (faster than pow(x,2) </p>

</div>
</div>
<a id="a44635de59c2c51ed966aa4345ade29b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44635de59c2c51ed966aa4345ade29b0">&#9670;&nbsp;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> bool icl::utils::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether a given string begins with a given prefix </p>

</div>
</div>
<a id="a626184c34b4c5bdaa6c2395b437aadc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626184c34b4c5bdaa6c2395b437aadc3">&#9670;&nbsp;</a></span>str() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icl::utils::str </td>
          <td>(</td>
          <td class="paramtype">char *const &amp;&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialized for char const pointers </p>

</div>
</div>
<a id="a52716cac258b218a847285facabc8e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52716cac258b218a847285facabc8e61">&#9670;&nbsp;</a></span>str() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icl::utils::str </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialized for bool </p>

</div>
</div>
<a id="a4d4a1b3013689097db6b0a6895770c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4a1b3013689097db6b0a6895770c3c">&#9670;&nbsp;</a></span>str() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icl::utils::str </td>
          <td>(</td>
          <td class="paramtype">const char *const &amp;&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialized for const char const pointers </p>

</div>
</div>
<a id="a7c9f30735a5e9e55553863ccfa18ade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9f30735a5e9e55553863ccfa18ade9">&#9670;&nbsp;</a></span>str() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icl::utils::str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialized for icl8u </p>

</div>
</div>
<a id="a70f426d9a3c02f382e3e26ad862d665f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f426d9a3c02f382e3e26ad862d665f">&#9670;&nbsp;</a></span>str() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icl::utils::str </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>specialized for std::string input (this is quiet silly) </p>

</div>
</div>
<a id="a2d5b026efe9b2f895c42bd124a2d3786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5b026efe9b2f895c42bd124a2d3786">&#9670;&nbsp;</a></span>str() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string icl::utils::str </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a data type into a string using an std::ostringstream instance </p>

</div>
</div>
<a id="a31e9b401f0f61d6a3454e5d44f737e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31e9b401f0f61d6a3454e5d44f737e15">&#9670;&nbsp;</a></span>strVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; icl::utils::strVec </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a vector of T's into a vector of strings </p>

</div>
</div>
<a id="a15ef89bd72737381461b9989fde3a6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ef89bd72737381461b9989fde3a6d9">&#9670;&nbsp;</a></span>time2str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::time2str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Time.html#accb09f29ecb73fc67cb7d5c3b548a193">Time::value_type</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts a <a class="el" href="classicl_1_1utils_1_1Time.html#accb09f29ecb73fc67cb7d5c3b548a193" title="internal data type (64Bit integer)">Time::value_type</a> (long int) into a string </p>

</div>
</div>
<a id="a7c07338ec802e96bc3a3217aae91cd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c07338ec802e96bc3a3217aae91cd3a">&#9670;&nbsp;</a></span>to16s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#a79af5b84ad2c6e4acf44ae0530d89269">icl16s</a> icl::utils::to16s </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast a string to an icl16s (parse) </p>

</div>
</div>
<a id="a61a2cd45fb2d0d6971a5faaf18299988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a2cd45fb2d0d6971a5faaf18299988">&#9670;&nbsp;</a></span>to32f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> icl::utils::to32f </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast a string to an icl32f (parse) </p>

</div>
</div>
<a id="ac6d5c6471b2c29e7988cd8987e68a4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d5c6471b2c29e7988cd8987e68a4d1">&#9670;&nbsp;</a></span>to32s()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> icl::utils::to32s </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast a string to an icl32ss (parse) </p>

</div>
</div>
<a id="ac70d2c79cd466261a34ef0ee6be2fafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70d2c79cd466261a34ef0ee6be2fafa">&#9670;&nbsp;</a></span>to64f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> icl::utils::to64f </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast a string to an icl64f (parse) </p>

</div>
</div>
<a id="ada12c5a77960b8adcbbfcf0e653020be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada12c5a77960b8adcbbfcf0e653020be">&#9670;&nbsp;</a></span>to8u()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a> icl::utils::to8u </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cast a string to an icl8u (parse) </p>

</div>
</div>
<a id="a4b71ded05def90d5b8941f203359503f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b71ded05def90d5b8941f203359503f">&#9670;&nbsp;</a></span>tok() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::vector&lt;std::string&gt;&amp; icl::utils::tok </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>singleCharDelims</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escapeChar</em> = <code>'\0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tokenize a string with given delimiters into a result vector (optimized) </p>

</div>
</div>
<a id="ad441f647a7e4f47e6789d5f5a382dceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad441f647a7e4f47e6789d5f5a382dceb">&#9670;&nbsp;</a></span>tok() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::vector&lt;std::string&gt; icl::utils::tok </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>singleCharDelims</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escapeChar</em> = <code>'\0'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tokenizes a string with given delimiters (internally using a temporary <a class="el" href="classicl_1_1utils_1_1StrTok.html" title="String Tokenizer Utility class.">StrTok</a> instance) </p>

</div>
</div>
<a id="a5654dd531ad1e22358e040c7a35fc71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5654dd531ad1e22358e040c7a35fc71e">&#9670;&nbsp;</a></span>toLower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::toLower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lower case conversion </p>

</div>
</div>
<a id="a068f9696659c2b957cb31151804ce01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068f9696659c2b957cb31151804ce01d">&#9670;&nbsp;</a></span>toLowerI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&amp; icl::utils::toLowerI </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inplace lower case conversion </p>

</div>
</div>
<a id="a81dde056ececa90ea99e20afe3431d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81dde056ececa90ea99e20afe3431d2a">&#9670;&nbsp;</a></span>toStr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::toStr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a string from given float using format string "%f" </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceicl_1_1utils.html#afc319551262ad0298d05a02a31d25f43" title="creates a string from a given double/float">toStr(double,const char*,char*)</a> </dd></dl>

</div>
</div>
<a id="afc319551262ad0298d05a02a31d25f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc319551262ad0298d05a02a31d25f43">&#9670;&nbsp;</a></span>toStr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::toStr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a string from a given double/float </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>to be converted double/float value </td></tr>
    <tr><td class="paramname">format</td><td>format string as ff or %3.5f </td></tr>
    <tr><td class="paramname">buf</td><td>optinal dest buffer (used if not NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ca6a4eddfcf75660ed5cd5df576face"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca6a4eddfcf75660ed5cd5df576face">&#9670;&nbsp;</a></span>toStr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::toStr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a string from given integer using format string "%d" </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceicl_1_1utils.html#a98d152706acbfda12282611b1ab04a81" title="creates a string from a given integer">toStr(int,const char*,char*)</a> </dd></dl>

</div>
</div>
<a id="a98d152706acbfda12282611b1ab04a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d152706acbfda12282611b1ab04a81">&#9670;&nbsp;</a></span>toStr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::toStr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a string from a given integer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>to be converted integer value </td></tr>
    <tr><td class="paramname">format</td><td>format string as d or %8d </td></tr>
    <tr><td class="paramname">buf</td><td>optinal dest buffer (used if not NULL) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53b6270b70846184ebde6c6b0f949b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b6270b70846184ebde6c6b0f949b99">&#9670;&nbsp;</a></span>toUpper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string icl::utils::toUpper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>upper case conversion </p>

</div>
</div>
<a id="af370594db3688b5d14c8ae9cf5125e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af370594db3688b5d14c8ae9cf5125e28">&#9670;&nbsp;</a></span>toUpperI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a0fa8579557bffc6e1e197889cf769e4f">ICLUtils_API</a> std::string&amp; icl::utils::toUpperI </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inplace upper case conversion </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceicl_1_1utils_html_ade3aca94cda923d51cae6dbc51384d52"><div class="ttname"><a href="namespaceicl_1_1utils.html#ade3aca94cda923d51cae6dbc51384d52">icl::utils::pa_init</a></div><div class="ttdeci">ICLUtils_API void pa_init(int n, char **ppc, const std::string &amp;init, bool allowDanglingArgs=false)</div><div class="ttdoc">initialization function for ICL's program argument evaluation framework</div></div>
<div class="ttc" id="aclassicl_1_1utils_1_1ProgArg_html_af2d70c0fa1d696fe7b11c2194ef58afd"><div class="ttname"><a href="classicl_1_1utils_1_1ProgArg.html#af2d70c0fa1d696fe7b11c2194ef58afd">icl::utils::ProgArg::n</a></div><div class="ttdeci">ICLUtils_API int n() const</div><div class="ttdoc">returns the count of actually given sub arguments</div></div>
<div class="ttc" id="anamespaceicl_1_1utils_html_a9d10d5cbc5c151413efea2bf9cd4abaf"><div class="ttname"><a href="namespaceicl_1_1utils.html#a9d10d5cbc5c151413efea2bf9cd4abaf">icl::utils::pa_get_count</a></div><div class="ttdeci">ICLUtils_API unsigned int pa_get_count(bool danglingOnly=true)</div><div class="ttdoc">returns number of actually given args given</div></div>
<div class="ttc" id="anamespaceicl_1_1utils_html_ac1c1a1e771ecc0681b8f277040cc2c99"><div class="ttname"><a href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">icl::utils::pa</a></div><div class="ttdeci">const ProgArg pa(const std::string &amp;id, unsigned int subargidx=0)</div><div class="ttdoc">returns given program argument</div><div class="ttdef"><b>Definition:</b> ProgArg.h:360</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 14:54:54 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
