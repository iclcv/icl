<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::cv::PositionTracker&lt; valueType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1cv.html">cv</a></li><li class="navelem"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html">PositionTracker</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classicl_1_1cv_1_1PositionTracker-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icl::cv::PositionTracker&lt; valueType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for tracking 2D positions.  
 <a href="classicl_1_1cv_1_1PositionTracker.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="PositionTracker_8h_source.html">PositionTracker.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a75180d3d364a1f736cc9adadd9232909"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a75180d3d364a1f736cc9adadd9232909">PositionTracker</a> ()</td></tr>
<tr class="memdesc:a75180d3d364a1f736cc9adadd9232909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty default constructor without any optimization.  <a href="classicl_1_1cv_1_1PositionTracker.html#a75180d3d364a1f736cc9adadd9232909">More...</a><br /></td></tr>
<tr class="separator:a75180d3d364a1f736cc9adadd9232909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c43e1fab3d6552e88efe891c366d1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#aa2c43e1fab3d6552e88efe891c366d1c">PositionTracker</a> (valueType threshold)</td></tr>
<tr class="memdesc:aa2c43e1fab3d6552e88efe891c366d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>NEW</em> constructor with optimization enabled and given theshold  <a href="classicl_1_1cv_1_1PositionTracker.html#aa2c43e1fab3d6552e88efe891c366d1c">More...</a><br /></td></tr>
<tr class="separator:aa2c43e1fab3d6552e88efe891c366d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472df76ed52ff93f2da6999c41df54bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a472df76ed52ff93f2da6999c41df54bf">pushData</a> (valueType *xys, int n)</td></tr>
<tr class="memdesc:a472df76ed52ff93f2da6999c41df54bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">most common function, adds a new data row, and causes all internal computation (see above)  <a href="classicl_1_1cv_1_1PositionTracker.html#a472df76ed52ff93f2da6999c41df54bf">More...</a><br /></td></tr>
<tr class="separator:a472df76ed52ff93f2da6999c41df54bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2fd846d0b6956ea23d68cad7dec463"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a7a2fd846d0b6956ea23d68cad7dec463">pushData</a> (const std::vector&lt; valueType &gt; &amp;xs, const std::vector&lt; valueType &gt; &amp;ys)</td></tr>
<tr class="memdesc:a7a2fd846d0b6956ea23d68cad7dec463"><td class="mdescLeft">&#160;</td><td class="mdescRight">as above  <a href="classicl_1_1cv_1_1PositionTracker.html#a7a2fd846d0b6956ea23d68cad7dec463">More...</a><br /></td></tr>
<tr class="separator:a7a2fd846d0b6956ea23d68cad7dec463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0028918c45f425abbc389b907eb52b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ab0028918c45f425abbc389b907eb52b6">pushData</a> (const std::vector&lt; <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> &gt; points)</td></tr>
<tr class="memdesc:ab0028918c45f425abbc389b907eb52b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">as above  <a href="classicl_1_1cv_1_1PositionTracker.html#ab0028918c45f425abbc389b907eb52b6">More...</a><br /></td></tr>
<tr class="separator:ab0028918c45f425abbc389b907eb52b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1668955d889b0d8a6d09945f8c2455c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a1668955d889b0d8a6d09945f8c2455c2">setIDAllocationMode</a> (<a class="el" href="namespaceicl_1_1cv.html#a58db0e68e6fc8a54a602eb4d51ac8391">IDAllocationMode</a> mode)</td></tr>
<tr class="separator:a1668955d889b0d8a6d09945f8c2455c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961d91741e3923e6a36908168621a09d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a961d91741e3923e6a36908168621a09d">getID</a> (valueType x, valueType y)</td></tr>
<tr class="memdesc:a961d91741e3923e6a36908168621a09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the unique id of a just pushe data point (x,y)  <a href="classicl_1_1cv_1_1PositionTracker.html#a961d91741e3923e6a36908168621a09d">More...</a><br /></td></tr>
<tr class="separator:a961d91741e3923e6a36908168621a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f13468c29f51d4d3af2b7495d6ef97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a73f13468c29f51d4d3af2b7495d6ef97">getID</a> (int index)</td></tr>
<tr class="memdesc:a73f13468c29f51d4d3af2b7495d6ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the unique id of just pushed data point with given index  <a href="classicl_1_1cv_1_1PositionTracker.html#a73f13468c29f51d4d3af2b7495d6ef97">More...</a><br /></td></tr>
<tr class="separator:a73f13468c29f51d4d3af2b7495d6ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad0000753d86b3ba73db66c20da12b49c"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; valueType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ad0000753d86b3ba73db66c20da12b49c">Vec</a></td></tr>
<tr class="memdesc:ad0000753d86b3ba73db66c20da12b49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally used vector type  <a href="classicl_1_1cv_1_1PositionTracker.html#ad0000753d86b3ba73db66c20da12b49c">More...</a><br /></td></tr>
<tr class="separator:ad0000753d86b3ba73db66c20da12b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad286bfc213c4e9eab3ce50c92b6ea65b"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ad0000753d86b3ba73db66c20da12b49c">Vec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ad286bfc213c4e9eab3ce50c92b6ea65b">Mat</a></td></tr>
<tr class="memdesc:ad286bfc213c4e9eab3ce50c92b6ea65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally used matrix type  <a href="classicl_1_1cv_1_1PositionTracker.html#ad286bfc213c4e9eab3ce50c92b6ea65b">More...</a><br /></td></tr>
<tr class="separator:ad286bfc213c4e9eab3ce50c92b6ea65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded108c30069f5a5eb9007d2fedcb5ba"><td class="memItemLeft" align="right" valign="top">typedef std::deque&lt; <a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ad0000753d86b3ba73db66c20da12b49c">Vec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#aded108c30069f5a5eb9007d2fedcb5ba">QMat</a></td></tr>
<tr class="memdesc:aded108c30069f5a5eb9007d2fedcb5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally used queue-matrix (columns can be pushed and pop'ed in constant time  <a href="classicl_1_1cv_1_1PositionTracker.html#aded108c30069f5a5eb9007d2fedcb5ba">More...</a><br /></td></tr>
<tr class="separator:aded108c30069f5a5eb9007d2fedcb5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac98994350f151db5fd9bdeb62a158545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#aded108c30069f5a5eb9007d2fedcb5ba">QMat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ac98994350f151db5fd9bdeb62a158545">m_matData</a> [2]</td></tr>
<tr class="memdesc:ac98994350f151db5fd9bdeb62a158545"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal storage of the history matrix H  <a href="classicl_1_1cv_1_1PositionTracker.html#ac98994350f151db5fd9bdeb62a158545">More...</a><br /></td></tr>
<tr class="separator:ac98994350f151db5fd9bdeb62a158545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ad6a4cc77cb2feb983be16768d261d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ab8ad6a4cc77cb2feb983be16768d261d">m_vecCurrentAssignment</a></td></tr>
<tr class="memdesc:ab8ad6a4cc77cb2feb983be16768d261d"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal storage of the last calculated assignment  <a href="classicl_1_1cv_1_1PositionTracker.html#ab8ad6a4cc77cb2feb983be16768d261d">More...</a><br /></td></tr>
<tr class="separator:ab8ad6a4cc77cb2feb983be16768d261d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8361c6b9437ca9d4f24517ff57734d15"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a8361c6b9437ca9d4f24517ff57734d15">m_vecIDs</a></td></tr>
<tr class="memdesc:a8361c6b9437ca9d4f24517ff57734d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal storage of the unique ids I  <a href="classicl_1_1cv_1_1PositionTracker.html#a8361c6b9437ca9d4f24517ff57734d15">More...</a><br /></td></tr>
<tr class="separator:a8361c6b9437ca9d4f24517ff57734d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca62ec1d6f751135fb08e3910583144f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#aca62ec1d6f751135fb08e3910583144f">m_vecGoodDataCount</a></td></tr>
<tr class="memdesc:aca62ec1d6f751135fb08e3910583144f"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal storage for the good data count G  <a href="classicl_1_1cv_1_1PositionTracker.html#aca62ec1d6f751135fb08e3910583144f">More...</a><br /></td></tr>
<tr class="separator:aca62ec1d6f751135fb08e3910583144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209643a55cc7e7d9bfd3bb86a0ed9223"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a209643a55cc7e7d9bfd3bb86a0ed9223">m_bTryOptimize</a></td></tr>
<tr class="memdesc:a209643a55cc7e7d9bfd3bb86a0ed9223"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate whether to try optimization (trivial assignment)  <a href="classicl_1_1cv_1_1PositionTracker.html#a209643a55cc7e7d9bfd3bb86a0ed9223">More...</a><br /></td></tr>
<tr class="separator:a209643a55cc7e7d9bfd3bb86a0ed9223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad650c93d21db1ee25b8ebbf0ae7394"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a4ad650c93d21db1ee25b8ebbf0ae7394">m_currentID</a></td></tr>
<tr class="memdesc:a4ad650c93d21db1ee25b8ebbf0ae7394"><td class="mdescLeft">&#160;</td><td class="mdescRight">first unused ID  <a href="classicl_1_1cv_1_1PositionTracker.html#a4ad650c93d21db1ee25b8ebbf0ae7394">More...</a><br /></td></tr>
<tr class="separator:a4ad650c93d21db1ee25b8ebbf0ae7394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428de79180d9fe34dbf34d8a481cb03d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceicl_1_1cv.html#a58db0e68e6fc8a54a602eb4d51ac8391">IDAllocationMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a428de79180d9fe34dbf34d8a481cb03d">m_IDAllocationMode</a></td></tr>
<tr class="memdesc:a428de79180d9fe34dbf34d8a481cb03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate which type of ID allocation should be used  <a href="classicl_1_1cv_1_1PositionTracker.html#a428de79180d9fe34dbf34d8a481cb03d">More...</a><br /></td></tr>
<tr class="separator:a428de79180d9fe34dbf34d8a481cb03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1399bf20f5feedcce9b9a487412cf16"><td class="memItemLeft" align="right" valign="top">valueType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#aa1399bf20f5feedcce9b9a487412cf16">m_tThreshold</a></td></tr>
<tr class="memdesc:aa1399bf20f5feedcce9b9a487412cf16"><td class="mdescLeft">&#160;</td><td class="mdescRight">threshold distance  <a href="classicl_1_1cv_1_1PositionTracker.html#aa1399bf20f5feedcce9b9a487412cf16">More...</a><br /></td></tr>
<tr class="separator:aa1399bf20f5feedcce9b9a487412cf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class valueType&gt;<br />
class icl::cv::PositionTracker&lt; valueType &gt;</h3>

<p>Class for tracking 2D positions. </p>
<h1><a class="anchor" id="INTRO"></a>
Introduction</h1>
<p>The <a class="el" href="classicl_1_1cv_1_1PositionTracker.html" title="Class for tracking 2D positions.">PositionTracker</a> class provides functionalities for tracking 2D data points. Consider the output of a standard blob-detection algorithm: A list of 2D Positions of all found blobs. In a special case these positions are not labeled, e.g. because the used blob-detection-algorithm does not provide any kind of "tracking-mechanism" that pursues each single blob from one time step to the next. But although having only a list of firstly unassociated "2DPositions-snapshots", it is possible to track each blob very efficiently by proceeding form the assumption of slow or continously moving blobs. A simple brute-force approach would assign a blob at time t to the closest blob at time t-1. If the tracked blobs will move slow, and there is a margin between each blob that is <em>large enough</em>, this approach would give us good results at a complexity of O( <img class="formulaInl" alt="$n^2$" src="form_176.png"/>). But what happens if one of the assumptions was false? The answer is, that the algorithm will calculate false assignments (E.g. if a blob moves fast enough, to be closer to another blob at at time t-1, the blobs IDs may be swapped).<br  />
In addition to this, two cases must be tackled in a special way: What if some existing blobs are lost by the blob detector? And what if new blobs are found, that have no corresponding blob at time t-1?</p>
<h1><a class="anchor" id="ALGO"></a>
The Segmentation Algorithm</h1>
<p>The first adaption is quite obvious: Instead of expecting a blobs position at time t at its position at time t-1, we can predict its position regarding its history (positions at time t-1, t-2, ...). This will allow the blobs to move or accelerate (<b>but note:</b> an extrapolation of the blobs position at time t implies an implicit model-assumption, which is e.g. a quadratic one in case of regarding up to 3 former positions for each blob).<br  />
Another problem, not mentioned above, is the special case that at time t a single blob (or its extrapolated position for time t) is the nearest of more than one blob at time t-1. In this case, we have to decide which blob is assigned to the nearest, and we have to search another good match for the other one. This problem can be made arbitrary sophisticated, by factoring in further questions like "What if the next good match is already assigned to
third blob". So what we need is a general approach to minimize a kind of <em>costs</em> by assigning blobs at time t-1 (or their prediction for time t) to blobs at time t, which leads to the so called (well known) problem-class of the <b>Linear Assignment Problems</b>.<br  />
 </p>
<h1><a class="anchor" id="LAP"></a>
Linear Assignment Problems</h1>
<p>The "Assignment Problem class" is defined as follows: "There are a number of agents and a number of tasks. Any agent can be assigned to perform any task, incurring some cost that may vary depending on the agent-task assignment. It is required to perform all tasks by assigning exactly one agent to each task in such a way that the total cost of the assignment is minimized" (Wikipedia, <a href="http://en.wikipedia.org/wiki/Assignment_problem">http://en.wikipedia.org/wiki/Assignment_problem</a>).<br  />
An additional restriction leads to the class of <b>Linear</b> Assignment Problems: "If the numbers of agents and tasks are equal and the total cost of the assignment for all tasks is equal to the sum of the costs for each agent (or the sum of the costs for each task, which is the same thing in this case), then the problem is called the Linear assignment problem. Commonly, when speaking of the Assignment problem without any additional qualification, then the Linear assignment problem is meant"(Wikipedia).<br  />
 </p>
<h1><a class="anchor" id="HA"></a>
The "Hungarian Algorithm" for solving linear assignment Problems</h1>
<p>Linear assignment problems can be solved using the Hungarian Algorithm with a complexity of O( <img class="formulaInl" alt="$n^3$" src="form_177.png"/>), where n is the number of tasks as well as the number of agents. The Hungarian Algorithm is well analyzed and should not be described further here. More information is available e.g. at <a href="http://en.wikipedia.org/wiki/Hungarian_algorithm">http://en.wikipedia.org/wiki/Hungarian_algorithm</a>.<br  />
We finish this section retaining that the Hungarian Algorithm gets a NxN cost matrix C, where C(i,j) are the costs arising if blob i at t is assigned to blob j at time t-1 (or its pred.;s.o.), and it returns the N-dimensional assignment vector a, with a(i)=index of blob at time t-1 that is assigned to current blob i.</p>
<h1><a class="anchor" id="PROB"></a>
Problems</h1>
<p>As mentioned in sec. <a class="el" href="classicl_1_1cv_1_1PositionTracker.html#INTRO">Introduction</a>, we are confronted with additional compounding problems:</p><ul>
<li>New Blobs are detected, that did not exist before</li>
<li>Blobs that still existed at time t-1 are lost at time t</li>
</ul>
<p>To make use of the Hungarian Algorithm as described in sec. <a class="el" href="classicl_1_1cv_1_1PositionTracker.html#HA">The "Hungarian Algorithm" for solving linear assignment Problems</a>, we need a quadratic cost matrix, which can be emulated by inserting so called <em>blind values</em>. This values should be as different as possible from all other blob positions (e.g. MAX_INT). If blobs are lost since time t-1, we can fill up the vector of new blob positions with blind values, which has the result, that these indices are assigned to exactly these old blobs, that match worst to any new blob. In the other case, where more blobs have been found at time t as recorded at time t-1, we can fill up the vector that contains the predictions for the blobs at time t with blind values. This makes the Hungarian Algorithm assigning only <em>brand new</em> blobs to these blind ones.</p>
<h1><a class="anchor" id="DM"></a>
PositionTracker Data-Management</h1>
<p>The following ASCII illustration shows a sketch of the internally hold data: </p><pre>
data matrix scheme: | . . . . N |      (the "."-elements do not exist)
                    | I G H P D |</pre><pre>where H is the history matrix:     H = [ x(t-3) x(t-2) x(t-1) ]  and the x(T) are column vectors
                                                                 of all blob positions at time
                                                                 T, and each row r of H contains
                                                                 the history values of one blob.</pre><pre>P is the prediction vector for time t     and P(r) is the prediction result of the r-th row of the
                                          History matrix H</pre><pre>N is the vector of new data positions</pre><pre>D is the cost matrix                      where D(c,r) is the square root of the
                                          euclidian distance of P(r) and N(c)
                                          We have to use the square root and not the euclidian
                                          distnace itself, to avoid that new blobs are
                                          are mixed up with old ones (...)</pre><pre>G is the so called "good count matrix"    where G(r) is the number of valid history steps is the
                                          r-th row of H</pre><pre>I is the ID vector                        where I(r) hold a unique blob ID associated with the
                                          blob thats history complies the r-th row of H</pre><pre>detailed scheme:
                                    new data (N)
                              | o   o  x(t)  o   o
    --------------------------+-----------------------
       o      o     o      o  | d   d   d    d   d
                              |
       o      o     o      o  | d   ...
                              |
    x(t-3) x(t-2) x(t-1) x~(t)|     distances
                              |         (D)
       o      o     o      o  |
                              |
       o      o     o      o  |
                           .  |
           History        / \ |
             (H)           |
                       Prediction
                          (P)
</pre><h1><a class="anchor" id="ALGO"></a>
The Segmentation Algorithm</h1>
<p>All the work is done by calling the pushData function of a <a class="el" href="classicl_1_1cv_1_1PositionTracker.html" title="Class for tracking 2D positions.">PositionTracker</a> object. During the fist call the algorithm does not need to solve any assignment problem, so the H(t-1) is set to the new data vector N, the ID-vector is initialized with unique IDs at each position G(i)=i and the good count vector G is set up with 1 at each position.<br  />
Now a call to pushData can be described using the following pseudo code: </p><pre>
void pushData( vector newData){
  DIFF = currentDataCount - newData.dim()
  if(DIFF &lt;  0){
      push_data_diff_lower_then_zero(...)
  }else if(DIFF &gt; 0){
      push_data_diff_greater_then_zero(...)
  }else{
    push_data_diff_equal_zero(...)
  }
}</pre><pre>push_data_diff_lower_then_zero(...){
   &gt; add DIFF blind values to H(t-1)
   &gt; add DIFF ones to G
   &gt; calculate prediction vector P
   &gt; remove DIFF ones from G
   &gt; calculate the distance matrix D
   &gt; apply the Hungarian algorithm with resulting assignment vector a
   &gt; create a vector v_tmp containing only the new data points, that have been assigned to blind values
   &gt; assign the DIFF last rows of H (which were set to blind value) to this new values in
   &gt; give each of these rows a brand new id in I
   &gt; assign the good count vector at these rows to 1, increment all other good counts by one
   &gt; rearrange the new data using the assignment a
   &gt; push the rearranged new data to H from right, and pop the left-most column of H
}</pre><pre>push_data_diff_greater_then_zero(...){
   &gt; add DIFF blind values to the new data vector
   &gt; calculate prediction vector P
   &gt; calculate the distance matrix D
   &gt; apply the Hungarian algorithm with resulting assignment vector a
   &gt; rearrange the new data using the assignment a
   &gt; push the rearranged new data to H from right, and pop the left-most column of H
   &gt; create a vector v_del containing all rows, that have been assigned to blind values
   &gt; use v_del to remove no longer used rows form H, I and G
   &gt; increment all remaining elements of G
}</pre><pre>push_data_diff_equal_zero(...){
   &gt; calculate prediction vector P
   &gt; calculate the distance matrix D
   &gt; apply the Hungarian algorithm with resulting assignment vector a
   &gt; rearrange the new data using the assignment a
   &gt; increment all elements of G
}
</pre><h1><a class="anchor" id="PERFORMANCE"></a>
Performance</h1>
<p>The Hungarian algorithm has a worst case complexity of O( <img class="formulaInl" alt="$n^3$" src="form_177.png"/>), which gives the algorithm a poor performance when the Blob count is about 100 or more. The <img class="formulaInl" alt="$n^3$" src="form_177.png"/> grows very fast: 20 Blobs can be tracked in about one milli second, 200 Blobs already need about 200ms. The following two diagrams illustrate the performance: </p><div class="image">
<img src="bench1.jpg" alt="" width="4cm"/>
<div class="caption">
Performance for 2-20 Blobs</div></div>
 <div class="image">
<img src="bench2.jpg" alt="" width="4cm"/>
<div class="caption">
Performance for 0-500 Blobs (the green line is show an O(n^2) approximation, the red on is O(n^3)</div></div>
<pre class="fragment">\section OPT_ Optimization
If the optimized flag and a valid threshold is given to the constructor, the pushData function is implemented as follows:
Because in real applications, there are many successive time steps, where pushData gets the nearly equal data, pushData
trys to associate old and new data with a trivial min-distance matching: If the data dimension has not changed, for each
old data item (without extrapolation), the nearest new data item is chosen. If no conflicts arise (one old center is the
nearest to more then one new center and if all minimum distances are below the given threshold, this trivial assignment is
used. Otherwise the default algorithm is applied, and the optimization has no effect. &lt;b&gt;Note:&lt;/b&gt; If the given threshold
is smaller or equal to zero or the data dimension changes from on push call to another, no optimization is performed.
</pre> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad286bfc213c4e9eab3ce50c92b6ea65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad286bfc213c4e9eab3ce50c92b6ea65b">&#9670;&nbsp;</a></span>Mat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ad0000753d86b3ba73db66c20da12b49c">Vec</a>&gt; <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::<a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ad286bfc213c4e9eab3ce50c92b6ea65b">Mat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internally used matrix type </p>

</div>
</div>
<a id="aded108c30069f5a5eb9007d2fedcb5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded108c30069f5a5eb9007d2fedcb5ba">&#9670;&nbsp;</a></span>QMat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::deque&lt;<a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ad0000753d86b3ba73db66c20da12b49c">Vec</a>&gt; <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::<a class="el" href="classicl_1_1cv_1_1PositionTracker.html#aded108c30069f5a5eb9007d2fedcb5ba">QMat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internally used queue-matrix (columns can be pushed and pop'ed in constant time </p>

</div>
</div>
<a id="ad0000753d86b3ba73db66c20da12b49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0000753d86b3ba73db66c20da12b49c">&#9670;&nbsp;</a></span>Vec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;valueType&gt; <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::<a class="el" href="classicl_1_1cv_1_1PositionTracker.html#ad0000753d86b3ba73db66c20da12b49c">Vec</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internally used vector type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a75180d3d364a1f736cc9adadd9232909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75180d3d364a1f736cc9adadd9232909">&#9670;&nbsp;</a></span>PositionTracker() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::<a class="el" href="classicl_1_1cv_1_1PositionTracker.html">PositionTracker</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty default constructor without any optimization. </p>

</div>
</div>
<a id="aa2c43e1fab3d6552e88efe891c366d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c43e1fab3d6552e88efe891c366d1c">&#9670;&nbsp;</a></span>PositionTracker() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::<a class="el" href="classicl_1_1cv_1_1PositionTracker.html">PositionTracker</a> </td>
          <td>(</td>
          <td class="paramtype">valueType&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>NEW</em> constructor with optimization enabled and given theshold </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>threshold for optimization (must be &gt; 0) OPT_ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a73f13468c29f51d4d3af2b7495d6ef97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f13468c29f51d4d3af2b7495d6ef97">&#9670;&nbsp;</a></span>getID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::getID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the unique id of just pushed data point with given index </p>

</div>
</div>
<a id="a961d91741e3923e6a36908168621a09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961d91741e3923e6a36908168621a09d">&#9670;&nbsp;</a></span>getID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::getID </td>
          <td>(</td>
          <td class="paramtype">valueType&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">valueType&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the unique id of a just pushe data point (x,y) </p>
<p>A problem occurs, if more than on point with coordinates (x,y) was pushed, in this case, this function will return the first found one. To avoid this, the next function (<a class="el" href="classicl_1_1cv_1_1PositionTracker.html#a73f13468c29f51d4d3af2b7495d6ef97" title="returns the unique id of just pushed data point with given index">getID(int index)</a>) can be used to specify the datapoint by its index </p>

</div>
</div>
<a id="ab0028918c45f425abbc389b907eb52b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0028918c45f425abbc389b907eb52b6">&#9670;&nbsp;</a></span>pushData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::pushData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classicl_1_1utils_1_1Point32f.html">utils::Point32f</a> &gt;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>as above </p>

</div>
</div>
<a id="a7a2fd846d0b6956ea23d68cad7dec463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2fd846d0b6956ea23d68cad7dec463">&#9670;&nbsp;</a></span>pushData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::pushData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; valueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; valueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>ys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>as above </p>

</div>
</div>
<a id="a472df76ed52ff93f2da6999c41df54bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472df76ed52ff93f2da6999c41df54bf">&#9670;&nbsp;</a></span>pushData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::pushData </td>
          <td>(</td>
          <td class="paramtype">valueType *&#160;</td>
          <td class="paramname"><em>xys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>most common function, adds a new data row, and causes all internal computation (see above) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xys</td><td>data vector with xyxy.. data order </td></tr>
    <tr><td class="paramname">n</td><td>count of xy-pairs in xys (xys.length/2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1668955d889b0d8a6d09945f8c2455c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1668955d889b0d8a6d09945f8c2455c2">&#9670;&nbsp;</a></span>setIDAllocationMode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::setIDAllocationMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceicl_1_1cv.html#a58db0e68e6fc8a54a602eb4d51ac8391">IDAllocationMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Switch between continuous and restocking ID allocation. Restocking means, that a new object will get the smallest avialable ID (formerly used by an older object which is no longer existing), instead of a brand new. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>on if true IDs will we be allocated continuously </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a209643a55cc7e7d9bfd3bb86a0ed9223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a209643a55cc7e7d9bfd3bb86a0ed9223">&#9670;&nbsp;</a></span>m_bTryOptimize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::m_bTryOptimize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>flag to indicate whether to try optimization (trivial assignment) </p>

</div>
</div>
<a id="a4ad650c93d21db1ee25b8ebbf0ae7394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad650c93d21db1ee25b8ebbf0ae7394">&#9670;&nbsp;</a></span>m_currentID</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::m_currentID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>first unused ID </p>

</div>
</div>
<a id="a428de79180d9fe34dbf34d8a481cb03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428de79180d9fe34dbf34d8a481cb03d">&#9670;&nbsp;</a></span>m_IDAllocationMode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceicl_1_1cv.html#a58db0e68e6fc8a54a602eb4d51ac8391">IDAllocationMode</a> <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::m_IDAllocationMode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>flag to indicate which type of ID allocation should be used </p>

</div>
</div>
<a id="ac98994350f151db5fd9bdeb62a158545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98994350f151db5fd9bdeb62a158545">&#9670;&nbsp;</a></span>m_matData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1cv_1_1PositionTracker.html#aded108c30069f5a5eb9007d2fedcb5ba">QMat</a> <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::m_matData[2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal storage of the history matrix H </p>

</div>
</div>
<a id="aa1399bf20f5feedcce9b9a487412cf16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1399bf20f5feedcce9b9a487412cf16">&#9670;&nbsp;</a></span>m_tThreshold</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">valueType <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::m_tThreshold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>threshold distance </p>

</div>
</div>
<a id="ab8ad6a4cc77cb2feb983be16768d261d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ad6a4cc77cb2feb983be16768d261d">&#9670;&nbsp;</a></span>m_vecCurrentAssignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::m_vecCurrentAssignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal storage of the last calculated assignment </p>

</div>
</div>
<a id="aca62ec1d6f751135fb08e3910583144f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca62ec1d6f751135fb08e3910583144f">&#9670;&nbsp;</a></span>m_vecGoodDataCount</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::m_vecGoodDataCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal storage for the good data count G </p>

</div>
</div>
<a id="a8361c6b9437ca9d4f24517ff57734d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8361c6b9437ca9d4f24517ff57734d15">&#9670;&nbsp;</a></span>m_vecIDs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class valueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="classicl_1_1cv_1_1PositionTracker.html">icl::cv::PositionTracker</a>&lt; valueType &gt;::m_vecIDs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal storage of the unique ids I </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/icl/icl/ICLCV/src/ICLCV/<a class="el" href="PositionTracker_8h_source.html">PositionTracker.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 14:54:51 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
