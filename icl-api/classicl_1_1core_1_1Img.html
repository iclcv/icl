<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::core::Img&lt; Type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classicl_1_1core_1_1Img-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icl::core::Img&lt; Type &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__IMAGE.html">Image Classes and Support Functions</a> &#124; <a class="el" href="group__TYPES.html">Common Data Type Definitions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> class implements the <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> Image interface with type specific functionalities.  
 <a href="classicl_1_1core_1_1Img.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Img_8h_source.html">Img.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for icl::core::Img&lt; Type &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classicl_1_1core_1_1Img.png" usemap="#icl::core::Img_3C_20Type_20_3E_map" alt=""/>
  <map id="icl::core::Img_3C_20Type_20_3E_map" name="icl::core::Img_3C_20Type_20_3E_map">
<area href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template." alt="icl::core::ImgBase" shape="rect" coords="0,0,253,24"/>
<area href="classicl_1_1utils_1_1UncopiedInstance.html" alt="icl::utils::UncopiedInstance&lt; icl::core::Img &gt;" shape="rect" coords="0,112,253,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa750aab12ce5265c4a6ca7e85600ccf5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aa750aab12ce5265c4a6ca7e85600ccf5">Img</a> (const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;params=<a class="el" href="classicl_1_1core_1_1ImgParams.html#a678ccf92d76d27b2acbcd1a5f3c507d3">ImgParams::null</a>)</td></tr>
<tr class="memdesc:aa750aab12ce5265c4a6ca7e85600ccf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new image specified by the given param struct  <a href="classicl_1_1core_1_1Img.html#aa750aab12ce5265c4a6ca7e85600ccf5">More...</a><br /></td></tr>
<tr class="separator:aa750aab12ce5265c4a6ca7e85600ccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96170b9ea9b657ecaef9d8cf15c2cd4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a96170b9ea9b657ecaef9d8cf15c2cd4f">Img</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels)</td></tr>
<tr class="memdesc:a96170b9ea9b657ecaef9d8cf15c2cd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an image with specified number of channels and size.  <a href="classicl_1_1core_1_1Img.html#a96170b9ea9b657ecaef9d8cf15c2cd4f">More...</a><br /></td></tr>
<tr class="separator:a96170b9ea9b657ecaef9d8cf15c2cd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dc515d11e89a9158c07304682c7fc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a98dc515d11e89a9158c07304682c7fc6">Img</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;s, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt)</td></tr>
<tr class="memdesc:a98dc515d11e89a9158c07304682c7fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an image with specified size, number of channels and format.  <a href="classicl_1_1core_1_1Img.html#a98dc515d11e89a9158c07304682c7fc6">More...</a><br /></td></tr>
<tr class="separator:a98dc515d11e89a9158c07304682c7fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8555de81ecc2a533e849b78880bfe6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a3e8555de81ecc2a533e849b78880bfe6">Img</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;s, int channels, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt)</td></tr>
<tr class="memdesc:a3e8555de81ecc2a533e849b78880bfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crates an image with given size, channel count and format.  <a href="classicl_1_1core_1_1Img.html#a3e8555de81ecc2a533e849b78880bfe6">More...</a><br /></td></tr>
<tr class="separator:a3e8555de81ecc2a533e849b78880bfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e56a84236b5db1edbf81f6bf57fb221"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a2e56a84236b5db1edbf81f6bf57fb221">Img</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>, const std::vector&lt; Type * &gt; &amp;vptData, bool passOwnerShip=false)</td></tr>
<tr class="memdesc:a2e56a84236b5db1edbf81f6bf57fb221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an image with specified size and format, using shared data pointers as channel data.  <a href="classicl_1_1core_1_1Img.html#a2e56a84236b5db1edbf81f6bf57fb221">More...</a><br /></td></tr>
<tr class="separator:a2e56a84236b5db1edbf81f6bf57fb221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced05e61ac3cf24974733efd34c974de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aced05e61ac3cf24974733efd34c974de">Img</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels, const std::vector&lt; Type * &gt; &amp;vptData, bool passOwnerShip=false)</td></tr>
<tr class="memdesc:aced05e61ac3cf24974733efd34c974de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an image with specified size and channel count, using shared data pointers as channel data.  <a href="classicl_1_1core_1_1Img.html#aced05e61ac3cf24974733efd34c974de">More...</a><br /></td></tr>
<tr class="separator:aced05e61ac3cf24974733efd34c974de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f50fc796f62c647b0419230b996b9e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a4f50fc796f62c647b0419230b996b9e2">Img</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, const std::vector&lt; Type * &gt; &amp;vptData, bool passOwnerShip=false)</td></tr>
<tr class="memdesc:a4f50fc796f62c647b0419230b996b9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crates an image with given size, channel count and format.  <a href="classicl_1_1core_1_1Img.html#a4f50fc796f62c647b0419230b996b9e2">More...</a><br /></td></tr>
<tr class="separator:a4f50fc796f62c647b0419230b996b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc03ba1b1aa5c74d3b1f70841425e6c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#abc03ba1b1aa5c74d3b1f70841425e6c4">Img</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;tSrc)</td></tr>
<tr class="memdesc:abc03ba1b1aa5c74d3b1f70841425e6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor WARNING: Violates const concept.  <a href="classicl_1_1core_1_1Img.html#abc03ba1b1aa5c74d3b1f70841425e6c4">More...</a><br /></td></tr>
<tr class="separator:abc03ba1b1aa5c74d3b1f70841425e6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7b76258e5bf542ea120c3b9366a48f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a0d7b76258e5bf542ea120c3b9366a48f">Img</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;c1, const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;c2=<a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt;(), const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;c3=<a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt;(), const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;c4=<a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt;(), const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;c5=<a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt;())</td></tr>
<tr class="memdesc:a0d7b76258e5bf542ea120c3b9366a48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor provides tight integration with DynMatrix template class.  <a href="classicl_1_1core_1_1Img.html#a0d7b76258e5bf542ea120c3b9366a48f">More...</a><br /></td></tr>
<tr class="separator:a0d7b76258e5bf542ea120c3b9366a48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e233b4cd972da0500f05600bb1dd32b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a9e233b4cd972da0500f05600bb1dd32b">~Img</a> ()</td></tr>
<tr class="memdesc:a9e233b4cd972da0500f05600bb1dd32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classicl_1_1core_1_1Img.html#a9e233b4cd972da0500f05600bb1dd32b">More...</a><br /></td></tr>
<tr class="separator:a9e233b4cd972da0500f05600bb1dd32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8882a9fd1055c02fbb217a99a2dab5c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a8882a9fd1055c02fbb217a99a2dab5c7">isNull</a> () const</td></tr>
<tr class="memdesc:a8882a9fd1055c02fbb217a99a2dab5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">null check : null images have 0-Channels and null-size  <a href="classicl_1_1core_1_1Img.html#a8882a9fd1055c02fbb217a99a2dab5c7">More...</a><br /></td></tr>
<tr class="separator:a8882a9fd1055c02fbb217a99a2dab5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classicl_1_1core_1_1ImgBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classicl_1_1core_1_1ImgBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classicl_1_1core_1_1ImgBase.html">icl::core::ImgBase</a></td></tr>
<tr class="memitem:a5ee6de6a8e67b9b7747e399a4eca855a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a5ee6de6a8e67b9b7747e399a4eca855a">~ImgBase</a> ()</td></tr>
<tr class="memdesc:a5ee6de6a8e67b9b7747e399a4eca855a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classicl_1_1core_1_1ImgBase.html#a5ee6de6a8e67b9b7747e399a4eca855a">More...</a><br /></td></tr>
<tr class="separator:a5ee6de6a8e67b9b7747e399a4eca855a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e0b92fcf8cb0aa47f36857dec1f17d inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a09e0b92fcf8cb0aa47f36857dec1f17d">hasMetaData</a> () const</td></tr>
<tr class="memdesc:a09e0b92fcf8cb0aa47f36857dec1f17d inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether meta data has been associated to this image  <a href="classicl_1_1core_1_1ImgBase.html#a09e0b92fcf8cb0aa47f36857dec1f17d">More...</a><br /></td></tr>
<tr class="separator:a09e0b92fcf8cb0aa47f36857dec1f17d inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bdf03023664c535d8ce2f5de2b0b64 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a87bdf03023664c535d8ce2f5de2b0b64">setMetaData</a> (const std::string &amp;data)</td></tr>
<tr class="memdesc:a87bdf03023664c535d8ce2f5de2b0b64 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">associates new meta data with this image  <a href="classicl_1_1core_1_1ImgBase.html#a87bdf03023664c535d8ce2f5de2b0b64">More...</a><br /></td></tr>
<tr class="separator:a87bdf03023664c535d8ce2f5de2b0b64 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9701749771d8b03ed4357603ebe80dfb inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a9701749771d8b03ed4357603ebe80dfb">clearMetaData</a> ()</td></tr>
<tr class="memdesc:a9701749771d8b03ed4357603ebe80dfb inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes all meta data  <a href="classicl_1_1core_1_1ImgBase.html#a9701749771d8b03ed4357603ebe80dfb">More...</a><br /></td></tr>
<tr class="separator:a9701749771d8b03ed4357603ebe80dfb inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40198a2fef9c6dd939be9d68333d170e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a40198a2fef9c6dd939be9d68333d170e">getMetaData</a> () const</td></tr>
<tr class="memdesc:a40198a2fef9c6dd939be9d68333d170e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns associated meta data  <a href="classicl_1_1core_1_1ImgBase.html#a40198a2fef9c6dd939be9d68333d170e">More...</a><br /></td></tr>
<tr class="separator:a40198a2fef9c6dd939be9d68333d170e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09159058caeb376706b8161e6666ea4a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a09159058caeb376706b8161e6666ea4a">getMetaData</a> ()</td></tr>
<tr class="memdesc:a09159058caeb376706b8161e6666ea4a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns associated meta data (unconst)  <a href="classicl_1_1core_1_1ImgBase.html#a09159058caeb376706b8161e6666ea4a">More...</a><br /></td></tr>
<tr class="separator:a09159058caeb376706b8161e6666ea4a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59355fbe438268c31c2c8a3b707063c7 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a59355fbe438268c31c2c8a3b707063c7">shallowCopy</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi, const std::vector&lt; int &gt; &amp;channelIndices, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, <a class="el" href="classicl_1_1utils_1_1Time.html">utils::Time</a> time=<a class="el" href="classicl_1_1utils_1_1Time.html#ace3f64d086f815af887221fd9b186996">utils::Time::null</a>) const</td></tr>
<tr class="separator:a59355fbe438268c31c2c8a3b707063c7 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca9b67f2792e29999fbac302b695713 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#afca9b67f2792e29999fbac302b695713">reinterpretChannels</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> newFmt, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=NULL)</td></tr>
<tr class="memdesc:afca9b67f2792e29999fbac302b695713 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of this image with a new format.  <a href="classicl_1_1core_1_1ImgBase.html#afca9b67f2792e29999fbac302b695713">More...</a><br /></td></tr>
<tr class="separator:afca9b67f2792e29999fbac302b695713 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa136e16b4b60ba42cfbc3c34af0930a5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#aa136e16b4b60ba42cfbc3c34af0930a5">reinterpretChannels</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> newFmt) const</td></tr>
<tr class="memdesc:aa136e16b4b60ba42cfbc3c34af0930a5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of this image with a new format (const version)  <a href="classicl_1_1core_1_1ImgBase.html#aa136e16b4b60ba42cfbc3c34af0930a5">More...</a><br /></td></tr>
<tr class="separator:aa136e16b4b60ba42cfbc3c34af0930a5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcda82512b4d5a6b3401405e6fa0e3ad inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#abcda82512b4d5a6b3401405e6fa0e3ad">shallowCopy</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=NULL)</td></tr>
<tr class="memdesc:abcda82512b4d5a6b3401405e6fa0e3ad inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of the image.  <a href="classicl_1_1core_1_1ImgBase.html#abcda82512b4d5a6b3401405e6fa0e3ad">More...</a><br /></td></tr>
<tr class="separator:abcda82512b4d5a6b3401405e6fa0e3ad inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e831aed4a660bcdd43a5aaac878422a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a3e831aed4a660bcdd43a5aaac878422a">shallowCopy</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=NULL)</td></tr>
<tr class="separator:a3e831aed4a660bcdd43a5aaac878422a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2946e0fbeaf61a33a1f92794d17550 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a0b2946e0fbeaf61a33a1f92794d17550">shallowCopy</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi) const</td></tr>
<tr class="memdesc:a0b2946e0fbeaf61a33a1f92794d17550 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of a const source image.  <a href="classicl_1_1core_1_1ImgBase.html#a0b2946e0fbeaf61a33a1f92794d17550">More...</a><br /></td></tr>
<tr class="separator:a0b2946e0fbeaf61a33a1f92794d17550 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe16e0445a9e984c77a44453fbf71791 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#abe16e0445a9e984c77a44453fbf71791">selectChannels</a> (const std::vector&lt; int &gt; &amp;channelIndices, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0)</td></tr>
<tr class="memdesc:abe16e0445a9e984c77a44453fbf71791 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of selected channels of an image.  <a href="classicl_1_1core_1_1ImgBase.html#abe16e0445a9e984c77a44453fbf71791">More...</a><br /></td></tr>
<tr class="separator:abe16e0445a9e984c77a44453fbf71791 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a4591324c9e72e3445710a13fca1cd inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a37a4591324c9e72e3445710a13fca1cd">selectChannel</a> (int channelIndex, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0)</td></tr>
<tr class="memdesc:a37a4591324c9e72e3445710a13fca1cd inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of a single image channel of an image.  <a href="classicl_1_1core_1_1ImgBase.html#a37a4591324c9e72e3445710a13fca1cd">More...</a><br /></td></tr>
<tr class="separator:a37a4591324c9e72e3445710a13fca1cd inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bb866ec47230e9075ab8fe44a7fceb inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a64bb866ec47230e9075ab8fe44a7fceb">selectChannels</a> (const std::vector&lt; int &gt; &amp;channelIndices) const</td></tr>
<tr class="memdesc:a64bb866ec47230e9075ab8fe44a7fceb inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of selected channels of a const image.  <a href="classicl_1_1core_1_1ImgBase.html#a64bb866ec47230e9075ab8fe44a7fceb">More...</a><br /></td></tr>
<tr class="separator:a64bb866ec47230e9075ab8fe44a7fceb inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8745795fc296b1be836eee75d48625f0 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a8745795fc296b1be836eee75d48625f0">selectChannel</a> (int channelIndex) const</td></tr>
<tr class="memdesc:a8745795fc296b1be836eee75d48625f0 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of a single image channel of a const image.  <a href="classicl_1_1core_1_1ImgBase.html#a8745795fc296b1be836eee75d48625f0">More...</a><br /></td></tr>
<tr class="separator:a8745795fc296b1be836eee75d48625f0 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1015e8202e0edf43c91d62f9f79436 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5e1015e8202e0edf43c91d62f9f79436 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a5e1015e8202e0edf43c91d62f9f79436">convert</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *poDst=NULL) const</td></tr>
<tr class="memdesc:a5e1015e8202e0edf43c91d62f9f79436 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> instance of this image (type-conversion or deep copy)  <a href="classicl_1_1core_1_1ImgBase.html#a5e1015e8202e0edf43c91d62f9f79436">More...</a><br /></td></tr>
<tr class="separator:a5e1015e8202e0edf43c91d62f9f79436 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80eba73f3725033f33b2f748fed8ce5d inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a80eba73f3725033f33b2f748fed8ce5d">convert</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d) const</td></tr>
<tr class="memdesc:a80eba73f3725033f33b2f748fed8ce5d inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a converted (or deep copied) instance of this image  <a href="classicl_1_1core_1_1ImgBase.html#a80eba73f3725033f33b2f748fed8ce5d">More...</a><br /></td></tr>
<tr class="separator:a80eba73f3725033f33b2f748fed8ce5d inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0379cd9e85ae245f258a9e34e2951b inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a0a0379cd9e85ae245f258a9e34e2951b">convert</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poDst) const</td></tr>
<tr class="memdesc:a0a0379cd9e85ae245f258a9e34e2951b inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts image data into the given destination image  <a href="classicl_1_1core_1_1ImgBase.html#a0a0379cd9e85ae245f258a9e34e2951b">More...</a><br /></td></tr>
<tr class="separator:a0a0379cd9e85ae245f258a9e34e2951b inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352aec5d14df3f67b5387dbd68794993 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a352aec5d14df3f67b5387dbd68794993 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a352aec5d14df3f67b5387dbd68794993">convertROI</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *poDst=NULL) const</td></tr>
<tr class="memdesc:a352aec5d14df3f67b5387dbd68794993 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a converted (or deep copied) instance of this images ROI  <a href="classicl_1_1core_1_1ImgBase.html#a352aec5d14df3f67b5387dbd68794993">More...</a><br /></td></tr>
<tr class="separator:a352aec5d14df3f67b5387dbd68794993 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad4f0c9f9471c2e0f957b2c86267796 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#abad4f0c9f9471c2e0f957b2c86267796">convertROI</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d) const</td></tr>
<tr class="memdesc:abad4f0c9f9471c2e0f957b2c86267796 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a converted (or deep copied) instance of this images ROI  <a href="classicl_1_1core_1_1ImgBase.html#abad4f0c9f9471c2e0f957b2c86267796">More...</a><br /></td></tr>
<tr class="separator:abad4f0c9f9471c2e0f957b2c86267796 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499edbd81481b48c91ce57208e447bd1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a499edbd81481b48c91ce57208e447bd1">convertROI</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poDst) const</td></tr>
<tr class="memdesc:a499edbd81481b48c91ce57208e447bd1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts this images ROI into a given destination image  <a href="classicl_1_1core_1_1ImgBase.html#a499edbd81481b48c91ce57208e447bd1">More...</a><br /></td></tr>
<tr class="separator:a499edbd81481b48c91ce57208e447bd1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b6177644bae7d6d0a2f189e6cb9a43 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a79b6177644bae7d6d0a2f189e6cb9a43 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43">asImg</a> ()</td></tr>
<tr class="memdesc:a79b6177644bae7d6d0a2f189e6cb9a43 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamically casts this image to one of its <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> subclasses  <a href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43">More...</a><br /></td></tr>
<tr class="separator:a79b6177644bae7d6d0a2f189e6cb9a43 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060ffc53f31784a9b7e08cf7be0c1e51 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a060ffc53f31784a9b7e08cf7be0c1e51 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a060ffc53f31784a9b7e08cf7be0c1e51">asImg</a> () const</td></tr>
<tr class="memdesc:a060ffc53f31784a9b7e08cf7be0c1e51 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">dynamically casts this image to one of its <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> subclasses (const version)  <a href="classicl_1_1core_1_1ImgBase.html#a060ffc53f31784a9b7e08cf7be0c1e51">More...</a><br /></td></tr>
<tr class="separator:a060ffc53f31784a9b7e08cf7be0c1e51 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af518e9ae3c636ebc1bc2d53263afe8f6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#af518e9ae3c636ebc1bc2d53263afe8f6">as8u</a> ()</td></tr>
<tr class="memdesc:af518e9ae3c636ebc1bc2d53263afe8f6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl8u&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#af518e9ae3c636ebc1bc2d53263afe8f6">More...</a><br /></td></tr>
<tr class="separator:af518e9ae3c636ebc1bc2d53263afe8f6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5b4f55c3279d89a680f588f558ad31 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a79af5b84ad2c6e4acf44ae0530d89269">icl16s</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a0f5b4f55c3279d89a680f588f558ad31">as16s</a> ()</td></tr>
<tr class="memdesc:a0f5b4f55c3279d89a680f588f558ad31 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl16s&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#a0f5b4f55c3279d89a680f588f558ad31">More...</a><br /></td></tr>
<tr class="separator:a0f5b4f55c3279d89a680f588f558ad31 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36436ffa6a4a12f242684ce5c15eddf6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a36436ffa6a4a12f242684ce5c15eddf6">as32s</a> ()</td></tr>
<tr class="memdesc:a36436ffa6a4a12f242684ce5c15eddf6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl32s&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#a36436ffa6a4a12f242684ce5c15eddf6">More...</a><br /></td></tr>
<tr class="separator:a36436ffa6a4a12f242684ce5c15eddf6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab740d57ffa3b1d82e1f4d6a51fa782ee inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ab740d57ffa3b1d82e1f4d6a51fa782ee">as32f</a> ()</td></tr>
<tr class="memdesc:ab740d57ffa3b1d82e1f4d6a51fa782ee inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl32f&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#ab740d57ffa3b1d82e1f4d6a51fa782ee">More...</a><br /></td></tr>
<tr class="separator:ab740d57ffa3b1d82e1f4d6a51fa782ee inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62dbe02f2e0377b6312ad20dd03249c inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ad62dbe02f2e0377b6312ad20dd03249c">as64f</a> ()</td></tr>
<tr class="memdesc:ad62dbe02f2e0377b6312ad20dd03249c inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl64f&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#ad62dbe02f2e0377b6312ad20dd03249c">More...</a><br /></td></tr>
<tr class="separator:ad62dbe02f2e0377b6312ad20dd03249c inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80485796cbe1db89d8cee923c01b503f inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a80485796cbe1db89d8cee923c01b503f">as8u</a> () const</td></tr>
<tr class="memdesc:a80485796cbe1db89d8cee923c01b503f inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl8u&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#a80485796cbe1db89d8cee923c01b503f">More...</a><br /></td></tr>
<tr class="separator:a80485796cbe1db89d8cee923c01b503f inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3dcfce3950978625158ce49c19622e5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a79af5b84ad2c6e4acf44ae0530d89269">icl16s</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ae3dcfce3950978625158ce49c19622e5">as16s</a> () const</td></tr>
<tr class="memdesc:ae3dcfce3950978625158ce49c19622e5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl16s&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#ae3dcfce3950978625158ce49c19622e5">More...</a><br /></td></tr>
<tr class="separator:ae3dcfce3950978625158ce49c19622e5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5527a087de2d5a20b04dbe70a4097a84 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a42327266b9cc89a04bb7cf0ff1b1b0b2">icl32s</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a5527a087de2d5a20b04dbe70a4097a84">as32s</a> () const</td></tr>
<tr class="memdesc:a5527a087de2d5a20b04dbe70a4097a84 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl32s&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#a5527a087de2d5a20b04dbe70a4097a84">More...</a><br /></td></tr>
<tr class="separator:a5527a087de2d5a20b04dbe70a4097a84 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe9611ce21c8105b77c590e84f21b2b inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#a9d5e66277c0b9e4cee1d9e0f51768f49">icl32f</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#adfe9611ce21c8105b77c590e84f21b2b">as32f</a> () const</td></tr>
<tr class="memdesc:adfe9611ce21c8105b77c590e84f21b2b inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl32f&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#adfe9611ce21c8105b77c590e84f21b2b">More...</a><br /></td></tr>
<tr class="separator:adfe9611ce21c8105b77c590e84f21b2b inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b4d21d15acd339bc413f36cb1de898 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a31b4d21d15acd339bc413f36cb1de898">as64f</a> () const</td></tr>
<tr class="memdesc:a31b4d21d15acd339bc413f36cb1de898 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience shortcut version for <a class="el" href="classicl_1_1core_1_1ImgBase.html#a79b6177644bae7d6d0a2f189e6cb9a43" title="dynamically casts this image to one of its Img&lt;T&gt; subclasses">asImg&lt;icl64f&gt;()</a>  <a href="classicl_1_1core_1_1ImgBase.html#a31b4d21d15acd339bc413f36cb1de898">More...</a><br /></td></tr>
<tr class="separator:a31b4d21d15acd339bc413f36cb1de898 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238b2bfd431918ff0ca10414470aa71a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a238b2bfd431918ff0ca10414470aa71a">getParams</a> () const</td></tr>
<tr class="memdesc:a238b2bfd431918ff0ca10414470aa71a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all params in terms of a const <a class="el" href="classicl_1_1core_1_1ImgParams.html" title="The ImgParams class stores all image parameters.">ImgParams</a> reference  <a href="classicl_1_1core_1_1ImgBase.html#a238b2bfd431918ff0ca10414470aa71a">More...</a><br /></td></tr>
<tr class="separator:a238b2bfd431918ff0ca10414470aa71a inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae767b0c5543c9934aa8af846dda1d7b2 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ae767b0c5543c9934aa8af846dda1d7b2">getSize</a> () const</td></tr>
<tr class="memdesc:ae767b0c5543c9934aa8af846dda1d7b2 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of the images  <a href="classicl_1_1core_1_1ImgBase.html#ae767b0c5543c9934aa8af846dda1d7b2">More...</a><br /></td></tr>
<tr class="separator:ae767b0c5543c9934aa8af846dda1d7b2 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19261f5654fa868e6fa5d039d8f3ccfe inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a19261f5654fa868e6fa5d039d8f3ccfe">getWidth</a> () const</td></tr>
<tr class="memdesc:a19261f5654fa868e6fa5d039d8f3ccfe inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the images width  <a href="classicl_1_1core_1_1ImgBase.html#a19261f5654fa868e6fa5d039d8f3ccfe">More...</a><br /></td></tr>
<tr class="separator:a19261f5654fa868e6fa5d039d8f3ccfe inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc3d21e86b5ffc9a1d5316010a78c6c inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#afcc3d21e86b5ffc9a1d5316010a78c6c">getHeight</a> () const</td></tr>
<tr class="memdesc:afcc3d21e86b5ffc9a1d5316010a78c6c inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the images height  <a href="classicl_1_1core_1_1ImgBase.html#afcc3d21e86b5ffc9a1d5316010a78c6c">More...</a><br /></td></tr>
<tr class="separator:afcc3d21e86b5ffc9a1d5316010a78c6c inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ba167824297dc67cf40e163ec855a9 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#af2ba167824297dc67cf40e163ec855a9">getDim</a> () const</td></tr>
<tr class="memdesc:af2ba167824297dc67cf40e163ec855a9 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pixel count of each channel  <a href="classicl_1_1core_1_1ImgBase.html#af2ba167824297dc67cf40e163ec855a9">More...</a><br /></td></tr>
<tr class="separator:af2ba167824297dc67cf40e163ec855a9 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7696553df7010323c6a6bb8c3fd3f6f inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#af7696553df7010323c6a6bb8c3fd3f6f">getChannels</a> () const</td></tr>
<tr class="memdesc:af7696553df7010323c6a6bb8c3fd3f6f inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the channel count of the image  <a href="classicl_1_1core_1_1ImgBase.html#af7696553df7010323c6a6bb8c3fd3f6f">More...</a><br /></td></tr>
<tr class="separator:af7696553df7010323c6a6bb8c3fd3f6f inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40972db3dca1dd6228030e5d15a9dab inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#af40972db3dca1dd6228030e5d15a9dab">getDepth</a> () const</td></tr>
<tr class="memdesc:af40972db3dca1dd6228030e5d15a9dab inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the depth (depth8u or depth32f)  <a href="classicl_1_1core_1_1ImgBase.html#af40972db3dca1dd6228030e5d15a9dab">More...</a><br /></td></tr>
<tr class="separator:af40972db3dca1dd6228030e5d15a9dab inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb8d3321cacf116d08773a1c30fd803 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#affb8d3321cacf116d08773a1c30fd803">getFormat</a> () const</td></tr>
<tr class="memdesc:affb8d3321cacf116d08773a1c30fd803 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current (color)-format of this image  <a href="classicl_1_1core_1_1ImgBase.html#affb8d3321cacf116d08773a1c30fd803">More...</a><br /></td></tr>
<tr class="separator:affb8d3321cacf116d08773a1c30fd803 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f9607e05b6f8f3a517c6775a0299e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1Time.html">utils::Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a9a0f9607e05b6f8f3a517c6775a0299e">getTime</a> () const</td></tr>
<tr class="memdesc:a9a0f9607e05b6f8f3a517c6775a0299e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the timestamp of the image  <a href="classicl_1_1core_1_1ImgBase.html#a9a0f9607e05b6f8f3a517c6775a0299e">More...</a><br /></td></tr>
<tr class="separator:a9a0f9607e05b6f8f3a517c6775a0299e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ad6855e73e79329c58d15ce619fef8 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a43ad6855e73e79329c58d15ce619fef8">getROI</a> () const</td></tr>
<tr class="memdesc:a43ad6855e73e79329c58d15ce619fef8 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the images ROI rectangle  <a href="classicl_1_1core_1_1ImgBase.html#a43ad6855e73e79329c58d15ce619fef8">More...</a><br /></td></tr>
<tr class="separator:a43ad6855e73e79329c58d15ce619fef8 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c08eca8bc5ab3b7a464f3203b04205 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a61c08eca8bc5ab3b7a464f3203b04205">getROI</a> (<a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;offset, <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size) const</td></tr>
<tr class="memdesc:a61c08eca8bc5ab3b7a464f3203b04205 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies the current ROI into the given offset and size references  <a href="classicl_1_1core_1_1ImgBase.html#a61c08eca8bc5ab3b7a464f3203b04205">More...</a><br /></td></tr>
<tr class="separator:a61c08eca8bc5ab3b7a464f3203b04205 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bfbfb55638d7758b41e960cba22a34 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#aa1bfbfb55638d7758b41e960cba22a34">getROIOffset</a> () const</td></tr>
<tr class="memdesc:aa1bfbfb55638d7758b41e960cba22a34 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the images ROI offset (upper left corner)  <a href="classicl_1_1core_1_1ImgBase.html#aa1bfbfb55638d7758b41e960cba22a34">More...</a><br /></td></tr>
<tr class="separator:aa1bfbfb55638d7758b41e960cba22a34 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5546accce012d468cdd211c83ce5dee inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ab5546accce012d468cdd211c83ce5dee">getROISize</a> () const</td></tr>
<tr class="memdesc:ab5546accce012d468cdd211c83ce5dee inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the images ROI size  <a href="classicl_1_1core_1_1ImgBase.html#ab5546accce012d468cdd211c83ce5dee">More...</a><br /></td></tr>
<tr class="separator:ab5546accce012d468cdd211c83ce5dee inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11da2858c872638d27f1264a797e29b2 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a11da2858c872638d27f1264a797e29b2">getROIWidth</a> () const</td></tr>
<tr class="memdesc:a11da2858c872638d27f1264a797e29b2 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the images ROI width  <a href="classicl_1_1core_1_1ImgBase.html#a11da2858c872638d27f1264a797e29b2">More...</a><br /></td></tr>
<tr class="separator:a11da2858c872638d27f1264a797e29b2 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed998bb3496b4125a115c7dff948d5f7 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#aed998bb3496b4125a115c7dff948d5f7">getROIHeight</a> () const</td></tr>
<tr class="memdesc:aed998bb3496b4125a115c7dff948d5f7 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the images ROI height  <a href="classicl_1_1core_1_1ImgBase.html#aed998bb3496b4125a115c7dff948d5f7">More...</a><br /></td></tr>
<tr class="separator:aed998bb3496b4125a115c7dff948d5f7 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea3a4335421533c58fbdd34b9e3d728 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a1ea3a4335421533c58fbdd34b9e3d728">getROIXOffset</a> () const</td></tr>
<tr class="memdesc:a1ea3a4335421533c58fbdd34b9e3d728 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the images ROI XOffset  <a href="classicl_1_1core_1_1ImgBase.html#a1ea3a4335421533c58fbdd34b9e3d728">More...</a><br /></td></tr>
<tr class="separator:a1ea3a4335421533c58fbdd34b9e3d728 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212583ec9936c44664ef0dd47f11a953 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a212583ec9936c44664ef0dd47f11a953">getROIYOffset</a> () const</td></tr>
<tr class="memdesc:a212583ec9936c44664ef0dd47f11a953 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the images ROI YOffset  <a href="classicl_1_1core_1_1ImgBase.html#a212583ec9936c44664ef0dd47f11a953">More...</a><br /></td></tr>
<tr class="separator:a212583ec9936c44664ef0dd47f11a953 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af543fea4892dbb2501b0885b8f18d1e4 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#af543fea4892dbb2501b0885b8f18d1e4">getImageRect</a> () const</td></tr>
<tr class="memdesc:af543fea4892dbb2501b0885b8f18d1e4 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the image rect (0,0,width, height)  <a href="classicl_1_1core_1_1ImgBase.html#af543fea4892dbb2501b0885b8f18d1e4">More...</a><br /></td></tr>
<tr class="separator:af543fea4892dbb2501b0885b8f18d1e4 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ab11a7eed74e88e5089627759e3c52 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ad9ab11a7eed74e88e5089627759e3c52">setROIOffset</a> (const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;offset)</td></tr>
<tr class="memdesc:ad9ab11a7eed74e88e5089627759e3c52 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the image ROI offset to the given value  <a href="classicl_1_1core_1_1ImgBase.html#ad9ab11a7eed74e88e5089627759e3c52">More...</a><br /></td></tr>
<tr class="separator:ad9ab11a7eed74e88e5089627759e3c52 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b33ca6176d4791870ded8e485e53b6e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a8b33ca6176d4791870ded8e485e53b6e">setROISize</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size)</td></tr>
<tr class="memdesc:a8b33ca6176d4791870ded8e485e53b6e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the image ROI size to the given value  <a href="classicl_1_1core_1_1ImgBase.html#a8b33ca6176d4791870ded8e485e53b6e">More...</a><br /></td></tr>
<tr class="separator:a8b33ca6176d4791870ded8e485e53b6e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893544ea5a02bf8f126d38e378a6b6bc inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a893544ea5a02bf8f126d38e378a6b6bc">setROI</a> (const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;offset, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size)</td></tr>
<tr class="memdesc:a893544ea5a02bf8f126d38e378a6b6bc inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">set both image ROI offset and size  <a href="classicl_1_1core_1_1ImgBase.html#a893544ea5a02bf8f126d38e378a6b6bc">More...</a><br /></td></tr>
<tr class="separator:a893544ea5a02bf8f126d38e378a6b6bc inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35780484afe6b502dc69a79ebb7d45c5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a35780484afe6b502dc69a79ebb7d45c5">setROI</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi)</td></tr>
<tr class="memdesc:a35780484afe6b502dc69a79ebb7d45c5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the image ROI to the given rectangle  <a href="classicl_1_1core_1_1ImgBase.html#a35780484afe6b502dc69a79ebb7d45c5">More...</a><br /></td></tr>
<tr class="separator:a35780484afe6b502dc69a79ebb7d45c5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8c4c2a705c13e124e91016358ae9eb inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a6d8c4c2a705c13e124e91016358ae9eb">setROIOffsetAdaptive</a> (const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;offset)</td></tr>
<tr class="memdesc:a6d8c4c2a705c13e124e91016358ae9eb inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks, eventually adapts and finally sets the image ROI size  <a href="classicl_1_1core_1_1ImgBase.html#a6d8c4c2a705c13e124e91016358ae9eb">More...</a><br /></td></tr>
<tr class="separator:a6d8c4c2a705c13e124e91016358ae9eb inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5087c85404910ca6123f59b3eaa3839 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ad5087c85404910ca6123f59b3eaa3839">setROISizeAdaptive</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size)</td></tr>
<tr class="memdesc:ad5087c85404910ca6123f59b3eaa3839 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks, eventually adapts and finally sets the image ROI size  <a href="classicl_1_1core_1_1ImgBase.html#ad5087c85404910ca6123f59b3eaa3839">More...</a><br /></td></tr>
<tr class="separator:ad5087c85404910ca6123f59b3eaa3839 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e6f2e734d4a4695edd4c0ff8730ee6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a75e6f2e734d4a4695edd4c0ff8730ee6">setROIAdaptive</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi)</td></tr>
<tr class="memdesc:a75e6f2e734d4a4695edd4c0ff8730ee6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks, eventually adapts and finally sets the image ROI size  <a href="classicl_1_1core_1_1ImgBase.html#a75e6f2e734d4a4695edd4c0ff8730ee6">More...</a><br /></td></tr>
<tr class="separator:a75e6f2e734d4a4695edd4c0ff8730ee6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d4da9c9619c27875a6c513bcfaf5f1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ae8d4da9c9619c27875a6c513bcfaf5f1">hasFullROI</a> () const</td></tr>
<tr class="memdesc:ae8d4da9c9619c27875a6c513bcfaf5f1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns ROISize == ImageSize  <a href="classicl_1_1core_1_1ImgBase.html#ae8d4da9c9619c27875a6c513bcfaf5f1">More...</a><br /></td></tr>
<tr class="separator:ae8d4da9c9619c27875a6c513bcfaf5f1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddd43e1ee36620cefa42714f288e9b7 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a8ddd43e1ee36620cefa42714f288e9b7">setFullROI</a> ()</td></tr>
<tr class="memdesc:a8ddd43e1ee36620cefa42714f288e9b7 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the image ROI to the whole image size with offset (0,0)  <a href="classicl_1_1core_1_1ImgBase.html#a8ddd43e1ee36620cefa42714f288e9b7">More...</a><br /></td></tr>
<tr class="separator:a8ddd43e1ee36620cefa42714f288e9b7 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e0f15fda2698caca7d3a315715fbb9 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#aa7e0f15fda2698caca7d3a315715fbb9">setParams</a> (const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;params)</td></tr>
<tr class="memdesc:aa7e0f15fda2698caca7d3a315715fbb9 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets all image parameters in order channels,size,format,roi  <a href="classicl_1_1core_1_1ImgBase.html#aa7e0f15fda2698caca7d3a315715fbb9">More...</a><br /></td></tr>
<tr class="separator:aa7e0f15fda2698caca7d3a315715fbb9 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e555f5a5cb36819de8d9de3d7a2cc5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ae4e555f5a5cb36819de8d9de3d7a2cc5">setFormat</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt)</td></tr>
<tr class="memdesc:ae4e555f5a5cb36819de8d9de3d7a2cc5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the format associated with channels of the image  <a href="classicl_1_1core_1_1ImgBase.html#ae4e555f5a5cb36819de8d9de3d7a2cc5">More...</a><br /></td></tr>
<tr class="separator:ae4e555f5a5cb36819de8d9de3d7a2cc5 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f09b9ff99031ed972da842683e4f4a8 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a8f09b9ff99031ed972da842683e4f4a8">setTime</a> (const <a class="el" href="classicl_1_1utils_1_1Time.html">utils::Time</a> time)</td></tr>
<tr class="memdesc:a8f09b9ff99031ed972da842683e4f4a8 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the timestamp of the image  <a href="classicl_1_1core_1_1ImgBase.html#a8f09b9ff99031ed972da842683e4f4a8">More...</a><br /></td></tr>
<tr class="separator:a8f09b9ff99031ed972da842683e4f4a8 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0040113c23b6046e015f3e1a40eb8dc inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ae0040113c23b6046e015f3e1a40eb8dc">setTime</a> ()</td></tr>
<tr class="memdesc:ae0040113c23b6046e015f3e1a40eb8dc inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets timestamp of the image to the current time  <a href="classicl_1_1core_1_1ImgBase.html#ae0040113c23b6046e015f3e1a40eb8dc">More...</a><br /></td></tr>
<tr class="separator:ae0040113c23b6046e015f3e1a40eb8dc inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fff7f42d15ba868453600c8ccf65c1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ab2fff7f42d15ba868453600c8ccf65c1">getMax</a> (int iChannel, <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *coords=0) const</td></tr>
<tr class="memdesc:ab2fff7f42d15ba868453600c8ccf65c1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max pixel value of channel iChannel within ROI.  <a href="classicl_1_1core_1_1ImgBase.html#ab2fff7f42d15ba868453600c8ccf65c1">More...</a><br /></td></tr>
<tr class="separator:ab2fff7f42d15ba868453600c8ccf65c1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a6393e0105e97b02535fdba1c2f25 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a962a6393e0105e97b02535fdba1c2f25">getMin</a> (int iChannel, <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *coords=0) const</td></tr>
<tr class="memdesc:a962a6393e0105e97b02535fdba1c2f25 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min pixel value of channel iChannel within ROI.  <a href="classicl_1_1core_1_1ImgBase.html#a962a6393e0105e97b02535fdba1c2f25">More...</a><br /></td></tr>
<tr class="separator:a962a6393e0105e97b02535fdba1c2f25 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47dbc7fd33c1578272c2c95c12a2b16 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ac47dbc7fd33c1578272c2c95c12a2b16">getMin</a> () const</td></tr>
<tr class="memdesc:ac47dbc7fd33c1578272c2c95c12a2b16 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">return maximal pixel value over all channels (restricted to ROI)  <a href="classicl_1_1core_1_1ImgBase.html#ac47dbc7fd33c1578272c2c95c12a2b16">More...</a><br /></td></tr>
<tr class="separator:ac47dbc7fd33c1578272c2c95c12a2b16 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430c30c3b59b4a45499abfb690cc17c6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a430c30c3b59b4a45499abfb690cc17c6">getMax</a> () const</td></tr>
<tr class="memdesc:a430c30c3b59b4a45499abfb690cc17c6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">return minimal pixel value over all channels (restricted to ROI)  <a href="classicl_1_1core_1_1ImgBase.html#a430c30c3b59b4a45499abfb690cc17c6">More...</a><br /></td></tr>
<tr class="separator:a430c30c3b59b4a45499abfb690cc17c6 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22041dd8ff0007f33fa6c9d1e3ea2034 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a22041dd8ff0007f33fa6c9d1e3ea2034">getMinMax</a> (int iChannel, <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *minCoords=0, <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *maxCoords=0) const</td></tr>
<tr class="memdesc:a22041dd8ff0007f33fa6c9d1e3ea2034 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min and max pixel values of channel iChannel within ROI.  <a href="classicl_1_1core_1_1ImgBase.html#a22041dd8ff0007f33fa6c9d1e3ea2034">More...</a><br /></td></tr>
<tr class="separator:a22041dd8ff0007f33fa6c9d1e3ea2034 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3bca45cc0c8c42784ab650f957bbf1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a4d3bca45cc0c8c42784ab650f957bbf1">getMinMax</a> () const</td></tr>
<tr class="memdesc:a4d3bca45cc0c8c42784ab650f957bbf1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min and max pixel values of all channels within ROI.  <a href="classicl_1_1core_1_1ImgBase.html#a4d3bca45cc0c8c42784ab650f957bbf1">More...</a><br /></td></tr>
<tr class="separator:a4d3bca45cc0c8c42784ab650f957bbf1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae056e3ed66eb35cd61e102138b2bac68 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ae056e3ed66eb35cd61e102138b2bac68">clear</a> (int iChannel=-1, <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> val=0, bool bROIOnly=true)</td></tr>
<tr class="memdesc:ae056e3ed66eb35cd61e102138b2bac68 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ROI pixels of one or all channels to a specified value.  <a href="classicl_1_1core_1_1ImgBase.html#ae056e3ed66eb35cd61e102138b2bac68">More...</a><br /></td></tr>
<tr class="separator:ae056e3ed66eb35cd61e102138b2bac68 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3724768299ea80140c492808befbd26d inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a3724768299ea80140c492808befbd26d">normalizeAllChannels</a> (const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:a3724768299ea80140c492808befbd26d inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the channel min/ max range to the new min, max range.  <a href="classicl_1_1core_1_1ImgBase.html#a3724768299ea80140c492808befbd26d">More...</a><br /></td></tr>
<tr class="separator:a3724768299ea80140c492808befbd26d inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfefa8ebfe5a08abbbc52c3f6b979b83 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#abfefa8ebfe5a08abbbc52c3f6b979b83">normalizeChannel</a> (int iChannel, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; &amp;srcRange, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:abfefa8ebfe5a08abbbc52c3f6b979b83 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the channel from a given min/max range to the new range.  <a href="classicl_1_1core_1_1ImgBase.html#abfefa8ebfe5a08abbbc52c3f6b979b83">More...</a><br /></td></tr>
<tr class="separator:abfefa8ebfe5a08abbbc52c3f6b979b83 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b7f7091dd5c566f9e84f3ba5bc1121 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a59b7f7091dd5c566f9e84f3ba5bc1121">normalizeChannel</a> (int iChannel, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:a59b7f7091dd5c566f9e84f3ba5bc1121 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the channel from a given min/max range to the new range.  <a href="classicl_1_1core_1_1ImgBase.html#a59b7f7091dd5c566f9e84f3ba5bc1121">More...</a><br /></td></tr>
<tr class="separator:a59b7f7091dd5c566f9e84f3ba5bc1121 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803483cf4f1cc93eea8141ca1605e4f4 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a803483cf4f1cc93eea8141ca1605e4f4">normalizeImg</a> (const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; &amp;srcRange, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:a803483cf4f1cc93eea8141ca1605e4f4 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the image from a given min/max range to the new range.  <a href="classicl_1_1core_1_1ImgBase.html#a803483cf4f1cc93eea8141ca1605e4f4">More...</a><br /></td></tr>
<tr class="separator:a803483cf4f1cc93eea8141ca1605e4f4 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b37dbb132839e3c1c2c8e765b8c3d0 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a95b37dbb132839e3c1c2c8e765b8c3d0">normalizeImg</a> (const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:a95b37dbb132839e3c1c2c8e765b8c3d0 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the image from a min/max range to the new range.  <a href="classicl_1_1core_1_1ImgBase.html#a95b37dbb132839e3c1c2c8e765b8c3d0">More...</a><br /></td></tr>
<tr class="separator:a95b37dbb132839e3c1c2c8e765b8c3d0 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad07e36e83dbf7378fa9814327ef243 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a9ad07e36e83dbf7378fa9814327ef243">print</a> (const std::string sTitle=&quot;image&quot;) const</td></tr>
<tr class="memdesc:a9ad07e36e83dbf7378fa9814327ef243 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints the image to std-out  <a href="classicl_1_1core_1_1ImgBase.html#a9ad07e36e83dbf7378fa9814327ef243">More...</a><br /></td></tr>
<tr class="separator:a9ad07e36e83dbf7378fa9814327ef243 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c65781275f0bf5b730cd53bd012456 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ae7c65781275f0bf5b730cd53bd012456">validChannel</a> (const int iChannel) const</td></tr>
<tr class="memdesc:ae7c65781275f0bf5b730cd53bd012456 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">validate the given channel index  <a href="classicl_1_1core_1_1ImgBase.html#ae7c65781275f0bf5b730cd53bd012456">More...</a><br /></td></tr>
<tr class="separator:ae7c65781275f0bf5b730cd53bd012456 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a36ca93bb87fdd6c4800b140f24818e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a1a36ca93bb87fdd6c4800b140f24818e">isEqual</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;s, int nChannels) const</td></tr>
<tr class="memdesc:a1a36ca93bb87fdd6c4800b140f24818e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if two images have same size, and channel count  <a href="classicl_1_1core_1_1ImgBase.html#a1a36ca93bb87fdd6c4800b140f24818e">More...</a><br /></td></tr>
<tr class="separator:a1a36ca93bb87fdd6c4800b140f24818e inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fa52d5db960a8ac8e4b47e9d1588e1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a91fa52d5db960a8ac8e4b47e9d1588e1">isEqual</a> (const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;params)</td></tr>
<tr class="memdesc:a91fa52d5db960a8ac8e4b47e9d1588e1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the image has the given parameters  <a href="classicl_1_1core_1_1ImgBase.html#a91fa52d5db960a8ac8e4b47e9d1588e1">More...</a><br /></td></tr>
<tr class="separator:a91fa52d5db960a8ac8e4b47e9d1588e1 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c287e29ea1166a6962fdacb7176974 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ac0c287e29ea1166a6962fdacb7176974">isEqual</a> (const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;params, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d)</td></tr>
<tr class="memdesc:ac0c287e29ea1166a6962fdacb7176974 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the image has given params and depth  <a href="classicl_1_1core_1_1ImgBase.html#ac0c287e29ea1166a6962fdacb7176974">More...</a><br /></td></tr>
<tr class="separator:ac0c287e29ea1166a6962fdacb7176974 inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb556e04eaaa17ec056fbbf5bb24b84f inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#abb556e04eaaa17ec056fbbf5bb24b84f">isEqual</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *otherImage)</td></tr>
<tr class="memdesc:abb556e04eaaa17ec056fbbf5bb24b84f inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks if the image has given params and depth as another image  <a href="classicl_1_1core_1_1ImgBase.html#abb556e04eaaa17ec056fbbf5bb24b84f">More...</a><br /></td></tr>
<tr class="separator:abb556e04eaaa17ec056fbbf5bb24b84f inherit pub_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac0cd34ad63d1ac567d02853fe2e53b6d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ac0cd34ad63d1ac567d02853fe2e53b6d">null</a></td></tr>
<tr class="memdesc:ac0cd34ad63d1ac567d02853fe2e53b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">null sized and null channel image  <a href="classicl_1_1core_1_1Img.html#ac0cd34ad63d1ac567d02853fe2e53b6d">More...</a><br /></td></tr>
<tr class="separator:ac0cd34ad63d1ac567d02853fe2e53b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5551b9551361837a4cae9a5720be30bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a5551b9551361837a4cae9a5720be30bd">shallowCopy</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;tSource)</td></tr>
<tr class="memdesc:a5551b9551361837a4cae9a5720be30bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Private assign operator (internally used)  <a href="classicl_1_1core_1_1Img.html#a5551b9551361837a4cae9a5720be30bd">More...</a><br /></td></tr>
<tr class="separator:a5551b9551361837a4cae9a5720be30bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5a29b120d0c8193d826d8b94464008"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ace5a29b120d0c8193d826d8b94464008">append</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *src, int iChannel=-1)</td></tr>
<tr class="memdesc:ace5a29b120d0c8193d826d8b94464008"><td class="mdescLeft">&#160;</td><td class="mdescRight">private append function for a specified image channel  <a href="classicl_1_1core_1_1Img.html#ace5a29b120d0c8193d826d8b94464008">More...</a><br /></td></tr>
<tr class="separator:ace5a29b120d0c8193d826d8b94464008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab014446ab51947df53ae127beb892c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ab014446ab51947df53ae127beb892c26">append</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *src, const std::vector&lt; int &gt; &amp;vChannels)</td></tr>
<tr class="memdesc:ab014446ab51947df53ae127beb892c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">private append function for a specified image channel  <a href="classicl_1_1core_1_1Img.html#ab014446ab51947df53ae127beb892c26">More...</a><br /></td></tr>
<tr class="separator:ab014446ab51947df53ae127beb892c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af5ebe1b9427826145e1fc3b47687c227"><td class="memTemplParams" colspan="2">template&lt;class ImgType &gt; </td></tr>
<tr class="memitem:af5ebe1b9427826145e1fc3b47687c227"><td class="memTemplItemLeft" align="right" valign="top">const friend ImgType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#af5ebe1b9427826145e1fc3b47687c227">combineImages</a> (const std::vector&lt; const ImgType * &gt; &amp;vec, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst)</td></tr>
<tr class="separator:af5ebe1b9427826145e1fc3b47687c227"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
data</h2></td></tr>
<tr class="memitem:a42c2f621cce7b4ad126bead38dca2058"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structicl_1_1utils_1_1SmartArray.html">utils::SmartArray</a>&lt; Type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a42c2f621cce7b4ad126bead38dca2058">m_vecChannels</a></td></tr>
<tr class="memdesc:a42c2f621cce7b4ad126bead38dca2058"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally used storage for the image channels  <a href="classicl_1_1core_1_1Img.html#a42c2f621cce7b4ad126bead38dca2058">More...</a><br /></td></tr>
<tr class="separator:a42c2f621cce7b4ad126bead38dca2058"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
auxiliary functions</h2></td></tr>
<tr class="memitem:a6879fba221d6b727db151cddea844409"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1utils_1_1SmartArray.html">utils::SmartArray</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a6879fba221d6b727db151cddea844409">createChannel</a> (Type *ptDataToCopy=0) const</td></tr>
<tr class="memdesc:a6879fba221d6b727db151cddea844409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally creates a new deep copy of a specified Type*.  <a href="classicl_1_1core_1_1Img.html#a6879fba221d6b727db151cddea844409">More...</a><br /></td></tr>
<tr class="separator:a6879fba221d6b727db151cddea844409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f9016cce58451355b6db43fbba233d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a66f9016cce58451355b6db43fbba233d">getStartIndex</a> (int iIndex) const</td></tr>
<tr class="memdesc:a66f9016cce58451355b6db43fbba233d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the start index for a channel loop  <a href="classicl_1_1core_1_1Img.html#a66f9016cce58451355b6db43fbba233d">More...</a><br /></td></tr>
<tr class="separator:a66f9016cce58451355b6db43fbba233d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141e786dbadd493bac77444fa1df95c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a141e786dbadd493bac77444fa1df95c1">getEndIndex</a> (int iIndex) const</td></tr>
<tr class="memdesc:a141e786dbadd493bac77444fa1df95c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the end index for a channel loop  <a href="classicl_1_1core_1_1Img.html#a141e786dbadd493bac77444fa1df95c1">More...</a><br /></td></tr>
<tr class="separator:a141e786dbadd493bac77444fa1df95c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
basic image manipulation</h2></td></tr>
<tr class="memitem:a6dd9c95a7aa606a347c416528915a5f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a6dd9c95a7aa606a347c416528915a5f3">normalize</a> (int iChannel, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;srcRange, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:a6dd9c95a7aa606a347c416528915a5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales pixel values from given min/max values to new min/max values (for internal use)  <a href="classicl_1_1core_1_1Img.html#a6dd9c95a7aa606a347c416528915a5f3">More...</a><br /></td></tr>
<tr class="separator:a6dd9c95a7aa606a347c416528915a5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35768286808f020880b7658701d2932"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ad35768286808f020880b7658701d2932">mirror</a> (<a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a> eAxis, int iChannel, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;oOffset, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;oSize)</td></tr>
<tr class="memdesc:ad35768286808f020880b7658701d2932"><td class="mdescLeft">&#160;</td><td class="mdescRight">in-place mirror operation on the given image rect (for internal use)  <a href="classicl_1_1core_1_1Img.html#ad35768286808f020880b7658701d2932">More...</a><br /></td></tr>
<tr class="separator:ad35768286808f020880b7658701d2932"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
operators</h2></td></tr>
<tr class="memitem:a3a72d40a19966a5768eb31bcc188a721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a3a72d40a19966a5768eb31bcc188a721">operator=</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;tSource)</td></tr>
<tr class="memdesc:a3a72d40a19966a5768eb31bcc188a721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign operator (flat copy of channels) WARNING: Violates const concept.  <a href="classicl_1_1core_1_1Img.html#a3a72d40a19966a5768eb31bcc188a721">More...</a><br /></td></tr>
<tr class="separator:a3a72d40a19966a5768eb31bcc188a721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fa509c57754dad16b48c7cac3a26c2"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#af9fa509c57754dad16b48c7cac3a26c2">operator()</a> (int iX, int iY, int iChannel)</td></tr>
<tr class="memdesc:af9fa509c57754dad16b48c7cac3a26c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">pixel access operator  <a href="classicl_1_1core_1_1Img.html#af9fa509c57754dad16b48c7cac3a26c2">More...</a><br /></td></tr>
<tr class="separator:af9fa509c57754dad16b48c7cac3a26c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fa0d7b4ba1eefac9724d4c057c80c8"><td class="memItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ac5fa0d7b4ba1eefac9724d4c057c80c8">operator()</a> (int iX, int iY, int iChannel) const</td></tr>
<tr class="memdesc:ac5fa0d7b4ba1eefac9724d4c057c80c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">as above, but const  <a href="classicl_1_1core_1_1Img.html#ac5fa0d7b4ba1eefac9724d4c057c80c8">More...</a><br /></td></tr>
<tr class="separator:ac5fa0d7b4ba1eefac9724d4c057c80c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04de36a29d2ae818cf70777656ef791c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1PixelRef.html">PixelRef</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a04de36a29d2ae818cf70777656ef791c">operator()</a> (int x, int y)</td></tr>
<tr class="memdesc:a04de36a29d2ae818cf70777656ef791c"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts a pixels channel values at once  <a href="classicl_1_1core_1_1Img.html#a04de36a29d2ae818cf70777656ef791c">More...</a><br /></td></tr>
<tr class="separator:a04de36a29d2ae818cf70777656ef791c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba249bd973e35eee4677fa8c14144fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1PixelRef.html">PixelRef</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a5ba249bd973e35eee4677fa8c14144fd">operator()</a> (int x, int y) const</td></tr>
<tr class="memdesc:a5ba249bd973e35eee4677fa8c14144fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">as above, but const  <a href="classicl_1_1core_1_1Img.html#a5ba249bd973e35eee4677fa8c14144fd">More...</a><br /></td></tr>
<tr class="separator:a5ba249bd973e35eee4677fa8c14144fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf72ca85a24756bbc422b2c93af0957b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#abf72ca85a24756bbc422b2c93af0957b">operator[]</a> (int channel)</td></tr>
<tr class="memdesc:abf72ca85a24756bbc422b2c93af0957b"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts an image channel  <a href="classicl_1_1core_1_1Img.html#abf72ca85a24756bbc422b2c93af0957b">More...</a><br /></td></tr>
<tr class="separator:abf72ca85a24756bbc422b2c93af0957b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9113122b2476ceb53266a8e2e310b22"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aa9113122b2476ceb53266a8e2e310b22">operator[]</a> (int channel) const</td></tr>
<tr class="memdesc:aa9113122b2476ceb53266a8e2e310b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts an image channel  <a href="classicl_1_1core_1_1Img.html#aa9113122b2476ceb53266a8e2e310b22">More...</a><br /></td></tr>
<tr class="separator:aa9113122b2476ceb53266a8e2e310b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882010c19abeb0e5663d583bdd687aff"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a882010c19abeb0e5663d583bdd687aff">subPixelNN</a> (float fX, float fY, int iChannel) const</td></tr>
<tr class="memdesc:a882010c19abeb0e5663d583bdd687aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">sub-pixel access using nearest neighbor interpolation  <a href="classicl_1_1core_1_1Img.html#a882010c19abeb0e5663d583bdd687aff">More...</a><br /></td></tr>
<tr class="separator:a882010c19abeb0e5663d583bdd687aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3135fed804f1e3d5d55069802c2eb03b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a3135fed804f1e3d5d55069802c2eb03b">subPixelLIN</a> (float fX, float fY, int iChannel) const</td></tr>
<tr class="memdesc:a3135fed804f1e3d5d55069802c2eb03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">sub-pixel access using linear interpolation  <a href="classicl_1_1core_1_1Img.html#a3135fed804f1e3d5d55069802c2eb03b">More...</a><br /></td></tr>
<tr class="separator:a3135fed804f1e3d5d55069802c2eb03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05faebaedbe7403274f88dddd58d292c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a05faebaedbe7403274f88dddd58d292c">subPixelRA</a> (float fX, float fY, float w, float h, int iChannel) const</td></tr>
<tr class="memdesc:a05faebaedbe7403274f88dddd58d292c"><td class="mdescLeft">&#160;</td><td class="mdescRight">sub-pixel access using region average interpolation  <a href="classicl_1_1core_1_1Img.html#a05faebaedbe7403274f88dddd58d292c">More...</a><br /></td></tr>
<tr class="separator:a05faebaedbe7403274f88dddd58d292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d595b1e23108a51dd1e08b51405588"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a17d595b1e23108a51dd1e08b51405588">subPixelRA</a> (const unsigned int xB, const unsigned int xE, const unsigned int yB, const unsigned int yE, const float xBMul, const float xEMul, const float BMul, const float yEMul, const Type *d, const unsigned int w) const</td></tr>
<tr class="separator:a17d595b1e23108a51dd1e08b51405588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed59562ce1c1051f144546f0ae81d546"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aed59562ce1c1051f144546f0ae81d546">operator()</a> (float fX, float fY, int iChannel, <a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> eMode) const</td></tr>
<tr class="memdesc:aed59562ce1c1051f144546f0ae81d546"><td class="mdescLeft">&#160;</td><td class="mdescRight">sub-pixel access operator, uses given interpolation method  <a href="classicl_1_1core_1_1Img.html#aed59562ce1c1051f144546f0ae81d546">More...</a><br /></td></tr>
<tr class="separator:aed59562ce1c1051f144546f0ae81d546"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
extractChannel functions</h2></td></tr>
<tr class="memitem:a3413e5b5b1d678a6953bcffc76598cf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a3413e5b5b1d678a6953bcffc76598cf3">extractDynMatrix</a> (int channel)</td></tr>
<tr class="memdesc:a3413e5b5b1d678a6953bcffc76598cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts given channel as DynMatrix&lt;Type&gt;  <a href="classicl_1_1core_1_1Img.html#a3413e5b5b1d678a6953bcffc76598cf3">More...</a><br /></td></tr>
<tr class="separator:a3413e5b5b1d678a6953bcffc76598cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae84b87ffa6cb6b327d04b0ae8d81d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a9ae84b87ffa6cb6b327d04b0ae8d81d1">extractDynMatrix</a> (int channel) const</td></tr>
<tr class="memdesc:a9ae84b87ffa6cb6b327d04b0ae8d81d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts given channel as DynMatrix&lt;Type&gt; const  <a href="classicl_1_1core_1_1Img.html#a9ae84b87ffa6cb6b327d04b0ae8d81d1">More...</a><br /></td></tr>
<tr class="separator:a9ae84b87ffa6cb6b327d04b0ae8d81d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b35475c8518c1415441e17054a77e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a60b35475c8518c1415441e17054a77e3">extractChannels</a> (<a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt; Type &gt; *dst)</td></tr>
<tr class="memdesc:a60b35475c8518c1415441e17054a77e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts all image channels at once into given channel pointer  <a href="classicl_1_1core_1_1Img.html#a60b35475c8518c1415441e17054a77e3">More...</a><br /></td></tr>
<tr class="separator:a60b35475c8518c1415441e17054a77e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c48d7b5b089d2f29450814bb69abe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a47c48d7b5b089d2f29450814bb69abe3">extractChannels</a> (<a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt; Type &gt; *dst) const</td></tr>
<tr class="memdesc:a47c48d7b5b089d2f29450814bb69abe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is forbidden, it produces an error message  <a href="classicl_1_1core_1_1Img.html#a47c48d7b5b089d2f29450814bb69abe3">More...</a><br /></td></tr>
<tr class="separator:a47c48d7b5b089d2f29450814bb69abe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb019a8879009bc2932b5231dce98f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#acdb019a8879009bc2932b5231dce98f5">extractChannels</a> (const <a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt; Type &gt; *dst) const</td></tr>
<tr class="memdesc:acdb019a8879009bc2932b5231dce98f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts all image channels at once into given channel pointer (const)  <a href="classicl_1_1core_1_1Img.html#acdb019a8879009bc2932b5231dce98f5">More...</a><br /></td></tr>
<tr class="separator:acdb019a8879009bc2932b5231dce98f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a9f7c2bd1ad22a3aa676dde066dc9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a95a9f7c2bd1ad22a3aa676dde066dc9a">extractPointers</a> (Type **dst)</td></tr>
<tr class="memdesc:a95a9f7c2bd1ad22a3aa676dde066dc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts all data pointers into given destination pointer  <a href="classicl_1_1core_1_1Img.html#a95a9f7c2bd1ad22a3aa676dde066dc9a">More...</a><br /></td></tr>
<tr class="separator:a95a9f7c2bd1ad22a3aa676dde066dc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f7d706268dc292928cf73b21d3c592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ab5f7d706268dc292928cf73b21d3c592">extractPointers</a> (Type **dst) const</td></tr>
<tr class="memdesc:ab5f7d706268dc292928cf73b21d3c592"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function is forbidden, it produces an error message  <a href="classicl_1_1core_1_1Img.html#ab5f7d706268dc292928cf73b21d3c592">More...</a><br /></td></tr>
<tr class="separator:ab5f7d706268dc292928cf73b21d3c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a35d6acb570e8139b0768a46abf6c73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a5a35d6acb570e8139b0768a46abf6c73">extractPointers</a> (const Type **dst) const</td></tr>
<tr class="memdesc:a5a35d6acb570e8139b0768a46abf6c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts all data pointers into given destination pointer (const)  <a href="classicl_1_1core_1_1Img.html#a5a35d6acb570e8139b0768a46abf6c73">More...</a><br /></td></tr>
<tr class="separator:a5a35d6acb570e8139b0768a46abf6c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
shallow/deepCopy functions</h2></td></tr>
<tr class="memitem:a54e1fedb8b8ef265a04be9d55e2ff11c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a54e1fedb8b8ef265a04be9d55e2ff11c">shallowCopy</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi, const std::vector&lt; int &gt; &amp;channelIndices, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, <a class="el" href="classicl_1_1utils_1_1Time.html">utils::Time</a> time=<a class="el" href="classicl_1_1utils_1_1Time.html#ace3f64d086f815af887221fd9b186996">utils::Time::null</a>, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=NULL)</td></tr>
<tr class="separator:a54e1fedb8b8ef265a04be9d55e2ff11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c5df2fd4b532bc9ecc63e2e5a3d16f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a05c5df2fd4b532bc9ecc63e2e5a3d16f">shallowCopy</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi, const std::vector&lt; int &gt; &amp;channelIndices, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, <a class="el" href="classicl_1_1utils_1_1Time.html">utils::Time</a> time=<a class="el" href="classicl_1_1utils_1_1Time.html#ace3f64d086f815af887221fd9b186996">utils::Time::null</a>) const</td></tr>
<tr class="separator:a05c5df2fd4b532bc9ecc63e2e5a3d16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e156f615d3e151bae8733f9cc07ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ae9e156f615d3e151bae8733f9cc07ac6">reinterpretChannels</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> newFmt, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *poDst=NULL)</td></tr>
<tr class="memdesc:ae9e156f615d3e151bae8733f9cc07ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of this image with a new format.  <a href="classicl_1_1core_1_1Img.html#ae9e156f615d3e151bae8733f9cc07ac6">More...</a><br /></td></tr>
<tr class="separator:ae9e156f615d3e151bae8733f9cc07ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75818ee8fc5fa4efafc168bceeed9e95"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a75818ee8fc5fa4efafc168bceeed9e95">reinterpretChannels</a> (<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> newFmt)</td></tr>
<tr class="memdesc:a75818ee8fc5fa4efafc168bceeed9e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of this image with a new format (const version)  <a href="classicl_1_1core_1_1Img.html#a75818ee8fc5fa4efafc168bceeed9e95">More...</a><br /></td></tr>
<tr class="separator:a75818ee8fc5fa4efafc168bceeed9e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c52a66d446dba08c5e579a189c5d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a62c52a66d446dba08c5e579a189c5d4c">shallowCopy</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *poDst=NULL)</td></tr>
<tr class="memdesc:a62c52a66d446dba08c5e579a189c5d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of the image.  <a href="classicl_1_1core_1_1Img.html#a62c52a66d446dba08c5e579a189c5d4c">More...</a><br /></td></tr>
<tr class="separator:a62c52a66d446dba08c5e579a189c5d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647aaf316816c5ce3c2d864af1ed5bde"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a647aaf316816c5ce3c2d864af1ed5bde">shallowCopy</a> (const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi) const</td></tr>
<tr class="memdesc:a647aaf316816c5ce3c2d864af1ed5bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of a const source image.  <a href="classicl_1_1core_1_1Img.html#a647aaf316816c5ce3c2d864af1ed5bde">More...</a><br /></td></tr>
<tr class="separator:a647aaf316816c5ce3c2d864af1ed5bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6cdbd98b48e1e33dc2ebb8a0dfcc91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a8b6cdbd98b48e1e33dc2ebb8a0dfcc91">selectChannels</a> (const std::vector&lt; int &gt; &amp;channelIndices, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *poDst=0)</td></tr>
<tr class="memdesc:a8b6cdbd98b48e1e33dc2ebb8a0dfcc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of selected channels of an image.  <a href="classicl_1_1core_1_1Img.html#a8b6cdbd98b48e1e33dc2ebb8a0dfcc91">More...</a><br /></td></tr>
<tr class="separator:a8b6cdbd98b48e1e33dc2ebb8a0dfcc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b77c10cf3bcd9cca01b87d8dcae892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#af1b77c10cf3bcd9cca01b87d8dcae892">selectChannel</a> (int channelIndex, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *poDst=0)</td></tr>
<tr class="memdesc:af1b77c10cf3bcd9cca01b87d8dcae892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of a single image channel of an image.  <a href="classicl_1_1core_1_1Img.html#af1b77c10cf3bcd9cca01b87d8dcae892">More...</a><br /></td></tr>
<tr class="separator:af1b77c10cf3bcd9cca01b87d8dcae892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a6462b385b80e53f59613feae87adc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aa6a6462b385b80e53f59613feae87adc">selectChannels</a> (const std::vector&lt; int &gt; &amp;channelIndices) const</td></tr>
<tr class="memdesc:aa6a6462b385b80e53f59613feae87adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of selected channels of a const image.  <a href="classicl_1_1core_1_1Img.html#aa6a6462b385b80e53f59613feae87adc">More...</a><br /></td></tr>
<tr class="separator:aa6a6462b385b80e53f59613feae87adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee63b3ff4863e9e640decf8dc7d74df"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a3ee63b3ff4863e9e640decf8dc7d74df">selectChannel</a> (int channelIndex) const</td></tr>
<tr class="memdesc:a3ee63b3ff4863e9e640decf8dc7d74df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy of a single image channel of a const image.  <a href="classicl_1_1core_1_1Img.html#a3ee63b3ff4863e9e640decf8dc7d74df">More...</a><br /></td></tr>
<tr class="separator:a3ee63b3ff4863e9e640decf8dc7d74df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d412faa3854d765ff2ee18b3478bbd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a93d412faa3854d765ff2ee18b3478bbd">deepCopy</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0) const</td></tr>
<tr class="memdesc:a93d412faa3854d765ff2ee18b3478bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a deep copy of an image.  <a href="classicl_1_1core_1_1Img.html#a93d412faa3854d765ff2ee18b3478bbd">More...</a><br /></td></tr>
<tr class="separator:a93d412faa3854d765ff2ee18b3478bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259fc616dde60b365938f3d24fb78636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a259fc616dde60b365938f3d24fb78636">deepCopy</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *poDst) const</td></tr>
<tr class="memdesc:a259fc616dde60b365938f3d24fb78636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a deep copy of an image.  <a href="classicl_1_1core_1_1Img.html#a259fc616dde60b365938f3d24fb78636">More...</a><br /></td></tr>
<tr class="separator:a259fc616dde60b365938f3d24fb78636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6317f8c04cc12fb7ee2366bfd05117"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a2d6317f8c04cc12fb7ee2366bfd05117">deepCopyROI</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0) const</td></tr>
<tr class="memdesc:a2d6317f8c04cc12fb7ee2366bfd05117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a deep copy of an images ROI.  <a href="classicl_1_1core_1_1Img.html#a2d6317f8c04cc12fb7ee2366bfd05117">More...</a><br /></td></tr>
<tr class="separator:a2d6317f8c04cc12fb7ee2366bfd05117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d1173a1661a8b39d55d3552f121359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a51d1173a1661a8b39d55d3552f121359">deepCopyROI</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *poDst) const</td></tr>
<tr class="memdesc:a51d1173a1661a8b39d55d3552f121359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a deep copy of an images ROI.  <a href="classicl_1_1core_1_1Img.html#a51d1173a1661a8b39d55d3552f121359">More...</a><br /></td></tr>
<tr class="separator:a51d1173a1661a8b39d55d3552f121359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04acaf11df91b1a4a66ba9855daeb8c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#af04acaf11df91b1a4a66ba9855daeb8c">scaledCopy</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;newSize, <a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> eScaleMode=<a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a>) const</td></tr>
<tr class="memdesc:af04acaf11df91b1a4a66ba9855daeb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a scaled copy of this image  <a href="classicl_1_1core_1_1Img.html#af04acaf11df91b1a4a66ba9855daeb8c">More...</a><br /></td></tr>
<tr class="separator:af04acaf11df91b1a4a66ba9855daeb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc010d3e2117664968cd13248376e93"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#acdc010d3e2117664968cd13248376e93">scaledCopy</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0, <a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> eScaleMode=<a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a>) const</td></tr>
<tr class="memdesc:acdc010d3e2117664968cd13248376e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a scaled copy of this image  <a href="classicl_1_1core_1_1Img.html#acdc010d3e2117664968cd13248376e93">More...</a><br /></td></tr>
<tr class="separator:acdc010d3e2117664968cd13248376e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad884126bd4c7ef3a8c2cbd7ee6c197b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ad884126bd4c7ef3a8c2cbd7ee6c197b2">scaledCopy</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *poDst, <a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> eScaleMode=<a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a>) const</td></tr>
<tr class="memdesc:ad884126bd4c7ef3a8c2cbd7ee6c197b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a scaled copy of this image  <a href="classicl_1_1core_1_1Img.html#ad884126bd4c7ef3a8c2cbd7ee6c197b2">More...</a><br /></td></tr>
<tr class="separator:ad884126bd4c7ef3a8c2cbd7ee6c197b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd806b9fc0f0bb3923f58fb0e0bbf408"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#abd806b9fc0f0bb3923f58fb0e0bbf408">scaledCopyROI</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;newSize, <a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> eScaleMode=<a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a>) const</td></tr>
<tr class="memdesc:abd806b9fc0f0bb3923f58fb0e0bbf408"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a scaled copy of an images ROI with given size  <a href="classicl_1_1core_1_1Img.html#abd806b9fc0f0bb3923f58fb0e0bbf408">More...</a><br /></td></tr>
<tr class="separator:abd806b9fc0f0bb3923f58fb0e0bbf408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0720172d5824368f0158465eadf02e31"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a0720172d5824368f0158465eadf02e31">scaledCopyROI</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0, <a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> eScaleMode=<a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a>) const</td></tr>
<tr class="memdesc:a0720172d5824368f0158465eadf02e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a scaled copy of an images ROI with given destination image  <a href="classicl_1_1core_1_1Img.html#a0720172d5824368f0158465eadf02e31">More...</a><br /></td></tr>
<tr class="separator:a0720172d5824368f0158465eadf02e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3162639569508c3b4c5c7ce3bd0c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aee3162639569508c3b4c5c7ce3bd0c8f">scaledCopyROI</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *poDst, <a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> eScaleMode=<a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a>) const</td></tr>
<tr class="memdesc:aee3162639569508c3b4c5c7ce3bd0c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a scaled copy of this images ROI  <a href="classicl_1_1core_1_1Img.html#aee3162639569508c3b4c5c7ce3bd0c8f">More...</a><br /></td></tr>
<tr class="separator:aee3162639569508c3b4c5c7ce3bd0c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
organization and channel management</h2></td></tr>
<tr class="memitem:ae7541625a11c5208e0ade388d534c18d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ae7541625a11c5208e0ade388d534c18d">detach</a> (int iIndex=-1)</td></tr>
<tr class="memdesc:ae7541625a11c5208e0ade388d534c18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the image channels inside the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> independent from other <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a>.  <a href="classicl_1_1core_1_1Img.html#ae7541625a11c5208e0ade388d534c18d">More...</a><br /></td></tr>
<tr class="separator:ae7541625a11c5208e0ade388d534c18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4129ac9e0f9c554e274505919ef5536c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a4129ac9e0f9c554e274505919ef5536c">detached</a> () const</td></tr>
<tr class="memdesc:a4129ac9e0f9c554e274505919ef5536c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method, that returns a detached version of this image.  <a href="classicl_1_1core_1_1Img.html#a4129ac9e0f9c554e274505919ef5536c">More...</a><br /></td></tr>
<tr class="separator:a4129ac9e0f9c554e274505919ef5536c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aafa9033a79cc690363be696eee8c68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a9aafa9033a79cc690363be696eee8c68">removeChannel</a> (int iChannel)</td></tr>
<tr class="memdesc:a9aafa9033a79cc690363be696eee8c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a specified channel.  <a href="classicl_1_1core_1_1Img.html#a9aafa9033a79cc690363be696eee8c68">More...</a><br /></td></tr>
<tr class="separator:a9aafa9033a79cc690363be696eee8c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7286e5de8d5d30a922939cedddd829"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a1f7286e5de8d5d30a922939cedddd829">append</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *src, int iChannel=-1)</td></tr>
<tr class="memdesc:a1f7286e5de8d5d30a922939cedddd829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append channels of external <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> to the existing <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a>.  <a href="classicl_1_1core_1_1Img.html#a1f7286e5de8d5d30a922939cedddd829">More...</a><br /></td></tr>
<tr class="separator:a1f7286e5de8d5d30a922939cedddd829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682ea3c863b76504947caf18d73ffec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a682ea3c863b76504947caf18d73ffec9">append</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *src, const std::vector&lt; int &gt; &amp;vChannels)</td></tr>
<tr class="memdesc:a682ea3c863b76504947caf18d73ffec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a set of selected channels from source image.  <a href="classicl_1_1core_1_1Img.html#a682ea3c863b76504947caf18d73ffec9">More...</a><br /></td></tr>
<tr class="separator:a682ea3c863b76504947caf18d73ffec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef7c48b005b01188994b6f29e02a8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a3ef7c48b005b01188994b6f29e02a8a2">extractChannelImg</a> (int index)</td></tr>
<tr class="memdesc:a3ef7c48b005b01188994b6f29e02a8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new image with a shallow copied single channel of this image.  <a href="classicl_1_1core_1_1Img.html#a3ef7c48b005b01188994b6f29e02a8a2">More...</a><br /></td></tr>
<tr class="separator:a3ef7c48b005b01188994b6f29e02a8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11d91e621dfb3eda82b0039559b82ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#af11d91e621dfb3eda82b0039559b82ce">extractChannelImg</a> (int index) const</td></tr>
<tr class="memdesc:af11d91e621dfb3eda82b0039559b82ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new image with a shallow copied single channel of this image.  <a href="classicl_1_1core_1_1Img.html#af11d91e621dfb3eda82b0039559b82ce">More...</a><br /></td></tr>
<tr class="separator:af11d91e621dfb3eda82b0039559b82ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f7b0d5d873dce5b4124892d1c54f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aa3f7b0d5d873dce5b4124892d1c54f15">extractChannelImg</a> (const std::vector&lt; int &gt; &amp;indices)</td></tr>
<tr class="memdesc:aa3f7b0d5d873dce5b4124892d1c54f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new image with shallow copied single channels of this image.  <a href="classicl_1_1core_1_1Img.html#aa3f7b0d5d873dce5b4124892d1c54f15">More...</a><br /></td></tr>
<tr class="separator:aa3f7b0d5d873dce5b4124892d1c54f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af617f7887e7caca2091653cb6f4fa57a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#af617f7887e7caca2091653cb6f4fa57a">extractChannelImg</a> (const std::vector&lt; int &gt; &amp;indices) const</td></tr>
<tr class="memdesc:af617f7887e7caca2091653cb6f4fa57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new image with shallow copied single channels of this image.  <a href="classicl_1_1core_1_1Img.html#af617f7887e7caca2091653cb6f4fa57a">More...</a><br /></td></tr>
<tr class="separator:af617f7887e7caca2091653cb6f4fa57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41db2a5b8f3f923e5bdc5dc1833b2fae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a41db2a5b8f3f923e5bdc5dc1833b2fae">swapChannels</a> (int iIndexA, int iIndexB)</td></tr>
<tr class="memdesc:a41db2a5b8f3f923e5bdc5dc1833b2fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap channel A and B.  <a href="classicl_1_1core_1_1Img.html#a41db2a5b8f3f923e5bdc5dc1833b2fae">More...</a><br /></td></tr>
<tr class="separator:a41db2a5b8f3f923e5bdc5dc1833b2fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28eecb397335bbdb760dd554ab2834bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a28eecb397335bbdb760dd554ab2834bd">replaceChannel</a> (int iThisIndex, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *poOtherImg, int iOtherIndex)</td></tr>
<tr class="memdesc:a28eecb397335bbdb760dd554ab2834bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the channel A of this image with the channel B another image.  <a href="classicl_1_1core_1_1Img.html#a28eecb397335bbdb760dd554ab2834bd">More...</a><br /></td></tr>
<tr class="separator:a28eecb397335bbdb760dd554ab2834bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229f911ae0d2e3f99ddb72a11c86e2d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a229f911ae0d2e3f99ddb72a11c86e2d3">setChannels</a> (int iNewNumChannels)</td></tr>
<tr class="memdesc:a229f911ae0d2e3f99ddb72a11c86e2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the channel count to a new value  <a href="classicl_1_1core_1_1Img.html#a229f911ae0d2e3f99ddb72a11c86e2d3">More...</a><br /></td></tr>
<tr class="separator:a229f911ae0d2e3f99ddb72a11c86e2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94731e22c8c728c5468573d4ec00d75e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a94731e22c8c728c5468573d4ec00d75e">setSize</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;s)</td></tr>
<tr class="memdesc:a94731e22c8c728c5468573d4ec00d75e"><td class="mdescLeft">&#160;</td><td class="mdescRight">resizes the image to new values  <a href="classicl_1_1core_1_1Img.html#a94731e22c8c728c5468573d4ec00d75e">More...</a><br /></td></tr>
<tr class="separator:a94731e22c8c728c5468573d4ec00d75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
getter functions</h2></td></tr>
<tr class="memitem:a49f453571d6ad790cb50016717907aa4"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a49f453571d6ad790cb50016717907aa4">getMax</a> (int iChannel, <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *coords=0) const</td></tr>
<tr class="memdesc:a49f453571d6ad790cb50016717907aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max pixel value of channel iChannel within ROI.  <a href="classicl_1_1core_1_1Img.html#a49f453571d6ad790cb50016717907aa4">More...</a><br /></td></tr>
<tr class="separator:a49f453571d6ad790cb50016717907aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30e405f529fff38e5110dbd2082819e"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#af30e405f529fff38e5110dbd2082819e">getMin</a> (int iChannel, <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *coords=0) const</td></tr>
<tr class="memdesc:af30e405f529fff38e5110dbd2082819e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min pixel value of channel iChannel within ROI.  <a href="classicl_1_1core_1_1Img.html#af30e405f529fff38e5110dbd2082819e">More...</a><br /></td></tr>
<tr class="separator:af30e405f529fff38e5110dbd2082819e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2eb464e72cecdf253fbf682ee5f690f"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ae2eb464e72cecdf253fbf682ee5f690f">getMin</a> () const</td></tr>
<tr class="memdesc:ae2eb464e72cecdf253fbf682ee5f690f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return maximal pixel value over all channels (restricted to ROI)  <a href="classicl_1_1core_1_1Img.html#ae2eb464e72cecdf253fbf682ee5f690f">More...</a><br /></td></tr>
<tr class="separator:ae2eb464e72cecdf253fbf682ee5f690f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37104b77fc3432b1660f1f717b254d5e"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a37104b77fc3432b1660f1f717b254d5e">getMax</a> () const</td></tr>
<tr class="memdesc:a37104b77fc3432b1660f1f717b254d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return minimal pixel value over all channels (restricted to ROI)  <a href="classicl_1_1core_1_1Img.html#a37104b77fc3432b1660f1f717b254d5e">More...</a><br /></td></tr>
<tr class="separator:a37104b77fc3432b1660f1f717b254d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65171125716590787772fbeb91836932"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a65171125716590787772fbeb91836932">getMinMax</a> (int iChannel, <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *minCoords=0, <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *maxCoords=0) const</td></tr>
<tr class="memdesc:a65171125716590787772fbeb91836932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min and max pixel values of channel iChannel within ROI.  <a href="classicl_1_1core_1_1Img.html#a65171125716590787772fbeb91836932">More...</a><br /></td></tr>
<tr class="separator:a65171125716590787772fbeb91836932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab4459235a90041a61ef4f3184cdfbb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#abab4459235a90041a61ef4f3184cdfbb">getMinMax</a> () const</td></tr>
<tr class="memdesc:abab4459235a90041a61ef4f3184cdfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">return minimal and maximal pixel values over all channels (restricted to ROI)  <a href="classicl_1_1core_1_1Img.html#abab4459235a90041a61ef4f3184cdfbb">More...</a><br /></td></tr>
<tr class="separator:abab4459235a90041a61ef4f3184cdfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659dca05fde0cb4f6f5fec2c0bba60b3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a659dca05fde0cb4f6f5fec2c0bba60b3">getLineStep</a> () const</td></tr>
<tr class="memdesc:a659dca05fde0cb4f6f5fec2c0bba60b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the width of an image line in bytes.  <a href="classicl_1_1core_1_1Img.html#a659dca05fde0cb4f6f5fec2c0bba60b3">More...</a><br /></td></tr>
<tr class="separator:a659dca05fde0cb4f6f5fec2c0bba60b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e09f24ce08f3618cd9c1342a0a47a1"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aa5e09f24ce08f3618cd9c1342a0a47a1">getData</a> (int iChannel)</td></tr>
<tr class="memdesc:aa5e09f24ce08f3618cd9c1342a0a47a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a Type save data data pointer to the channel data origin  <a href="classicl_1_1core_1_1Img.html#aa5e09f24ce08f3618cd9c1342a0a47a1">More...</a><br /></td></tr>
<tr class="separator:aa5e09f24ce08f3618cd9c1342a0a47a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e929262ce00f0d8c0dbb5d552f86958"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a0e929262ce00f0d8c0dbb5d552f86958">getData</a> (int iChannel) const</td></tr>
<tr class="memdesc:a0e929262ce00f0d8c0dbb5d552f86958"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a Type save data data pointer to the channel data origin (const)  <a href="classicl_1_1core_1_1Img.html#a0e929262ce00f0d8c0dbb5d552f86958">More...</a><br /></td></tr>
<tr class="separator:a0e929262ce00f0d8c0dbb5d552f86958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa60c3bbc45f7682ed98af276b1c89a"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a9fa60c3bbc45f7682ed98af276b1c89a">getROIData</a> (int iChannel)</td></tr>
<tr class="memdesc:a9fa60c3bbc45f7682ed98af276b1c89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a Type save data pointer to the first pixel within the images roi  <a href="classicl_1_1core_1_1Img.html#a9fa60c3bbc45f7682ed98af276b1c89a">More...</a><br /></td></tr>
<tr class="separator:a9fa60c3bbc45f7682ed98af276b1c89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea20e1d52bf1e4a40dfc9b8e76d2599"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a7ea20e1d52bf1e4a40dfc9b8e76d2599">getROIData</a> (int iChannel) const</td></tr>
<tr class="memdesc:a7ea20e1d52bf1e4a40dfc9b8e76d2599"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a Type save data pointer to the first pixel within the images roi (const)  <a href="classicl_1_1core_1_1Img.html#a7ea20e1d52bf1e4a40dfc9b8e76d2599">More...</a><br /></td></tr>
<tr class="separator:a7ea20e1d52bf1e4a40dfc9b8e76d2599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b3b84c143a4acb7655b30e739435a9"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ae5b3b84c143a4acb7655b30e739435a9">getROIData</a> (int iChannel, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;p)</td></tr>
<tr class="memdesc:ae5b3b84c143a4acb7655b30e739435a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the data pointer to a pixel with defined offset  <a href="classicl_1_1core_1_1Img.html#ae5b3b84c143a4acb7655b30e739435a9">More...</a><br /></td></tr>
<tr class="separator:ae5b3b84c143a4acb7655b30e739435a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3d7b84016401516224d835a4cc6453"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a3f3d7b84016401516224d835a4cc6453">getROIData</a> (int iChannel, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;p) const</td></tr>
<tr class="memdesc:a3f3d7b84016401516224d835a4cc6453"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the data pointer to a pixel with defined offset (const)  <a href="classicl_1_1core_1_1Img.html#a3f3d7b84016401516224d835a4cc6453">More...</a><br /></td></tr>
<tr class="separator:a3f3d7b84016401516224d835a4cc6453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6559fc4730ad4fe2a8671db6b722b1c"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aa6559fc4730ad4fe2a8671db6b722b1c">getDataPtr</a> (int iChannel)</td></tr>
<tr class="memdesc:aa6559fc4730ad4fe2a8671db6b722b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the raw- data pointer of an image channel  <a href="classicl_1_1core_1_1Img.html#aa6559fc4730ad4fe2a8671db6b722b1c">More...</a><br /></td></tr>
<tr class="separator:aa6559fc4730ad4fe2a8671db6b722b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9a4a36cbaf196d960eebfc93e8c9a5"><td class="memItemLeft" align="right" valign="top">virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#abc9a4a36cbaf196d960eebfc93e8c9a5">getDataPtr</a> (int iChannel) const</td></tr>
<tr class="memdesc:abc9a4a36cbaf196d960eebfc93e8c9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the raw- data pointer of an image channel (const)  <a href="classicl_1_1core_1_1Img.html#abc9a4a36cbaf196d960eebfc93e8c9a5">More...</a><br /></td></tr>
<tr class="separator:abc9a4a36cbaf196d960eebfc93e8c9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
basic in-place image manipulations</h2></td></tr>
<tr class="memitem:af8df2ce956d4256a608cadd143078fff"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:af8df2ce956d4256a608cadd143078fff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#af8df2ce956d4256a608cadd143078fff">forEach_C</a> (UnaryFunction f, int channel)</td></tr>
<tr class="memdesc:af8df2ce956d4256a608cadd143078fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL based "for_each" implementations applying an Unary function on each ROI-pixel of given channel.  <a href="classicl_1_1core_1_1Img.html#af8df2ce956d4256a608cadd143078fff">More...</a><br /></td></tr>
<tr class="separator:af8df2ce956d4256a608cadd143078fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae2c82990ee22f5afffacb55ec6e154"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a6ae2c82990ee22f5afffacb55ec6e154"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a6ae2c82990ee22f5afffacb55ec6e154">forEach</a> (UnaryFunction f)</td></tr>
<tr class="memdesc:a6ae2c82990ee22f5afffacb55ec6e154"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL based "for_each" implementations applying an Unary function on each ROI-pixel.  <a href="classicl_1_1core_1_1Img.html#a6ae2c82990ee22f5afffacb55ec6e154">More...</a><br /></td></tr>
<tr class="separator:a6ae2c82990ee22f5afffacb55ec6e154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304bef854c2721778839a13285ab7682"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction , class dstType &gt; </td></tr>
<tr class="memitem:a304bef854c2721778839a13285ab7682"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a304bef854c2721778839a13285ab7682">transform_C</a> (UnaryFunction f, int srcChannel, int dstChannel, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;dst) const</td></tr>
<tr class="memdesc:a304bef854c2721778839a13285ab7682"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL based "transform" implementation applying an Unary function on ROI-pixles with given destination image.  <a href="classicl_1_1core_1_1Img.html#a304bef854c2721778839a13285ab7682">More...</a><br /></td></tr>
<tr class="separator:a304bef854c2721778839a13285ab7682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f940015b91291e7335c79cdaac4860"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction , class dstType &gt; </td></tr>
<tr class="memitem:a41f940015b91291e7335c79cdaac4860"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a41f940015b91291e7335c79cdaac4860">transform</a> (UnaryFunction f, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;dst) const</td></tr>
<tr class="memdesc:a41f940015b91291e7335c79cdaac4860"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL based "transform" implementation applying an Unary function on ROI-pixles with given destination image.  <a href="classicl_1_1core_1_1Img.html#a41f940015b91291e7335c79cdaac4860">More...</a><br /></td></tr>
<tr class="separator:a41f940015b91291e7335c79cdaac4860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8153c70ec0232aaf8c98ddfef11ffd"><td class="memTemplParams" colspan="2">template&lt;typename BinaryFunction , class dstType , class otherSrcType &gt; </td></tr>
<tr class="memitem:add8153c70ec0232aaf8c98ddfef11ffd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#add8153c70ec0232aaf8c98ddfef11ffd">combine_C</a> (BinaryFunction f, int thisChannel, int otherSrcChannel, int dstChannel, const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; otherSrcType &gt; &amp;otherSrc, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;dst) const</td></tr>
<tr class="memdesc:add8153c70ec0232aaf8c98ddfef11ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-based "transform function combining two images pixel-wise into a given destination image (with ROI support)".  <a href="classicl_1_1core_1_1Img.html#add8153c70ec0232aaf8c98ddfef11ffd">More...</a><br /></td></tr>
<tr class="separator:add8153c70ec0232aaf8c98ddfef11ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25474639a3e70b65f22f1bac48eaad89"><td class="memTemplParams" colspan="2">template&lt;typename BinaryFunction , class dstType , class otherSrcType &gt; </td></tr>
<tr class="memitem:a25474639a3e70b65f22f1bac48eaad89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a25474639a3e70b65f22f1bac48eaad89">combine</a> (BinaryFunction f, const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; otherSrcType &gt; &amp;otherSrc, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;dst) const</td></tr>
<tr class="memdesc:a25474639a3e70b65f22f1bac48eaad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL-based "transform function combining two images pixel-wise into a given destination image (with ROI support)".  <a href="classicl_1_1core_1_1Img.html#a25474639a3e70b65f22f1bac48eaad89">More...</a><br /></td></tr>
<tr class="separator:a25474639a3e70b65f22f1bac48eaad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772c0b531c86e05b5c4799c01c6b0c2b"><td class="memTemplParams" colspan="2">template&lt;typename Tdst , int Nthis, int Ndst, typename ReduceFunc &gt; </td></tr>
<tr class="memitem:a772c0b531c86e05b5c4799c01c6b0c2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a772c0b531c86e05b5c4799c01c6b0c2b">reduce_channels</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Tdst &gt; &amp;dst, ReduceFunc reduce) const</td></tr>
<tr class="memdesc:a772c0b531c86e05b5c4799c01c6b0c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for combining image channels into another image.  <a href="classicl_1_1core_1_1Img.html#a772c0b531c86e05b5c4799c01c6b0c2b">More...</a><br /></td></tr>
<tr class="separator:a772c0b531c86e05b5c4799c01c6b0c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7e0fc3af37c3b06185f910faf93a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a9c7e0fc3af37c3b06185f910faf93a33">lut</a> (const Type *lut, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *dst=0, int bits=8) const</td></tr>
<tr class="memdesc:a9c7e0fc3af37c3b06185f910faf93a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">applys a lookup function using the given lookup table  <a href="classicl_1_1core_1_1Img.html#a9c7e0fc3af37c3b06185f910faf93a33">More...</a><br /></td></tr>
<tr class="separator:a9c7e0fc3af37c3b06185f910faf93a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76b4659e383b4bbeb72dc755aff2d61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">scale</a> (const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;s, <a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a> eScaleMode=<a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a>)</td></tr>
<tr class="memdesc:ae76b4659e383b4bbeb72dc755aff2d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform an in-place resize of the image (keeping the data)  <a href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">More...</a><br /></td></tr>
<tr class="separator:ae76b4659e383b4bbeb72dc755aff2d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d399a33ae609720e9641d53a493fc2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a85d399a33ae609720e9641d53a493fc2">mirror</a> (<a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a> eAxis, bool bOnlyROI=false)</td></tr>
<tr class="memdesc:a85d399a33ae609720e9641d53a493fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform an in-place mirror operation on the image  <a href="classicl_1_1core_1_1Img.html#a85d399a33ae609720e9641d53a493fc2">More...</a><br /></td></tr>
<tr class="separator:a85d399a33ae609720e9641d53a493fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da0eda1f6dddd31381b65c794a37983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a1da0eda1f6dddd31381b65c794a37983">clear</a> (int iChannel=-1, Type tValue=0, bool bROIOnly=true)</td></tr>
<tr class="memdesc:a1da0eda1f6dddd31381b65c794a37983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the ROI pixels of one or all channels to a specified value.  <a href="classicl_1_1core_1_1Img.html#a1da0eda1f6dddd31381b65c794a37983">More...</a><br /></td></tr>
<tr class="separator:a1da0eda1f6dddd31381b65c794a37983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0f90b207c4ce99b9f18f9f5d165dde"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a0f90b207c4ce99b9f18f9f5d165dde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a6a0f90b207c4ce99b9f18f9f5d165dde">fill</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a6a0f90b207c4ce99b9f18f9f5d165dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">fills the whole image with given source type value  <a href="classicl_1_1core_1_1Img.html#a6a0f90b207c4ce99b9f18f9f5d165dde">More...</a><br /></td></tr>
<tr class="separator:a6a0f90b207c4ce99b9f18f9f5d165dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e61d7766379f4135b4d5736047bf49"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a58e61d7766379f4135b4d5736047bf49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a58e61d7766379f4135b4d5736047bf49">fillChannel</a> (int channel, const T &amp;value)</td></tr>
<tr class="memdesc:a58e61d7766379f4135b4d5736047bf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">fills the given channel with given source type value  <a href="classicl_1_1core_1_1Img.html#a58e61d7766379f4135b4d5736047bf49">More...</a><br /></td></tr>
<tr class="separator:a58e61d7766379f4135b4d5736047bf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12065fb47f1b2198b811ce88abe805a6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a12065fb47f1b2198b811ce88abe805a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a12065fb47f1b2198b811ce88abe805a6">fillROI</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a12065fb47f1b2198b811ce88abe805a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">fills the whole image with given source type value  <a href="classicl_1_1core_1_1Img.html#a12065fb47f1b2198b811ce88abe805a6">More...</a><br /></td></tr>
<tr class="separator:a12065fb47f1b2198b811ce88abe805a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e72c186b1386e47c909d286cfa36ca"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a44e72c186b1386e47c909d286cfa36ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a44e72c186b1386e47c909d286cfa36ca">fillChannelROI</a> (int channel, const T &amp;value)</td></tr>
<tr class="memdesc:a44e72c186b1386e47c909d286cfa36ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">fills the given channel's with given source type value  <a href="classicl_1_1core_1_1Img.html#a44e72c186b1386e47c909d286cfa36ca">More...</a><br /></td></tr>
<tr class="separator:a44e72c186b1386e47c909d286cfa36ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6c326bf9622dbb8454bb002ecd84e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#abd6c326bf9622dbb8454bb002ecd84e2">normalizeAllChannels</a> (const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:abd6c326bf9622dbb8454bb002ecd84e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the channel min/ max range to the new min, max range.  <a href="classicl_1_1core_1_1Img.html#abd6c326bf9622dbb8454bb002ecd84e2">More...</a><br /></td></tr>
<tr class="separator:abd6c326bf9622dbb8454bb002ecd84e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add40399fcecf64cde67ead552dce7695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#add40399fcecf64cde67ead552dce7695">normalizeChannel</a> (int iChannel, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;srcRange, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:add40399fcecf64cde67ead552dce7695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the channel from a given min/max range to the new range.  <a href="classicl_1_1core_1_1Img.html#add40399fcecf64cde67ead552dce7695">More...</a><br /></td></tr>
<tr class="separator:add40399fcecf64cde67ead552dce7695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c44a202ca8a55d71253bce4884c19fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a3c44a202ca8a55d71253bce4884c19fa">normalizeChannel</a> (int iChannel, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:a3c44a202ca8a55d71253bce4884c19fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the channel from a given min/max range to the new range.  <a href="classicl_1_1core_1_1Img.html#a3c44a202ca8a55d71253bce4884c19fa">More...</a><br /></td></tr>
<tr class="separator:a3c44a202ca8a55d71253bce4884c19fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05578d2ca296f7291e0169d18955fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#af05578d2ca296f7291e0169d18955fc2">normalizeImg</a> (const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;srcRange, const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:af05578d2ca296f7291e0169d18955fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the image from a given min/max range to the new range.  <a href="classicl_1_1core_1_1Img.html#af05578d2ca296f7291e0169d18955fc2">More...</a><br /></td></tr>
<tr class="separator:af05578d2ca296f7291e0169d18955fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d29a48ae9d338cb45cd2cba197bc928"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a7d29a48ae9d338cb45cd2cba197bc928">normalizeImg</a> (const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;dstRange)</td></tr>
<tr class="memdesc:a7d29a48ae9d338cb45cd2cba197bc928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the image from a min/max range to the new range.  <a href="classicl_1_1core_1_1Img.html#a7d29a48ae9d338cb45cd2cba197bc928">More...</a><br /></td></tr>
<tr class="separator:a7d29a48ae9d338cb45cd2cba197bc928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677953c11743ad94538ef6abb59f89d2"><td class="memTemplParams" colspan="2">template&lt;typename Tsrc , typename Tdst , int Nsrc, int Ndst, typename ReduceFunc &gt; </td></tr>
<tr class="memitem:a677953c11743ad94538ef6abb59f89d2"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a677953c11743ad94538ef6abb59f89d2">reduce_arrays</a> (const Tsrc *src[Nsrc], Tdst *dst[Ndst], unsigned int dim, ReduceFunc reduce)</td></tr>
<tr class="memdesc:a677953c11743ad94538ef6abb59f89d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">private helper function called from reduce_channels template  <a href="classicl_1_1core_1_1Img.html#a677953c11743ad94538ef6abb59f89d2">More...</a><br /></td></tr>
<tr class="separator:a677953c11743ad94538ef6abb59f89d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
pixel access using roi iterator</h2></td></tr>
<tr class="memitem:a99bf3e2c1e2ce88167fe460c5d95b209"><td class="memItemLeft" align="right" valign="top">typedef Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a99bf3e2c1e2ce88167fe460c5d95b209">iterator</a></td></tr>
<tr class="memdesc:a99bf3e2c1e2ce88167fe460c5d95b209"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator type (just a data pointer)  <a href="classicl_1_1core_1_1Img.html#a99bf3e2c1e2ce88167fe460c5d95b209">More...</a><br /></td></tr>
<tr class="separator:a99bf3e2c1e2ce88167fe460c5d95b209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad006890f5c29b127017718d7eca22a5f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classicl_1_1core_1_1ImgIterator.html">ImgIterator</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ad006890f5c29b127017718d7eca22a5f">roi_iterator</a></td></tr>
<tr class="memdesc:ad006890f5c29b127017718d7eca22a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">type definition for ROI iterator  <a href="classicl_1_1core_1_1Img.html#ad006890f5c29b127017718d7eca22a5f">More...</a><br /></td></tr>
<tr class="separator:ad006890f5c29b127017718d7eca22a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995351d0a5f5902b08320986899dee1e"><td class="memItemLeft" align="right" valign="top">const typedef Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a995351d0a5f5902b08320986899dee1e">const_iterator</a></td></tr>
<tr class="memdesc:a995351d0a5f5902b08320986899dee1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator type (just a const pointer)  <a href="classicl_1_1core_1_1Img.html#a995351d0a5f5902b08320986899dee1e">More...</a><br /></td></tr>
<tr class="separator:a995351d0a5f5902b08320986899dee1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecc6a75df36a631d62a98317b121b59"><td class="memItemLeft" align="right" valign="top">const typedef <a class="el" href="classicl_1_1core_1_1ImgIterator.html">ImgIterator</a>&lt; Type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#adecc6a75df36a631d62a98317b121b59">const_roi_iterator</a></td></tr>
<tr class="memdesc:adecc6a75df36a631d62a98317b121b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">type definition for a const ROI iterator  <a href="classicl_1_1core_1_1Img.html#adecc6a75df36a631d62a98317b121b59">More...</a><br /></td></tr>
<tr class="separator:adecc6a75df36a631d62a98317b121b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab023d66e784d830ecc16cec86293e23b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html#a99bf3e2c1e2ce88167fe460c5d95b209">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ab023d66e784d830ecc16cec86293e23b">begin</a> (int channel)</td></tr>
<tr class="memdesc:ab023d66e784d830ecc16cec86293e23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the image iterator (equal to getData(channel))  <a href="classicl_1_1core_1_1Img.html#ab023d66e784d830ecc16cec86293e23b">More...</a><br /></td></tr>
<tr class="separator:ab023d66e784d830ecc16cec86293e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba81c4275646aaf0596c851de6372e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html#a995351d0a5f5902b08320986899dee1e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aaba81c4275646aaf0596c851de6372e8">begin</a> (int channel) const</td></tr>
<tr class="memdesc:aaba81c4275646aaf0596c851de6372e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the image iterator (equal to getData(channel)) (const)  <a href="classicl_1_1core_1_1Img.html#aaba81c4275646aaf0596c851de6372e8">More...</a><br /></td></tr>
<tr class="separator:aaba81c4275646aaf0596c851de6372e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ce5c5950b768e2976cb3d47825d6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html#a99bf3e2c1e2ce88167fe460c5d95b209">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#adf3ce5c5950b768e2976cb3d47825d6a">end</a> (int channel)</td></tr>
<tr class="memdesc:adf3ce5c5950b768e2976cb3d47825d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the image end-iterator (equal to getData(channel)+<a class="el" href="classicl_1_1core_1_1ImgBase.html#af2ba167824297dc67cf40e163ec855a9" title="returns the pixel count of each channel">getDim()</a>)  <a href="classicl_1_1core_1_1Img.html#adf3ce5c5950b768e2976cb3d47825d6a">More...</a><br /></td></tr>
<tr class="separator:adf3ce5c5950b768e2976cb3d47825d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ec73acd099c23ef8482dbe2b5855f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html#a995351d0a5f5902b08320986899dee1e">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#aa6ec73acd099c23ef8482dbe2b5855f7">end</a> (int channel) const</td></tr>
<tr class="memdesc:aa6ec73acd099c23ef8482dbe2b5855f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the image end-iterator (const)  <a href="classicl_1_1core_1_1Img.html#aa6ec73acd099c23ef8482dbe2b5855f7">More...</a><br /></td></tr>
<tr class="separator:aa6ec73acd099c23ef8482dbe2b5855f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7294e40dc6cd76b59a841a6d44d148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html#ad006890f5c29b127017718d7eca22a5f">roi_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a9b7294e40dc6cd76b59a841a6d44d148">beginROI</a> (int channel)</td></tr>
<tr class="memdesc:a9b7294e40dc6cd76b59a841a6d44d148"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the iterator for an images ROI  <a href="classicl_1_1core_1_1Img.html#a9b7294e40dc6cd76b59a841a6d44d148">More...</a><br /></td></tr>
<tr class="separator:a9b7294e40dc6cd76b59a841a6d44d148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7994627b67ee09a4f367edfe8e919dcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html#adecc6a75df36a631d62a98317b121b59">const_roi_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a7994627b67ee09a4f367edfe8e919dcc">beginROI</a> (int channel) const</td></tr>
<tr class="memdesc:a7994627b67ee09a4f367edfe8e919dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the iterator for an images ROI (const)  <a href="classicl_1_1core_1_1Img.html#a7994627b67ee09a4f367edfe8e919dcc">More...</a><br /></td></tr>
<tr class="separator:a7994627b67ee09a4f367edfe8e919dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada51f5db29e43c1251700970a28c6b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html#ad006890f5c29b127017718d7eca22a5f">roi_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ada51f5db29e43c1251700970a28c6b3d">endROI</a> (int channel)</td></tr>
<tr class="memdesc:ada51f5db29e43c1251700970a28c6b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the end-iterator for an images ROI  <a href="classicl_1_1core_1_1Img.html#ada51f5db29e43c1251700970a28c6b3d">More...</a><br /></td></tr>
<tr class="separator:ada51f5db29e43c1251700970a28c6b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5318b62dc21b4309912d07429e09398c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1Img.html#adecc6a75df36a631d62a98317b121b59">const_roi_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a5318b62dc21b4309912d07429e09398c">endROI</a> (int channel) const</td></tr>
<tr class="memdesc:a5318b62dc21b4309912d07429e09398c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the end-iterator for an images ROI (const)  <a href="classicl_1_1core_1_1Img.html#a5318b62dc21b4309912d07429e09398c">More...</a><br /></td></tr>
<tr class="separator:a5318b62dc21b4309912d07429e09398c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5610bfed9c4a6868ab97abd0d2e458b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a5610bfed9c4a6868ab97abd0d2e458b8">getLocation</a> (const Type *p, int channel, bool relToROI=false) const</td></tr>
<tr class="memdesc:a5610bfed9c4a6868ab97abd0d2e458b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the x,y-coordinates of a pointer whithin a given channel  <a href="classicl_1_1core_1_1Img.html#a5610bfed9c4a6868ab97abd0d2e458b8">More...</a><br /></td></tr>
<tr class="separator:a5610bfed9c4a6868ab97abd0d2e458b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffa13e22ecc9f72b1af873c6b342b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a1ffa13e22ecc9f72b1af873c6b342b6d">printAsMatrix</a> (const std::string &amp;<a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>=&quot;5.3&quot;, bool visROI=true) const</td></tr>
<tr class="memdesc:a1ffa13e22ecc9f72b1af873c6b342b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">shows the image value by value at std::out  <a href="classicl_1_1core_1_1Img.html#a1ffa13e22ecc9f72b1af873c6b342b6d">More...</a><br /></td></tr>
<tr class="separator:a1ffa13e22ecc9f72b1af873c6b342b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f94e9791b58dc27efd85f295ce7b5fa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a6f94e9791b58dc27efd85f295ce7b5fa">isIndependent</a> () const</td></tr>
<tr class="memdesc:a6f94e9791b58dc27efd85f295ce7b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">shows wheter all image channels are currently not share with another image  <a href="classicl_1_1core_1_1Img.html#a6f94e9791b58dc27efd85f295ce7b5fa">More...</a><br /></td></tr>
<tr class="separator:a6f94e9791b58dc27efd85f295ce7b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
border functions</h2></td></tr>
<tr class="memitem:a675d8455ff7eb5f559a862a10afb7dcd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a675d8455ff7eb5f559a862a10afb7dcd">fillBorder</a> (bool <a class="el" href="classicl_1_1core_1_1ImgBase.html#a8ddd43e1ee36620cefa42714f288e9b7">setFullROI</a>=true)</td></tr>
<tr class="memdesc:a675d8455ff7eb5f559a862a10afb7dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">extrudes ROI borders through non-ROI borders  <a href="classicl_1_1core_1_1Img.html#a675d8455ff7eb5f559a862a10afb7dcd">More...</a><br /></td></tr>
<tr class="separator:a675d8455ff7eb5f559a862a10afb7dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1574708ef15f369fd58cee70f365f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a3e1574708ef15f369fd58cee70f365f9">fillBorder</a> (<a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> val, bool <a class="el" href="classicl_1_1core_1_1ImgBase.html#a8ddd43e1ee36620cefa42714f288e9b7">setFullROI</a>=true)</td></tr>
<tr class="memdesc:a3e1574708ef15f369fd58cee70f365f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">fills all non-ROI pixels with a given value  <a href="classicl_1_1core_1_1Img.html#a3e1574708ef15f369fd58cee70f365f9">More...</a><br /></td></tr>
<tr class="separator:a3e1574708ef15f369fd58cee70f365f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab333ac0d570ee2daf492492e16854b0e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#ab333ac0d570ee2daf492492e16854b0e">fillBorder</a> (const std::vector&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; &amp;vals, bool <a class="el" href="classicl_1_1core_1_1ImgBase.html#a8ddd43e1ee36620cefa42714f288e9b7">setFullROI</a>=true)</td></tr>
<tr class="memdesc:ab333ac0d570ee2daf492492e16854b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">fills all non-ROI pixels with a given value  <a href="classicl_1_1core_1_1Img.html#ab333ac0d570ee2daf492492e16854b0e">More...</a><br /></td></tr>
<tr class="separator:ab333ac0d570ee2daf492492e16854b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e452021e00847e93222a7a2a779243"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html#a61e452021e00847e93222a7a2a779243">fillBorder</a> (const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *src, bool <a class="el" href="classicl_1_1core_1_1ImgBase.html#a8ddd43e1ee36620cefa42714f288e9b7">setFullROI</a>=true)</td></tr>
<tr class="memdesc:a61e452021e00847e93222a7a2a779243"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies images non-border pixels from source image.  <a href="classicl_1_1core_1_1Img.html#a61e452021e00847e93222a7a2a779243">More...</a><br /></td></tr>
<tr class="separator:a61e452021e00847e93222a7a2a779243"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classicl_1_1core_1_1ImgBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classicl_1_1core_1_1ImgBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classicl_1_1core_1_1ImgBase.html">icl::core::ImgBase</a></td></tr>
<tr class="memitem:a5f5f045f71eed64db895500a8d79b643 inherit pro_methods_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a5f5f045f71eed64db895500a8d79b643">ImgBase</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;params)</td></tr>
<tr class="memdesc:a5f5f045f71eed64db895500a8d79b643 inherit pro_methods_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> object with specified image parameters.  <a href="classicl_1_1core_1_1ImgBase.html#a5f5f045f71eed64db895500a8d79b643">More...</a><br /></td></tr>
<tr class="separator:a5f5f045f71eed64db895500a8d79b643 inherit pro_methods_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classicl_1_1core_1_1ImgBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classicl_1_1core_1_1ImgBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classicl_1_1core_1_1ImgBase.html">icl::core::ImgBase</a></td></tr>
<tr class="memitem:aeaa93da2ff5bf4e9af265cdb39f48444 inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#aeaa93da2ff5bf4e9af265cdb39f48444">m_oParams</a></td></tr>
<tr class="memdesc:aeaa93da2ff5bf4e9af265cdb39f48444 inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">all image params  <a href="classicl_1_1core_1_1ImgBase.html#aeaa93da2ff5bf4e9af265cdb39f48444">More...</a><br /></td></tr>
<tr class="separator:aeaa93da2ff5bf4e9af265cdb39f48444 inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b87e0d438ec7e9127b7d01a5fd84ac inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a46b87e0d438ec7e9127b7d01a5fd84ac">m_eDepth</a></td></tr>
<tr class="memdesc:a46b87e0d438ec7e9127b7d01a5fd84ac inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">depth of the image (depth8 for icl8u/depth32 for icl32f)  <a href="classicl_1_1core_1_1ImgBase.html#a46b87e0d438ec7e9127b7d01a5fd84ac">More...</a><br /></td></tr>
<tr class="separator:a46b87e0d438ec7e9127b7d01a5fd84ac inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e94dec116dc86501596b06c89eb4be inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1Time.html">utils::Time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#ac9e94dec116dc86501596b06c89eb4be">m_timestamp</a></td></tr>
<tr class="memdesc:ac9e94dec116dc86501596b06c89eb4be inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">timestamp of the image  <a href="classicl_1_1core_1_1ImgBase.html#ac9e94dec116dc86501596b06c89eb4be">More...</a><br /></td></tr>
<tr class="separator:ac9e94dec116dc86501596b06c89eb4be inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3092ddaeda28bc989c25fe6d1a096db9 inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html#a3092ddaeda28bc989c25fe6d1a096db9">m_metaData</a></td></tr>
<tr class="memdesc:a3092ddaeda28bc989c25fe6d1a096db9 inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">additional information associated with this image  <a href="classicl_1_1core_1_1ImgBase.html#a3092ddaeda28bc989c25fe6d1a096db9">More...</a><br /></td></tr>
<tr class="separator:a3092ddaeda28bc989c25fe6d1a096db9 inherit pro_attribs_classicl_1_1core_1_1ImgBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Type&gt;<br />
class icl::core::Img&lt; Type &gt;</h3>

<p>The <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> class implements the <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> Image interface with type specific functionalities. </p>
<p>forward declaration of the Img-class</p>
<p>\ </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a99bf3e2c1e2ce88167fe460c5d95b209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bf3e2c1e2ce88167fe460c5d95b209">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Type* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html#a99bf3e2c1e2ce88167fe460c5d95b209">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>iterator type (just a data pointer) </p>

</div>
</div>
<a id="ad006890f5c29b127017718d7eca22a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad006890f5c29b127017718d7eca22a5f">&#9670;&nbsp;</a></span>roi_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classicl_1_1core_1_1ImgIterator.html">ImgIterator</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html#ad006890f5c29b127017718d7eca22a5f">roi_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type definition for ROI iterator </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa750aab12ce5265c4a6ca7e85600ccf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa750aab12ce5265c4a6ca7e85600ccf5">&#9670;&nbsp;</a></span>Img() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code><a class="el" href="classicl_1_1core_1_1ImgParams.html#a678ccf92d76d27b2acbcd1a5f3c507d3">ImgParams::null</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a new image specified by the given param struct </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>initializing image parameters, if null, then a null image is created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96170b9ea9b657ecaef9d8cf15c2cd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96170b9ea9b657ecaef9d8cf15c2cd4f">&#9670;&nbsp;</a></span>Img() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an image with specified number of channels and size. </p>
<p>the format of the image will be set to "formatMatrix" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>image size </td></tr>
    <tr><td class="paramname">channels</td><td>Number of Channels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98dc515d11e89a9158c07304682c7fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dc515d11e89a9158c07304682c7fc6">&#9670;&nbsp;</a></span>Img() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an image with specified size, number of channels and format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>size of the new image </td></tr>
    <tr><td class="paramname">fmt</td><td>(color)-format of the image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e8555de81ecc2a533e849b78880bfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8555de81ecc2a533e849b78880bfe6">&#9670;&nbsp;</a></span>Img() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crates an image with given size, channel count and format. </p>
<p>Note: channel count and format depend on each other, so if the given channel count and the given format are not compatible, an exception is thrown </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>size of the image </td></tr>
    <tr><td class="paramname">channels</td><td>channel count of the image (must be compatible to fmt) </td></tr>
    <tr><td class="paramname">fmt</td><td>format of the image (must be compatible to channels) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e56a84236b5db1edbf81f6bf57fb221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e56a84236b5db1edbf81f6bf57fb221">&#9670;&nbsp;</a></span>Img() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vptData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passOwnerShip</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an image with specified size and format, using shared data pointers as channel data. </p>
<p>The channel count is set to the channel count that is associated with given the format </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>new image size </td></tr>
    <tr><td class="paramname">format</td><td>(color)-format of the image </td></tr>
    <tr><td class="paramname">vptData</td><td>holds channel data pointers. It must contain enough Type-pointers for the given format. The data must not be deleted during the "lifetime" of the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> unless data ownership is passed to the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> instance by setting passOwnerShip to true. Call detach after the constructor call, to induce the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> to allocate own memory for the image data if ownership cannot be passed. </td></tr>
    <tr><td class="paramname">passOwnerShip</td><td>flag to specify the passed ownership </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aced05e61ac3cf24974733efd34c974de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced05e61ac3cf24974733efd34c974de">&#9670;&nbsp;</a></span>Img() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vptData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passOwnerShip</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an image with specified size and channel count, using shared data pointers as channel data. </p>
<p>the format is set to formatMatrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>new image size </td></tr>
    <tr><td class="paramname">channels</td><td>channel count of the image (format is set to "formatMatrix") </td></tr>
    <tr><td class="paramname">vptData</td><td>holds channel data pointers. It must contain at least 'channels' data pointers. The data must not be deleted during the "lifetime" of the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> unless data ownership is passed to the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> instance by setting passOwnerShip to true. Call detach after the constructor call, to induce the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> to allocate own memory for the image data if ownership cannot be passed. </td></tr>
    <tr><td class="paramname">passOwnerShip</td><td>flag to specify the passed ownership </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f50fc796f62c647b0419230b996b9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f50fc796f62c647b0419230b996b9e2">&#9670;&nbsp;</a></span>Img() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vptData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>passOwnerShip</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crates an image with given size, channel count and format. </p>
<p>Note: channel count and format depend on each other, so if the given channel count and the given format are not compatible, an exception is thrown </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>size of the image </td></tr>
    <tr><td class="paramname">channels</td><td>channel count of the image (must be compatible to fmt) </td></tr>
    <tr><td class="paramname">fmt</td><td>format of the image (must be compatible to channels) </td></tr>
    <tr><td class="paramname">vptData</td><td>array of data pointers, which are used as shared pointers. Ensure, that these pointers are persistent during the lifetime of the image unless ownership is passed by setting passOwnerShip to true, or call detach, to make the image allocate it own memory for the data </td></tr>
    <tr><td class="paramname">passOwnerShip</td><td>flag to specify the passed ownership </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc03ba1b1aa5c74d3b1f70841425e6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc03ba1b1aa5c74d3b1f70841425e6c4">&#9670;&nbsp;</a></span>Img() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tSrc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor WARNING: Violates const concept. </p>
<p>Creates a flat copy of the source image. The new image will contain a flat copy of all channels of the source image. This constructor is only applicable to <b>non-const</b> Img&lt;Type&gt; references. <b>Note:</b> this implicit shallow copy can be exploited to violate ICL's const concept: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func(<span class="keyword">const</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> &amp;a){</div>
<div class="line">  <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> b = a;</div>
<div class="line">  <span class="comment">// b is now unconst and therewith the data of</span></div>
<div class="line">  <span class="comment">// a can b chaned</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tSrc</td><td>non-const reference of source instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d7b76258e5bf542ea120c3b9366a48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7b76258e5bf542ea120c3b9366a48f">&#9670;&nbsp;</a></span>Img() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>c2</em> = <code><a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt;&#160;Type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>c3</em> = <code><a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt;&#160;Type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>c4</em> = <code><a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt;&#160;Type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>c5</em> = <code><a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt;&#160;Type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This constructor provides tight integration with DynMatrix template class. </p>
<p>creates a shallow Img&lt;Type&gt;-wrapper around a set of DynMatrix instances. <b>Note, of course this consturctor might be used to break DynMatrix's const concept, so please be aware of this!</b>. The resulting image counts that many channels as given count (up to 5) of non-null DynMatrix&lt;T&gt; instances. All null instances must have the same size, otherwise, an exception of type InvalidMatrixDimensionException is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>first image channel (mandatory) (if this is null, the image becomes null) </td></tr>
    <tr><td class="paramname">c2</td><td>optional 2nd image channel. Must have the same size as c1. </td></tr>
    <tr><td class="paramname">c3</td><td>optional 3rd image channel. Must have the same size as c1 and c2. </td></tr>
    <tr><td class="paramname">c4</td><td>optional 4th image channel. Must have the same size as c1 - c3. </td></tr>
    <tr><td class="paramname">c5</td><td>optional 5th image channel. Must have the same size as c1 - c4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e233b4cd972da0500f05600bb1dd32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e233b4cd972da0500f05600bb1dd32b">&#9670;&nbsp;</a></span>~Img()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::~<a class="el" href="classicl_1_1core_1_1Img.html">Img</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab014446ab51947df53ae127beb892c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab014446ab51947df53ae127beb892c26">&#9670;&nbsp;</a></span>append() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vChannels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private append function for a specified image channel </p>
<p>This must be kept private! Because it could otherwise be exploited to violate the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a>'s const concept </p>

</div>
</div>
<a id="ace5a29b120d0c8193d826d8b94464008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5a29b120d0c8193d826d8b94464008">&#9670;&nbsp;</a></span>append() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private append function for a specified image channel </p>
<p>This must be kept private! Because it could otherwise be exploited to violate the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a>'s const concept </p>

</div>
</div>
<a id="a682ea3c863b76504947caf18d73ffec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682ea3c863b76504947caf18d73ffec9">&#9670;&nbsp;</a></span>append() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vChannels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a set of selected channels from source image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image </td></tr>
    <tr><td class="paramname">vChannels</td><td>vector of channels indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f7286e5de8d5d30a922939cedddd829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7286e5de8d5d30a922939cedddd829">&#9670;&nbsp;</a></span>append() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append channels of external <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> to the existing <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a>. </p>
<p>Both objects will share their data (cheap copy). If a non-matrix format image gets new channels using it's append method, the new channel count will not match to the channel count, that is associated with the current format. In this case, a waring is written to std::out, and the format will be set to formatMatrix implicitly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image </td></tr>
    <tr><td class="paramname">iChannel</td><td>channel to append (or all, if &lt; 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab023d66e784d830ecc16cec86293e23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab023d66e784d830ecc16cec86293e23b">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html#a99bf3e2c1e2ce88167fe460c5d95b209">iterator</a> <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the image iterator (equal to getData(channel)) </p>

</div>
</div>
<a id="aaba81c4275646aaf0596c851de6372e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba81c4275646aaf0596c851de6372e8">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html#a995351d0a5f5902b08320986899dee1e">const_iterator</a> <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the image iterator (equal to getData(channel)) (const) </p>

</div>
</div>
<a id="a9b7294e40dc6cd76b59a841a6d44d148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7294e40dc6cd76b59a841a6d44d148">&#9670;&nbsp;</a></span>beginROI() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html#ad006890f5c29b127017718d7eca22a5f">roi_iterator</a> <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::beginROI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the iterator for an images ROI </p>

</div>
</div>
<a id="a7994627b67ee09a4f367edfe8e919dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7994627b67ee09a4f367edfe8e919dcc">&#9670;&nbsp;</a></span>beginROI() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html#adecc6a75df36a631d62a98317b121b59">const_roi_iterator</a> <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::beginROI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the iterator for an images ROI (const) </p>

</div>
</div>
<a id="a1da0eda1f6dddd31381b65c794a37983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da0eda1f6dddd31381b65c794a37983">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>tValue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bROIOnly</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the ROI pixels of one or all channels to a specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td><a class="el" href="classicl_1_1core_1_1Channel.html" title="Utility helper class for faster and more convenient access to single channel image data.">Channel</a> to fill with zero (default: -1 = all channels) </td></tr>
    <tr><td class="paramname">tValue</td><td>destination value (default: 0) </td></tr>
    <tr><td class="paramname">bROIOnly</td><td>if set false, the whole image is set to tValue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25474639a3e70b65f22f1bac48eaad89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25474639a3e70b65f22f1bac48eaad89">&#9670;&nbsp;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;typename BinaryFunction , class dstType , class otherSrcType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;dstType&gt;&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::combine </td>
          <td>(</td>
          <td class="paramtype">BinaryFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; otherSrcType &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-based "transform function combining two images pixel-wise into a given destination image (with ROI support)". </p>
<p>This function calls D = F(A,B), with D: destination ROI pixel, F: given binary functor/function, A: pixel of this image and B: pixel of other given src image. Internally this function uses std::transform Beispiel: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Quick_8h.html">ICLQt/Quick.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">ImgQ</a> a = <a class="code" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">scale</a>(<a class="code" href="namespaceicl_1_1qt.html#a0535967935289099b53e7035df6d33c8">create</a>(<span class="stringliteral">&quot;parrot&quot;</span>),640,480);</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">ImgQ</a> b = <a class="code" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">scale</a>(<a class="code" href="namespaceicl_1_1qt.html#a0535967935289099b53e7035df6d33c8">create</a>(<span class="stringliteral">&quot;women&quot;</span>),640,480);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> dst(a.getParams());</div>
<div class="line"> </div>
<div class="line">  a.setROI(Rect(10,10,300,100));</div>
<div class="line">  b.setROI(Rect(10,10,300,100));</div>
<div class="line">  dst.setROI(Rect(10,10,300,100));</div>
<div class="line"> </div>
<div class="line">  a.combine(std::less&lt;icl32f&gt;(),b,dst);</div>
<div class="line"> </div>
<div class="line">  dst.setFullROI();</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a6d5888c806c5f70d6ab41384717d772b">show</a>(<a class="code" href="namespaceicl_1_1qt.html#a708f0f4e044223db05553e6223d3801a">norm</a>(<a class="code" href="namespaceicl_1_1qt.html#a4b7ec064d50f72a77db212bdbebbf1fb">cvt</a>(dst)));</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>binary function or functor implementing "dstType operator() const(Type &amp;a, otherSrcType &amp;b) const" </td></tr>
    <tr><td class="paramname">otherSrc</td><td>2nd source image </td></tr>
    <tr><td class="paramname">dst</td><td>destination image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add8153c70ec0232aaf8c98ddfef11ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8153c70ec0232aaf8c98ddfef11ffd">&#9670;&nbsp;</a></span>combine_C()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;typename BinaryFunction , class dstType , class otherSrcType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;dstType&gt;&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::combine_C </td>
          <td>(</td>
          <td class="paramtype">BinaryFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thisChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>otherSrcChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; otherSrcType &gt; &amp;&#160;</td>
          <td class="paramname"><em>otherSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL-based "transform function combining two images pixel-wise into a given destination image (with ROI support)". </p>
<p>Internally this function uses std::transform. Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Quick_8h.html">ICLQt/Quick.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> gt_func(<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;a,<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;b){</div>
<div class="line">  <span class="keywordflow">return</span> a &gt; b;</div>
<div class="line">}</div>
<div class="line"><span class="keyword">struct </span>EqFunctor{</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code" href="classicl_1_1core_1_1Img.html#af9fa509c57754dad16b48c7cac3a26c2">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;a, <span class="keyword">const</span> <span class="keywordtype">float</span> &amp;b){</div>
<div class="line">    <span class="keywordflow">return</span> a == b;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">ImgQ</a> a = <a class="code" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">scale</a>(<a class="code" href="namespaceicl_1_1qt.html#a0535967935289099b53e7035df6d33c8">create</a>(<span class="stringliteral">&quot;parrot&quot;</span>),640,480);</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">ImgQ</a> b = <a class="code" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">scale</a>(<a class="code" href="namespaceicl_1_1qt.html#a0535967935289099b53e7035df6d33c8">create</a>(<span class="stringliteral">&quot;women&quot;</span>),640,480);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> dst(a.getParams());</div>
<div class="line"> </div>
<div class="line">  a.setROI(Rect(10,10,500,400));</div>
<div class="line">  b.setROI(Rect(10,10,500,400));</div>
<div class="line">  dst.setROI(Rect(10,10,500,400));</div>
<div class="line"> </div>
<div class="line">  a.combine_C(std::less&lt;icl32f&gt;(),0,0,0,b,dst);</div>
<div class="line">  a.combine_C(gt_func,1,1,1,b,dst);</div>
<div class="line">  a.combine_C(EqFunctor(),2,2,2,b,dst);</div>
<div class="line"> </div>
<div class="line">  dst.setFullROI();</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a6d5888c806c5f70d6ab41384717d772b">show</a>(<a class="code" href="namespaceicl_1_1qt.html#a708f0f4e044223db05553e6223d3801a">norm</a>(<a class="code" href="namespaceicl_1_1qt.html#a4b7ec064d50f72a77db212bdbebbf1fb">cvt</a>(dst)));</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>binary function of functor implementing "dstType operator() const(Type &amp;a, otherSrcType &amp;b) const" </td></tr>
    <tr><td class="paramname">thisChannel</td><td>valid channel of this image </td></tr>
    <tr><td class="paramname">otherSrcChannel</td><td>valid channel index for give 2nd source image </td></tr>
    <tr><td class="paramname">dstChannel</td><td>valid channel index of dst image </td></tr>
    <tr><td class="paramname">otherSrc</td><td>2nd source image (ROI-size must be equal to this' ROI size) </td></tr>
    <tr><td class="paramname">dst</td><td>destination image (ROI-size must be equal to this' ROI size) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6879fba221d6b727db151cddea844409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6879fba221d6b727db151cddea844409">&#9670;&nbsp;</a></span>createChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1utils_1_1SmartArray.html">utils::SmartArray</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::createChannel </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>ptDataToCopy</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internally creates a new deep copy of a specified Type*. </p>
<p>if the give Type* ptDataToCopy is not NULL, the data addressed from it, is copied deeply into the new created data pointer </p>

</div>
</div>
<a id="a259fc616dde60b365938f3d24fb78636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259fc616dde60b365938f3d24fb78636">&#9670;&nbsp;</a></span>deepCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::deepCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>poDst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a deep copy of an image. </p>
<p>This is an overloaded version of the above function. It behaves essentially like the above function, except getting an Img&lt;Type&gt;* as destination image argument, what allows to apply the operation without a depth switch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poDst</td><td>destination image, if NULL, a new Img&lt;Type&gt; is created </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deep copy of this image </dd></dl>

</div>
</div>
<a id="a93d412faa3854d765ff2ee18b3478bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d412faa3854d765ff2ee18b3478bbd">&#9670;&nbsp;</a></span>deepCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::deepCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>ppoDst</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a deep copy of an image. </p>
<p>Create a deep copy of a given image. An optional destination image can be given via ppoDst. If ppoDst is NULL, a new image created and returned. If ppoDst points to NULL, the new image is created at *ppoDst. Otherwise, the given destination image (*ppoDst) is adapted to this images params including its depth. If the destination images depth differs from this images depth, (*ppoDst) is first released and then created new on the heap </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppoDst</td><td>optionally given destination image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deep copied image </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a25f01d5cc78250612fa7acb372931a1b">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a51d1173a1661a8b39d55d3552f121359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d1173a1661a8b39d55d3552f121359">&#9670;&nbsp;</a></span>deepCopyROI() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::deepCopyROI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>poDst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a deep copy of an images ROI. </p>
<p>This is an overloaded version of the above function. It behaves essentially like the above function, except getting an Img&lt;Type&gt;* as destination image argument, what allows to apply the operation without a depth switch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poDst</td><td>destination image, if NULL, a new Img&lt;Type&gt; is created. poDst must have either ROI size identical to this images ROI size or zero-dim size (in this case poDst's size is set to this images ROI size) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>deep copy of this images ROI </dd></dl>

</div>
</div>
<a id="a2d6317f8c04cc12fb7ee2366bfd05117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6317f8c04cc12fb7ee2366bfd05117">&#9670;&nbsp;</a></span>deepCopyROI() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::deepCopyROI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>ppoDst</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a deep copy of an images ROI. </p>
<p>Create a deep copy of an images ROI. This function creates copies this images ROI into an optional given destination image. If ppoDst is NULL, a new image is created. If it points to NULL, a new image is created at *ppoDst. Otherwise the destination image is adapted in size, channels and depth to this image (the size is set to this images ROI size). The copy operation is performed line-wise using <em>memcpy</em>, what makes deepCopyROI very fast. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppoDst</td><td>optionally given destination image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>image containing a deep copy of the source images ROI </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a38e706629576244de5000ba017a5f478">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="ae7541625a11c5208e0ade388d534c18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7541625a11c5208e0ade388d534c18d">&#9670;&nbsp;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::detach </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iIndex</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the image channels inside the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> independent from other <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a>. </p>
<p>Makes the image channels independent from other images. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iIndex</td><td>index of the channel, that should be detached. (If iIndex is an legal channel index only the corresponding channel will be detached. If iIndex is -1 (default) all channels are detached </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#ad5a04cd146de11aed371b76984f80dba">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a4129ac9e0f9c554e274505919ef5536c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4129ac9e0f9c554e274505919ef5536c">&#9670;&nbsp;</a></span>detached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::detached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method, that returns a detached version of this image. </p>
<p>This method can be seen as a deep-copy method. With this method, you can copy an image deeply be calling </p><div class="fragment"><div class="line"><a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> sourceImage(Size::VGA,<a class="code" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a14b76eca3cc1e9ac323ba2308a15f49e">formatRGB</a>)</div>
<div class="line"><a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> deeplyCopiedInstance = sourceImage.<a class="code" href="classicl_1_1core_1_1Img.html#a4129ac9e0f9c554e274505919ef5536c">detached</a>();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adf3ce5c5950b768e2976cb3d47825d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3ce5c5950b768e2976cb3d47825d6a">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html#a99bf3e2c1e2ce88167fe460c5d95b209">iterator</a> <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::end </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the image end-iterator (equal to getData(channel)+<a class="el" href="classicl_1_1core_1_1ImgBase.html#af2ba167824297dc67cf40e163ec855a9" title="returns the pixel count of each channel">getDim()</a>) </p>

</div>
</div>
<a id="aa6ec73acd099c23ef8482dbe2b5855f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ec73acd099c23ef8482dbe2b5855f7">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html#a995351d0a5f5902b08320986899dee1e">const_iterator</a> <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::end </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the image end-iterator (const) </p>

</div>
</div>
<a id="ada51f5db29e43c1251700970a28c6b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada51f5db29e43c1251700970a28c6b3d">&#9670;&nbsp;</a></span>endROI() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html#ad006890f5c29b127017718d7eca22a5f">roi_iterator</a> <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::endROI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the end-iterator for an images ROI </p>
<p>the returned iterator must not be incremented or decremented! </p>

</div>
</div>
<a id="a5318b62dc21b4309912d07429e09398c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5318b62dc21b4309912d07429e09398c">&#9670;&nbsp;</a></span>endROI() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html#adecc6a75df36a631d62a98317b121b59">const_roi_iterator</a> <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::endROI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the end-iterator for an images ROI (const) </p>

</div>
</div>
<a id="aa3f7b0d5d873dce5b4124892d1c54f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f7b0d5d873dce5b4124892d1c54f15">&#9670;&nbsp;</a></span>extractChannelImg() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractChannelImg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new image with shallow copied single channels of this image. </p>
<p>param indices channel indices to extract (each must be valid, else error and channel index that does not match is omitted) </p>

</div>
</div>
<a id="af617f7887e7caca2091653cb6f4fa57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af617f7887e7caca2091653cb6f4fa57a">&#9670;&nbsp;</a></span>extractChannelImg() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractChannelImg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new image with shallow copied single channels of this image. </p>
<p>param indices channel indices to extract (each must be valid, else error and channel index that does not match is omitted) </p>

</div>
</div>
<a id="a3ef7c48b005b01188994b6f29e02a8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef7c48b005b01188994b6f29e02a8a2">&#9670;&nbsp;</a></span>extractChannelImg() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractChannelImg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new image with a shallow copied single channel of this image. </p>
<p>param index channel index to extract (must be valid, else resulting image has no channels and error message) </p>

</div>
</div>
<a id="af11d91e621dfb3eda82b0039559b82ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11d91e621dfb3eda82b0039559b82ce">&#9670;&nbsp;</a></span>extractChannelImg() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractChannelImg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new image with a shallow copied single channel of this image. </p>
<p>param index channel index to extract (must be valid, else resulting image has no channels and error message) </p>

</div>
</div>
<a id="a60b35475c8518c1415441e17054a77e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b35475c8518c1415441e17054a77e3">&#9670;&nbsp;</a></span>extractChannels() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts all image channels at once into given channel pointer </p>

</div>
</div>
<a id="a47c48d7b5b089d2f29450814bb69abe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c48d7b5b089d2f29450814bb69abe3">&#9670;&nbsp;</a></span>extractChannels() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is forbidden, it produces an error message </p>
<p>This would allow the programme to violate the Imgs const concept </p>

</div>
</div>
<a id="acdb019a8879009bc2932b5231dce98f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb019a8879009bc2932b5231dce98f5">&#9670;&nbsp;</a></span>extractChannels() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractChannels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts all image channels at once into given channel pointer (const) </p>
<p>Plese note that the given dst-pointer must also be const </p>

</div>
</div>
<a id="a3413e5b5b1d678a6953bcffc76598cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3413e5b5b1d678a6953bcffc76598cf3">&#9670;&nbsp;</a></span>extractDynMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractDynMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts given channel as DynMatrix&lt;Type&gt; </p>

</div>
</div>
<a id="a9ae84b87ffa6cb6b327d04b0ae8d81d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae84b87ffa6cb6b327d04b0ae8d81d1">&#9670;&nbsp;</a></span>extractDynMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">math::DynMatrix</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractDynMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts given channel as DynMatrix&lt;Type&gt; const </p>

</div>
</div>
<a id="a5a35d6acb570e8139b0768a46abf6c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a35d6acb570e8139b0768a46abf6c73">&#9670;&nbsp;</a></span>extractPointers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractPointers </td>
          <td>(</td>
          <td class="paramtype">const Type **&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts all data pointers into given destination pointer (const) </p>

</div>
</div>
<a id="a95a9f7c2bd1ad22a3aa676dde066dc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a9f7c2bd1ad22a3aa676dde066dc9a">&#9670;&nbsp;</a></span>extractPointers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractPointers </td>
          <td>(</td>
          <td class="paramtype">Type **&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts all data pointers into given destination pointer </p>

</div>
</div>
<a id="ab5f7d706268dc292928cf73b21d3c592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f7d706268dc292928cf73b21d3c592">&#9670;&nbsp;</a></span>extractPointers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::extractPointers </td>
          <td>(</td>
          <td class="paramtype">Type **&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function is forbidden, it produces an error message </p>
<p>This would allow the programme to violate the Imgs const concept </p>

</div>
</div>
<a id="a6a0f90b207c4ce99b9f18f9f5d165dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0f90b207c4ce99b9f18f9f5d165dde">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fills the whole image with given source type value </p>
<p>In contrast to icl::Img::clear, which is highly optimized, this methods use std::fill. By this means, the given source value is really assigned to each value. This can e.g. be used to fill an image with random values </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Img_8h.html">ICLCore/Img.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ICLCore/Random.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Quick_8h.html">ICLQt/Quick.h</a>&gt;</span></div>
<div class="line"><span class="keywordtype">void</span> foo(){</div>
<div class="line">   <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> image(Size::QQVGA,3);</div>
<div class="line">   image.fill(URandI(255));</div>
<div class="line">   <a class="code" href="namespaceicl_1_1qt.html#a6d5888c806c5f70d6ab41384717d772b">show</a>(image);</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="image">
<img src="img-fill.jpg" alt=""/>
<div class="caption">
result if Img::fill example</div></div>
 
</div>
</div>
<a id="a675d8455ff7eb5f559a862a10afb7dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675d8455ff7eb5f559a862a10afb7dcd">&#9670;&nbsp;</a></span>fillBorder() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::fillBorder </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setFullROI</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extrudes ROI borders through non-ROI borders </p>
<p>This function can be used fill all image border pixles (pixels outside the current ROI with the value of the closest ROI-pixel </p>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#afe8903d4ea6a157b13f127c1837ed2e9">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a61e452021e00847e93222a7a2a779243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e452021e00847e93222a7a2a779243">&#9670;&nbsp;</a></span>fillBorder() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::fillBorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setFullROI</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies images non-border pixels from source image. </p>
<p>The source image must provided pixel values for each non border pixel of this image. So the source images size must be at least (X+1)x(Y+1) where (X,Y) is the lower right non-border pixel of this image. </p>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a200461a67551b586bebe654499ed7b29">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="ab333ac0d570ee2daf492492e16854b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab333ac0d570ee2daf492492e16854b0e">&#9670;&nbsp;</a></span>fillBorder() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::fillBorder </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setFullROI</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fills all non-ROI pixels with a given value </p>
<p>here, for each channel a given value is used, so vals.size() must be at least this-&gt;<a class="el" href="classicl_1_1core_1_1ImgBase.html#af7696553df7010323c6a6bb8c3fd3f6f" title="returns the channel count of the image">getChannels()</a> </p>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a276a2223cf682a0372917b769c1c2e55">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a3e1574708ef15f369fd58cee70f365f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1574708ef15f369fd58cee70f365f9">&#9670;&nbsp;</a></span>fillBorder() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::fillBorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceicl.html#ab21f404160d56751f53c4b12618acb26">icl64f</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setFullROI</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fills all non-ROI pixels with a given value </p>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#aedb30a189c5cd1a9ff4b322fb1b56f6b">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a58e61d7766379f4135b4d5736047bf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e61d7766379f4135b4d5736047bf49">&#9670;&nbsp;</a></span>fillChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::fillChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fills the given channel with given source type value </p>

</div>
</div>
<a id="a44e72c186b1386e47c909d286cfa36ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44e72c186b1386e47c909d286cfa36ca">&#9670;&nbsp;</a></span>fillChannelROI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::fillChannelROI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fills the given channel's with given source type value </p>

</div>
</div>
<a id="a12065fb47f1b2198b811ce88abe805a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12065fb47f1b2198b811ce88abe805a6">&#9670;&nbsp;</a></span>fillROI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::fillROI </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fills the whole image with given source type value </p>

</div>
</div>
<a id="a6ae2c82990ee22f5afffacb55ec6e154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ae2c82990ee22f5afffacb55ec6e154">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL based "for_each" implementations applying an Unary function on each ROI-pixel. </p>
<p>Internally using std::for_each by calling <a class="el" href="classicl_1_1core_1_1Img.html#af8df2ce956d4256a608cadd143078fff" title="STL based &quot;for_each&quot; implementations applying an Unary function on each ROI-pixel of given channel.">Img&lt;T&gt;::forEach_C</a> for all channels Example:<br  />
</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Quick_8h.html">ICLQt/Quick.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Thresh{</div>
<div class="line">  <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classicl_1_1core_1_1Img.html#af9fa509c57754dad16b48c7cac3a26c2">operator()</a>(<span class="keywordtype">float</span> &amp;f){ f = f&gt;128 ? 0 : 255; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">ImgQ</a> a = <a class="code" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">scale</a>(<a class="code" href="namespaceicl_1_1qt.html#a0535967935289099b53e7035df6d33c8">create</a>(<span class="stringliteral">&quot;parrot&quot;</span>),0.2);</div>
<div class="line">  a.forEach(Thresh());</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a6d5888c806c5f70d6ab41384717d772b">show</a>(a);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>unary function or functor implementing "AnyType operator()(Type &amp;val)" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8df2ce956d4256a608cadd143078fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8df2ce956d4256a608cadd143078fff">&#9670;&nbsp;</a></span>forEach_C()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::forEach_C </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL based "for_each" implementations applying an Unary function on each ROI-pixel of given channel. </p>
<p>Internally this function uses std::for_each Example:<br  />
</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Quick_8h.html">ICLQt/Quick.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Thresh{</div>
<div class="line">  <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classicl_1_1core_1_1Img.html#af9fa509c57754dad16b48c7cac3a26c2">operator()</a>(<span class="keywordtype">float</span> &amp;f){ f = f&gt;128 ? 0 : 255; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> ttt(<span class="keywordtype">float</span> &amp;f){</div>
<div class="line">  f = f&gt;128 ? 0 : 255;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">ImgQ</a> a = <a class="code" href="namespaceicl_1_1qt.html#a0535967935289099b53e7035df6d33c8">create</a>(<span class="stringliteral">&quot;parrot&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  a.forEach_C(ttt,1);</div>
<div class="line">  a.forEach_C(Thresh(),0);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a6d5888c806c5f70d6ab41384717d772b">show</a>(<a class="code" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">scale</a>(a,0.2));</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>unary function or functor implementing "AnyType operator()(Type &amp;val)" </td></tr>
    <tr><td class="paramname">channel</td><td>valid channel index for this image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5e09f24ce08f3618cd9c1342a0a47a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e09f24ce08f3618cd9c1342a0a47a1">&#9670;&nbsp;</a></span>getData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a Type save data data pointer to the channel data origin </p>
<p>If the channel index is not valid (&lt;0 or &gt;= getChannels) NULL is returned and an error is written to std::err </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>specifies the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data origin pointer to the specified channel </dd></dl>

</div>
</div>
<a id="a0e929262ce00f0d8c0dbb5d552f86958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e929262ce00f0d8c0dbb5d552f86958">&#9670;&nbsp;</a></span>getData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a Type save data data pointer to the channel data origin (const) </p>
<p>returns a Type save data data pointer to the channel data origin If the channel index is not valid (&lt;0 or &gt;= getChannels) NULL is returned and an error is written to std::err </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>specifies the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data origin pointer to the specified channel </dd></dl>

</div>
</div>
<a id="aa6559fc4730ad4fe2a8671db6b722b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6559fc4730ad4fe2a8671db6b722b1c">&#9670;&nbsp;</a></span>getDataPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getDataPtr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the raw- data pointer of an image channel </p>
<p>returns a pointer to first data element of a given channel </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a772ec6593c4ea21b896e2c167de5dc04">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="abc9a4a36cbaf196d960eebfc93e8c9a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9a4a36cbaf196d960eebfc93e8c9a5">&#9670;&nbsp;</a></span>getDataPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const void* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getDataPtr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the raw- data pointer of an image channel (const) </p>
<p>returns a pointer to first data element of a given channel </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#ab4df1b06f38e50a96b5c1d0e26ed8ae9">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a141e786dbadd493bac77444fa1df95c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141e786dbadd493bac77444fa1df95c1">&#9670;&nbsp;</a></span>getEndIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getEndIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the end index for a channel loop </p>
<p>this function behaves essentially like the above function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iIndex</td><td>channel index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>end index for for-loops </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicl_1_1core_1_1Img.html#a66f9016cce58451355b6db43fbba233d" title="returns the start index for a channel loop">getStartIndex</a> </dd></dl>

</div>
</div>
<a id="a659dca05fde0cb4f6f5fec2c0bba60b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659dca05fde0cb4f6f5fec2c0bba60b3">&#9670;&nbsp;</a></span>getLineStep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getLineStep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the width of an image line in bytes. </p>
<p>returns the length of an image line in bytes (width*sizeof(Type)) This information is compulsory for calling any IPP function. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classicl_1_1core_1_1ImgBase.html#a19261f5654fa868e6fa5d039d8f3ccfe" title="returns the images width">getWidth()</a>*sizeof(Type) in the underlying <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> template </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#abe776aea024fc46cda6bb47ea14df290">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a5610bfed9c4a6868ab97abd0d2e458b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5610bfed9c4a6868ab97abd0d2e458b8">&#9670;&nbsp;</a></span>getLocation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getLocation </td>
          <td>(</td>
          <td class="paramtype">const Type *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>relToROI</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the x,y-coordinates of a pointer whithin a given channel </p>
<p>E.g channel c's pointer of image I points to adress p=1005, image width is 10 and data depth is 1 (icl-8u image). Then I.getLocation(1006,c) returns Point(1,0) and I.getLocation(1015,c) returns Point(0,1).<br  />
The following rule is always true: <code> Point p = somewhat; image i = somewhat; p == i.getLocation(i.getData(0)+p.x+image.getWidth()*p.y,any-valid-channel); </code> Optionally, returned point can be calculated w.r.t. the images roi offset. </p>

</div>
</div>
<a id="a37104b77fc3432b1660f1f717b254d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37104b77fc3432b1660f1f717b254d5e">&#9670;&nbsp;</a></span>getMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return minimal pixel value over all channels (restricted to ROI) </p>

</div>
</div>
<a id="a49f453571d6ad790cb50016717907aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f453571d6ad790cb50016717907aa4">&#9670;&nbsp;</a></span>getMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getMax </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *&#160;</td>
          <td class="paramname"><em>coords</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns max pixel value of channel iChannel within ROI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>Index of channel </td></tr>
    <tr><td class="paramname">coords</td><td>(optinal) if not null, the pixel position of the max is written into this argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2eb464e72cecdf253fbf682ee5f690f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2eb464e72cecdf253fbf682ee5f690f">&#9670;&nbsp;</a></span>getMin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return maximal pixel value over all channels (restricted to ROI) </p>

</div>
</div>
<a id="af30e405f529fff38e5110dbd2082819e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30e405f529fff38e5110dbd2082819e">&#9670;&nbsp;</a></span>getMin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getMin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *&#160;</td>
          <td class="paramname"><em>coords</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns min pixel value of channel iChannel within ROI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>Index of channel </td></tr>
    <tr><td class="paramname">coords</td><td>(optinal) if not null, the pixel position of the min is written into this argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abab4459235a90041a61ef4f3184cdfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab4459235a90041a61ef4f3184cdfbb">&#9670;&nbsp;</a></span>getMinMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getMinMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return minimal and maximal pixel values over all channels (restricted to ROI) </p>

</div>
</div>
<a id="a65171125716590787772fbeb91836932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65171125716590787772fbeb91836932">&#9670;&nbsp;</a></span>getMinMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getMinMax </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *&#160;</td>
          <td class="paramname"><em>minCoords</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> *&#160;</td>
          <td class="paramname"><em>maxCoords</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns min and max pixel values of channel iChannel within ROI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>Index of channel </td></tr>
    <tr><td class="paramname">minCoords</td><td>(optinal) if not null, the pixel position of the min is written into this argument </td></tr>
    <tr><td class="paramname">maxCoords</td><td>(optinal) if not null, the pixel position of the max is written into this argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fa60c3bbc45f7682ed98af276b1c89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa60c3bbc45f7682ed98af276b1c89a">&#9670;&nbsp;</a></span>getROIData() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getROIData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a Type save data pointer to the first pixel within the images roi </p>
<p>The following ASCII image shows an images ROI. </p><pre>
               1st roi-pixel
                    |
                ....|....................         ---
                ....|..ooooooooo......... ---      |
                ....|..ooooooooo.........  |       |
                ....|..ooooooooo......... roi-h  image-h
1st image pixel ....|..ooooooooo.........  |       |
     |          ....+-&gt;xoooooooo......... ---      |
     +---------&gt;x........................         ---
                       |-roi-w-|
                |---------image-w-------|</pre><pre></pre><p> <b>Note:</b> most ipp-function require the ROI-data pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>specifies the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>roi data pointer </dd></dl>

</div>
</div>
<a id="a7ea20e1d52bf1e4a40dfc9b8e76d2599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea20e1d52bf1e4a40dfc9b8e76d2599">&#9670;&nbsp;</a></span>getROIData() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getROIData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a Type save data pointer to the first pixel within the images roi (const) </p>
<p>returns a Type save data pointer to the first pixel within the images roi The following ASCII image shows an images ROI. </p><pre>
               1st roi-pixel
                    |
                ....|....................         ---
                ....|..ooooooooo......... ---      |
                ....|..ooooooooo.........  |       |
                ....|..ooooooooo......... roi-h  image-h
1st image pixel ....|..ooooooooo.........  |       |
     |          ....+-&gt;xoooooooo......... ---      |
     +---------&gt;x........................         ---
                       |-roi-w-|
                |---------image-w-------|</pre><pre></pre><p> <b>Note:</b> most ipp-function require the ROI-data pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>specifies the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>roi data pointer </dd></dl>

</div>
</div>
<a id="ae5b3b84c143a4acb7655b30e739435a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b3b84c143a4acb7655b30e739435a9">&#9670;&nbsp;</a></span>getROIData() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getROIData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the data pointer to a pixel with defined offset </p>
<p>In some functions like filters, it might be necessary to change the images ROI parameters before applying the underlying image operation. Temporarily changing the images ROI parameters causes problems in multi-threaded environments. To avoid this, this function provides access to a data pointer to an arbitrary notional ROI-offset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>selects the channel </td></tr>
    <tr><td class="paramname">p</td><td>notional ROI offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data pointer with notional ROI offset p </dd></dl>

</div>
</div>
<a id="a3f3d7b84016401516224d835a4cc6453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3d7b84016401516224d835a4cc6453">&#9670;&nbsp;</a></span>getROIData() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getROIData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the data pointer to a pixel with defined offset (const) </p>
<p>returns the data pointer to a pixel with defined offset In some functions like filters, it might be necessary to change the images ROI parameters before applying the underlying image operation. Temporarily changing the images ROI parameters causes problems in multi-threaded environments. To avoid this, this function provides access to a data pointer to an arbitrary notional ROI-offset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>selects the channel </td></tr>
    <tr><td class="paramname">p</td><td>notional ROI offset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data pointer with notional ROI offset p </dd></dl>

</div>
</div>
<a id="a66f9016cce58451355b6db43fbba233d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f9016cce58451355b6db43fbba233d">&#9670;&nbsp;</a></span>getStartIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::getStartIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the start index for a channel loop </p>
<p>In some functions to cases must be regarded:</p><ul>
<li>if given channel index is -1, then it has to be iterated over all image channels</li>
<li>else only the given image channel has to be touched</li>
</ul>
<p>To avoid code doublication, one can use the following for-loop </p><pre>
void foo(int iChannel){
   for(int i = iIndex &lt; 0 ? 0 : iIndex, iEnd = iIndex &lt; 0 ? m_iChannels : iIndex+1; i &lt; iEnd; i++)   {
         // do something
   }
}
</pre><p> When using the get&lt;Start|End&gt;Index functions the loop becomes much more readable: </p><pre>
void foo(int iChannel){
   for(int i=getStartIndex(iIndex), iEnd=getEndIndex(iIndex); i&lt;iEnd ;i++){
     // do something
   }
}
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iIndex</td><td>channel index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>start index for for-loops </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicl_1_1core_1_1Img.html#a141e786dbadd493bac77444fa1df95c1" title="returns the end index for a channel loop">getEndIndex</a> </dd></dl>

</div>
</div>
<a id="a6f94e9791b58dc27efd85f295ce7b5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f94e9791b58dc27efd85f295ce7b5fa">&#9670;&nbsp;</a></span>isIndependent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::isIndependent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>shows wheter all image channels are currently not share with another image </p>
<p>\copydoc bool <a class="el" href="classicl_1_1core_1_1ImgBase.html#a99781d1d4537a5e77d0763bda632969a" title="returns whether image data is currently shared">icl::core::ImgBase::isIndependent() const </a> </p>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a99781d1d4537a5e77d0763bda632969a">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a8882a9fd1055c02fbb217a99a2dab5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8882a9fd1055c02fbb217a99a2dab5c7">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>null check : null images have 0-Channels and null-size </p>

</div>
</div>
<a id="a9c7e0fc3af37c3b06185f910faf93a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7e0fc3af37c3b06185f910faf93a33">&#9670;&nbsp;</a></span>lut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::lut </td>
          <td>(</td>
          <td class="paramtype">const Type *&#160;</td>
          <td class="paramname"><em>lut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>dst</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>applys a lookup function using the given lookup table </p>
<p>The lookup table has 2^bits entries. Source values are assumed to be in range [0,255]. If the given destination image is 0, a new image is created and returned IPP-accellerated for icl8u </p>

</div>
</div>
<a id="a85d399a33ae609720e9641d53a493fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d399a33ae609720e9641d53a493fc2">&#9670;&nbsp;</a></span>mirror() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::mirror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a>&#160;</td>
          <td class="paramname"><em>eAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOnlyROI</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>perform an in-place mirror operation on the image </p>
<p>performs an in-place mirror operation This function is an in-place version of the flippedCopy function, that is also provided in this class. Its performance is comparable to the out-place function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eAxis</td><td>axis for the mirror operations </td></tr>
    <tr><td class="paramname">bOnlyROI</td><td>if set, only the ROI of this image is mirrored, else the whole image is mirrored. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a4e077af347eb4f366fcb506b37a7a08c">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="ad35768286808f020880b7658701d2932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35768286808f020880b7658701d2932">&#9670;&nbsp;</a></span>mirror() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::mirror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a>&#160;</td>
          <td class="paramname"><em>eAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>oOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>oSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>in-place mirror operation on the given image rect (for internal use) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eAxis</td><td>axis for the mirror operation </td></tr>
    <tr><td class="paramname">iChannel</td><td>channel index to work on </td></tr>
    <tr><td class="paramname">oOffset</td><td>image rects offset to use </td></tr>
    <tr><td class="paramname">oSize</td><td>image rects size to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6dd9c95a7aa606a347c416528915a5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd9c95a7aa606a347c416528915a5f3">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::normalize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales pixel values from given min/max values to new min/max values (for internal use) </p>
<p>Values exceeding the given range are set to the new min/max values. For an automatic scaling use the results of min(),max() as as arguments. (Defining a range allows to compare different images.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>channel index (if set to -1, then operation is </td></tr>
    <tr><td class="paramname">srcRange</td><td>assumption of the images range </td></tr>
    <tr><td class="paramname">dstRange</td><td>image range after the operation</td></tr>
  </table>
  </dd>
</dl>
<p>performed on all channels) </p>

</div>
</div>
<a id="abd6c326bf9622dbb8454bb002ecd84e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6c326bf9622dbb8454bb002ecd84e2">&#9670;&nbsp;</a></span>normalizeAllChannels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::normalizeAllChannels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the channel min/ max range to the new min, max range. </p>
<p>The min/ max range from the source channels are automatically detected, <b>separately</b> for each channel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstRange</td><td>new image range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c44a202ca8a55d71253bce4884c19fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c44a202ca8a55d71253bce4884c19fa">&#9670;&nbsp;</a></span>normalizeChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::normalizeChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the channel from a given min/max range to the new range. </p>
<p>The min/ max range from the source channel is automatically detected, separately for this channel </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>channel index </td></tr>
    <tr><td class="paramname">dstRange</td><td>destination image range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add40399fcecf64cde67ead552dce7695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add40399fcecf64cde67ead552dce7695">&#9670;&nbsp;</a></span>normalizeChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::normalizeChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the channel from a given min/max range to the new range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>channel index </td></tr>
    <tr><td class="paramname">srcRange</td><td>notional image range befor this function call </td></tr>
    <tr><td class="paramname">dstRange</td><td>image range after this function call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d29a48ae9d338cb45cd2cba197bc928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d29a48ae9d338cb45cd2cba197bc928">&#9670;&nbsp;</a></span>normalizeImg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::normalizeImg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the image from a min/max range to the new range. </p>
<p>The min/ max range from the image is automatically detected, combined over all image channels. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstRange</td><td>destination image range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af05578d2ca296f7291e0169d18955fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05578d2ca296f7291e0169d18955fc2">&#9670;&nbsp;</a></span>normalizeImg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::normalizeImg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>srcRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Range.html">utils::Range</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>dstRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the image from a given min/max range to the new range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcRange</td><td>notional image range befor this function call </td></tr>
    <tr><td class="paramname">dstRange</td><td>image range after this function call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed59562ce1c1051f144546f0ae81d546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed59562ce1c1051f144546f0ae81d546">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a>&#160;</td>
          <td class="paramname"><em>eMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sub-pixel access operator, uses given interpolation method </p>

</div>
</div>
<a id="af9fa509c57754dad16b48c7cac3a26c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fa509c57754dad16b48c7cac3a26c2">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pixel access operator </p>
<p>This operator may be used, to access the pixel data of the image e.g. copy of image data: </p><pre>
Img8u oA(Size(320,240),1),oB(Size(320,240),1);
for(int x=0;x&lt;320;x++){
for(int y=0;y&lt;240;y++){
oB(x,y,0)=oA(x,y,0);
}
}
</pre> <h3>Efficiency</h3>
<p>Although the ()-operator is compiled inline, and optimized, it is very slow, as it has to select a channel internally (array access) followed by the data access of the selected channel (return array[x+w*y]). A measurement with a "-O3" binary brought the result that pixel access is up to 10 times faster when working directly with a channel data pointer. Nevertheless, the ()-operator is provided in the Img-class, as it offers a very intuitive access to the pixel data. <b>Note:</b> The also provided <a class="el" href="classicl_1_1core_1_1ImgIterator.html" title="Iterator class used to iterate through an Images ROI-pixels.">ImgIterator</a> provides an additional ROI handling mechanism and is more than 5 times faster. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classicl_1_1core_1_1ImgIterator.html" title="Iterator class used to iterate through an Images ROI-pixels.">ImgIterator</a> </dd>
<dd>
getIterator() </dd>
<dd>
<a class="el" href="classicl_1_1core_1_1Img.html#a9b7294e40dc6cd76b59a841a6d44d148" title="returns the iterator for an images ROI">beginROI()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iX</td><td>X-Position of the referenced pixel </td></tr>
    <tr><td class="paramname">iY</td><td>Y-Position of the referenced pixel </td></tr>
    <tr><td class="paramname">iChannel</td><td>channel index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5fa0d7b4ba1eefac9724d4c057c80c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fa0d7b4ba1eefac9724d4c057c80c8">&#9670;&nbsp;</a></span>operator()() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Type&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>as above, but const </p>

</div>
</div>
<a id="a04de36a29d2ae818cf70777656ef791c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04de36a29d2ae818cf70777656ef791c">&#9670;&nbsp;</a></span>operator()() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1PixelRef.html">PixelRef</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts a pixels channel values at once </p>
<p>This enables the user to write <code> imageA(x,y) = imageB(a,b); </code> </p>

</div>
</div>
<a id="a5ba249bd973e35eee4677fa8c14144fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba249bd973e35eee4677fa8c14144fd">&#9670;&nbsp;</a></span>operator()() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1PixelRef.html">PixelRef</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>as above, but const </p>

</div>
</div>
<a id="a3a72d40a19966a5768eb31bcc188a721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a72d40a19966a5768eb31bcc188a721">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign operator (flat copy of channels) WARNING: Violates const concept. </p>
<p>Both images will share their channel data. Use <a class="el" href="classicl_1_1core_1_1Img.html#a93d412faa3854d765ff2ee18b3478bbd" title="Perform a deep copy of an image.">deepCopy()</a> to obtain a copy of an image which is not attached to the source image. <b>Note:</b> this implicit shallow copy can be exploited to violate ICL's const concept: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func(<span class="keyword">const</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> &amp;a){</div>
<div class="line">  <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> b = a;</div>
<div class="line">  <span class="comment">// b is now unconst and therewith the data of</span></div>
<div class="line">  <span class="comment">// a can b chaned</span></div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tSource</td><td>Reference to source object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf72ca85a24756bbc422b2c93af0957b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf72ca85a24756bbc422b2c93af0957b">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts an image channel </p>
<dl class="section see"><dt>See also</dt><dd>ICLUtils::iclDynMatrix.h </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>valid channel index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9113122b2476ceb53266a8e2e310b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9113122b2476ceb53266a8e2e310b22">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1Channel.html">Channel</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extracts an image channel </p>
<dl class="section see"><dt>See also</dt><dd>ICLUtils::iclDynMatrix.h </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>valid channel index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ffa13e22ecc9f72b1af873c6b342b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffa13e22ecc9f72b1af873c6b342b6d">&#9670;&nbsp;</a></span>printAsMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::printAsMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;5.3&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visROI</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>shows the image value by value at std::out </p>
<p>Warning: <b>SLOW</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>this string is passed to printf internally uchars can be printed e.g. using format="3.0" </td></tr>
    <tr><td class="paramname">visROI</td><td>indicates ROI-pixels with a 'r'-postfix (only if image has no full-ROI) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a677953c11743ad94538ef6abb59f89d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677953c11743ad94538ef6abb59f89d2">&#9670;&nbsp;</a></span>reduce_arrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;typename Tsrc , typename Tdst , int Nsrc, int Ndst, typename ReduceFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::reduce_arrays </td>
          <td>(</td>
          <td class="paramtype">const Tsrc *&#160;</td>
          <td class="paramname"><em>src</em>[Nsrc], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tdst *&#160;</td>
          <td class="paramname"><em>dst</em>[Ndst], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceFunc&#160;</td>
          <td class="paramname"><em>reduce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private helper function called from reduce_channels template </p>

</div>
</div>
<a id="a772c0b531c86e05b5c4799c01c6b0c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772c0b531c86e05b5c4799c01c6b0c2b">&#9670;&nbsp;</a></span>reduce_channels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;typename Tdst , int Nthis, int Ndst, typename ReduceFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::reduce_channels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Tdst &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReduceFunc&#160;</td>
          <td class="paramname"><em>reduce</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for combining image channels into another image. </p>
<p>In some application we want to combine an images channels pixel-by-pixel in any way and to store the result (or even results) in a 2nd image at the corresponding image location. This can easily be performed using the reduce channels template function. Look at the following example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Thresh{</div>
<div class="line">   Thresh(<span class="keywordtype">int</span> t):t(t*3){}</div>
<div class="line">   <span class="keywordtype">int</span> t;</div>
<div class="line">   <span class="keywordtype">void</span> <a class="code" href="classicl_1_1core_1_1Img.html#af9fa509c57754dad16b48c7cac3a26c2">operator()</a>(<span class="keyword">const</span> <a class="code" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a> src[6], <a class="code" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a> dst[1])<span class="keyword"> const</span>{</div>
<div class="line">     *dst = 255*( (<a class="code" href="namespaceicl_1_1qt.html#a291f81bb37c221edb426e01f88ac0db3">abs</a>(src[0]-src[3])+<a class="code" href="namespaceicl_1_1qt.html#a291f81bb37c221edb426e01f88ac0db3">abs</a>(src[1]-src[4])+<a class="code" href="namespaceicl_1_1qt.html#a291f81bb37c221edb426e01f88ac0db3">abs</a>(src[2]-src[5])) &gt; t);</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> bgMask(<span class="keyword">const</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> &amp;image,<span class="keyword">const</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> &amp;bgImage, <span class="keywordtype">int</span> tollerance){</div>
<div class="line">   <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> imageAndBG;</div>
<div class="line">   imageAndBG.<a class="code" href="classicl_1_1core_1_1Img.html#ace5a29b120d0c8193d826d8b94464008">append</a>(&amp;<span class="keyword">const_cast&lt;</span><a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a>&amp;<span class="keyword">&gt;</span>(image));   <span class="comment">// const_cast is ok here,</span></div>
<div class="line">   imageAndBG.append(&amp;<span class="keyword">const_cast&lt;</span><a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a>&amp;<span class="keyword">&gt;</span>(bgImage)); <span class="comment">// we will not change them!</span></div>
<div class="line">   <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> dst(image.getSize(),<a class="code" href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a9f11c5f4c5d0e8ddc461f3f9a7d24721">formatMatrix</a>);</div>
<div class="line">   imageAndBG.reduce_channels&lt;<a class="code" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a>,6,1,Thresh&gt;(dst,Thresh(tollerance));</div>
<div class="line">   <span class="keywordflow">return</span> dst;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="PERF"></a>
Performance</h1>
<p>Source and destination channel count is given as template parameter, to allow the compiler to leave out loops over single values or to unroll short ones. Besides, the compiler is able to use fixed sized arrays on the stack, instead of dynamically allocated heap arrays. By this means performance of reduce_channels is accelerated by factor <b>12</b>.</p>
<h1><a class="anchor" id="BENCHMARK"></a>
Benchmarks</h1>
<p>Exemplarily, the example function above takes about 4-5ms on a 2GHz Core2Duo (using -O4 and -funroll-loop optimization of gcc) on a VGA-sized image (640x480) </p>

</div>
</div>
<a id="a75818ee8fc5fa4efafc168bceeed9e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75818ee8fc5fa4efafc168bceeed9e95">&#9670;&nbsp;</a></span>reinterpretChannels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::reinterpretChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>newFmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shallow copy of this image with a new format (const version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newFmt</td><td>new format to choose. This must be compatible to the channel count of this image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shallow copie with given format of NULL if an error occured </dd></dl>

</div>
</div>
<a id="ae9e156f615d3e151bae8733f9cc07ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e156f615d3e151bae8733f9cc07ac6">&#9670;&nbsp;</a></span>reinterpretChannels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::reinterpretChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>newFmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>poDst</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shallow copy of this image with a new format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newFmt</td><td>new format to choose. This must be compatible to the channel count of this image. </td></tr>
    <tr><td class="paramname">poDst</td><td>destination image (exploited as possible) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shallow copie with given format of NULL if an error occured </dd></dl>

</div>
</div>
<a id="a9aafa9033a79cc690363be696eee8c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aafa9033a79cc690363be696eee8c68">&#9670;&nbsp;</a></span>removeChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::removeChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a specified channel. </p>
<p>Removes a specified channel. If a non-matrix format image looses a channel, the new channel count will not match to the channel count, that is associated with the current format. In this case, a warning is written to std::out, and the format will be set to formatMatrix implicitly. To avoid this warning the programmer has to change the format explicitly before to formatMatrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iChannel</td><td>Index of channel to remove </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a5879e53927eed0d498662dea872b4c3c">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a28eecb397335bbdb760dd554ab2834bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28eecb397335bbdb760dd554ab2834bd">&#9670;&nbsp;</a></span>replaceChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::replaceChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iThisIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>poOtherImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iOtherIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the channel A of this image with the channel B another image. </p>
<p>Both images must have the same width and height. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iThisIndex</td><td>channel to replace </td></tr>
    <tr><td class="paramname">iOtherIndex</td><td>channel to replace with </td></tr>
    <tr><td class="paramname">poOtherImg</td><td>Image that contains the new channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae76b4659e383b4bbeb72dc755aff2d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76b4659e383b4bbeb72dc755aff2d61">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a>&#160;</td>
          <td class="paramname"><em>eScaleMode</em> = <code><a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>perform an in-place resize of the image (keeping the data) </p>
<p>performs an in-place resize operation on the image (IPP-OPTIMIZED) The image size is adapted on demand to the given size, and the image data is scaled. This function is SLOW in comparison to the scaledCopy function that is also provided in this class, as an additional scaling buffer is allocated and released at runtime. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new size of this image </td></tr>
    <tr><td class="paramname">eScaleMode</td><td>interpolation method to use for the scaling operation </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a76d82759360d92599bbb19b7426cbcc6">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="af04acaf11df91b1a4a66ba9855daeb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04acaf11df91b1a4a66ba9855daeb8c">&#9670;&nbsp;</a></span>scaledCopy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::scaledCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a>&#160;</td>
          <td class="paramname"><em>eScaleMode</em> = <code><a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a scaled copy of this image </p>
<p>scaled-, and flipped-Copy functions</p>
<p>Create a scaled copy with given size of an image. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>size of the new image </td></tr>
    <tr><td class="paramname">eScaleMode</td><td>interpolation method to use when scaling the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scaled image </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#af1b841285a034c370a2c740670390da0">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="ad884126bd4c7ef3a8c2cbd7ee6c197b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad884126bd4c7ef3a8c2cbd7ee6c197b2">&#9670;&nbsp;</a></span>scaledCopy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::scaledCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>poDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a>&#160;</td>
          <td class="paramname"><em>eScaleMode</em> = <code><a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a scaled copy of this image </p>
<p>Overloaded function to create a scaled copy of an image. This function gets an Img&lt;Type&gt;* as destination, what allows to apply the operation without any depth-switch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poDst</td><td>destination image pointer, if NULL, a new Img&lt;Type&gt; is created </td></tr>
    <tr><td class="paramname">eScaleMode</td><td>interpolation method to use when scaling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdc010d3e2117664968cd13248376e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc010d3e2117664968cd13248376e93">&#9670;&nbsp;</a></span>scaledCopy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::scaledCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>ppoDst</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a>&#160;</td>
          <td class="paramname"><em>eScaleMode</em> = <code><a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a scaled copy of this image </p>
<p>Create a scaled copy into a given destination image. If the given destination pointer ppoDst is NULL, a deep copy of this image is returned. If ppoDst points to NULL, a new a deep copy of this image is created at *ppoDst. Otherwise, the destination image is only adapted in its depth to this image; its size is hold. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppoDst</td><td>optionally given destination image pointer </td></tr>
    <tr><td class="paramname">eScaleMode</td><td>interpolation method to use when scaling the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scaled image </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a5fb8ce2b2f4c29e6ab5b1e4e8e0cf6d7">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="abd806b9fc0f0bb3923f58fb0e0bbf408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd806b9fc0f0bb3923f58fb0e0bbf408">&#9670;&nbsp;</a></span>scaledCopyROI() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::scaledCopyROI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a>&#160;</td>
          <td class="paramname"><em>eScaleMode</em> = <code><a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a scaled copy of an images ROI with given size </p>
<p>Create a scaled copy with given size of an images ROI. This function behaves identically to the scaledCopy function above, except it is applied on the source images ROI only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>size of the new image </td></tr>
    <tr><td class="paramname">eScaleMode</td><td>interpolation method to use when scaling the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>image containing a scaled instance of the source images ROI </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a37ee2bedf8cfa9e4f9256e0c546db215">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="aee3162639569508c3b4c5c7ce3bd0c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3162639569508c3b4c5c7ce3bd0c8f">&#9670;&nbsp;</a></span>scaledCopyROI() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::scaledCopyROI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>poDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a>&#160;</td>
          <td class="paramname"><em>eScaleMode</em> = <code><a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a scaled copy of this images ROI </p>
<p>Overloaded function to create a scaled copy of an images ROI. This function gets an Img&lt;Type&gt;* as destination, what allows to apply the operation without any depth-switch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poDst</td><td>destination image pointer, if NULL, a new Img&lt;Type&gt; is created </td></tr>
    <tr><td class="paramname">eScaleMode</td><td>interpolation method to use when scaling </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0720172d5824368f0158465eadf02e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0720172d5824368f0158465eadf02e31">&#9670;&nbsp;</a></span>scaledCopyROI() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::scaledCopyROI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>ppoDst</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga9b56af8fa13ba9780f05cb3d3cb0b1d0">scalemode</a>&#160;</td>
          <td class="paramname"><em>eScaleMode</em> = <code><a class="el" href="group__TYPES.html#gga9b56af8fa13ba9780f05cb3d3cb0b1d0a1bebbede16cd56d13118bcef188243ac">interpolateNN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a scaled copy of an images ROI with given destination image </p>
<p>Create a scaled copy of an images ROI with optionally given destination image. This function behaves identically to the scaledCopy function above, except it is applied on the source images ROI only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppoDst</td><td>optionally given destination image pointer </td></tr>
    <tr><td class="paramname">eScaleMode</td><td>interpolation method to use when scaling the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>image containing a scaled instance of the source images ROI </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a30ad97cc59aac69ced9baf0c9b2e40da">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a3ee63b3ff4863e9e640decf8dc7d74df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee63b3ff4863e9e640decf8dc7d74df">&#9670;&nbsp;</a></span>selectChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::selectChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shallow copy of a single image channel of a const image. </p>
<p>This function is a shortcut to use icl::ImgBase::selectChannels(const std::vector&lt;int&gt;&amp;)const to select a single channel from a const image image </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelIndex</td><td>index of the channel to select (if invalid, NULL is returned) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const image containing only the selected channel </dd></dl>

</div>
</div>
<a id="af1b77c10cf3bcd9cca01b87d8dcae892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b77c10cf3bcd9cca01b87d8dcae892">&#9670;&nbsp;</a></span>selectChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::selectChannel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channelIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>poDst</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shallow copy of a single image channel of an image. </p>
<p>This function is a shortcut to use icl::ImgBase::selectChannels(const std::vector&lt;int&gt;&amp;,icl::ImgBase**) to select a single channel from an image </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelIndex</td><td>index of the channel to select (if invalid, NULL is returned) </td></tr>
    <tr><td class="paramname">poDst</td><td>destination image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>image containing only the selected channel </dd></dl>

</div>
</div>
<a id="aa6a6462b385b80e53f59613feae87adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a6462b385b80e53f59613feae87adc">&#9670;&nbsp;</a></span>selectChannels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::selectChannels </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>channelIndices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shallow copy of selected channels of a const image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelIndices</td><td>vector containing channel indices to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const image containing only the selected channels </dd></dl>

</div>
</div>
<a id="a8b6cdbd98b48e1e33dc2ebb8a0dfcc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6cdbd98b48e1e33dc2ebb8a0dfcc91">&#9670;&nbsp;</a></span>selectChannels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::selectChannels </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>channelIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>poDst</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shallow copy of selected channels of an image. </p>
<p>This function can be used if only one or some channels of a given const image should be used in further processing steps. It helps to avoid the necessity of "deepCopy" calls there. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channelIndices</td><td>vector containing channel indices to copy </td></tr>
    <tr><td class="paramname">poDst</td><td>destination image (if Null, a new one is created) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>image containing only the selected channels (as shallow copies) format of that image becomes formatMatrix </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicl_1_1core_1_1Img.html#a5551b9551361837a4cae9a5720be30bd" title="Private assign operator (internally used)">shallowCopy</a> </dd></dl>

</div>
</div>
<a id="a229f911ae0d2e3f99ddb72a11c86e2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229f911ae0d2e3f99ddb72a11c86e2d3">&#9670;&nbsp;</a></span>setChannels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::setChannels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iNewNumChannels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the channel count to a new value </p>
<p>sets the channel count to a new value This function works only on demand, that means, that channels will only be created/deleted, if the new channel count differs from the current. If the current image has a non-matrix format, then the new channel count must match to the channel count associated with this format. If not, a warning is written to std::out, and the format is set to formatMatrix implicitly. To avoid this warning, the image format must be set to formatMatrix explicitly before calling setChannels </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iNewNumChannels</td><td>new channel count </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a001f4e6422da6e1608c0c9b617252fac">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a94731e22c8c728c5468573d4ec00d75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94731e22c8c728c5468573d4ec00d75e">&#9670;&nbsp;</a></span>setSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::setSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resizes the image to new values </p>
<p>resizes the image to new size (image data is lost!) operation is performed on demand - if the image has already the given size, then nothing is done at all. For resizing operation with scaling of the image data use scale. <b>Note:</b> The ROI of the image is set to the hole image using delROI(), notwithstanding if a resize operation was performed or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>new image size (if x or y is &lt; 0, the original width/height is used) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61" title="perform an in-place resize of the image (keeping the data)">scale</a> </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#accb152893b5a99b4667be51d376e3af4">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a5551b9551361837a4cae9a5720be30bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5551b9551361837a4cae9a5720be30bd">&#9670;&nbsp;</a></span>shallowCopy() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::shallowCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Private assign operator (internally used) </p>
<p>This must be kept private! Because the assign operator could otherwise be exploited to violate the <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a>'s const concept </p>

</div>
</div>
<a id="a647aaf316816c5ce3c2d864af1ed5bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647aaf316816c5ce3c2d864af1ed5bde">&#9670;&nbsp;</a></span>shallowCopy() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::shallowCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shallow copy of a const source image. </p>
<p>In contrast to the not const function shallowCopy, the const one does not provide to specify a destination image pointer, because this must neither be const nor not const. If it would be const, it would not be possible to adapt it to correct parameters, otherwise it would violate the const concept as it could be used to change the const result.<br  />
This function can only be used to get const copy of a source image with a special ROI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roi</td><td>ROI of the returned image (Rect::null is not allowed!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shallow copy of this image with specified ROI </dd></dl>

</div>
</div>
<a id="a05c5df2fd4b532bc9ecc63e2e5a3d16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c5df2fd4b532bc9ecc63e2e5a3d16f">&#9670;&nbsp;</a></span>shallowCopy() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::shallowCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>channelIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Time.html">utils::Time</a>&#160;</td>
          <td class="paramname"><em>time</em> = <code><a class="el" href="classicl_1_1utils_1_1Time.html#ace3f64d086f815af887221fd9b186996">utils::Time::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a shallow copy of an image with given (const version) </p><dl class="section see"><dt>See also</dt><dd>the above function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roi</td><td>ROI of the new Image </td></tr>
    <tr><td class="paramname">channelIndices</td><td>indices to select from the source image. These channels are shallow-copied into the destination image (if size is null, all channels are selected) </td></tr>
    <tr><td class="paramname">fmt</td><td>format of the new image (the channel count that is associated with this format must be equal to the channel count that is implicitely defined by the size of the vector channelIndices </td></tr>
    <tr><td class="paramname">time</td><td>new timestamp for the returned image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shallow-copied image </dd></dl>

</div>
</div>
<a id="a54e1fedb8b8ef265a04be9d55e2ff11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e1fedb8b8ef265a04be9d55e2ff11c">&#9670;&nbsp;</a></span>shallowCopy() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::shallowCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>channelIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1utils_1_1Time.html">utils::Time</a>&#160;</td>
          <td class="paramname"><em>time</em> = <code><a class="el" href="classicl_1_1utils_1_1Time.html#ace3f64d086f815af887221fd9b186996">utils::Time::null</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>ppoDst</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a shallow copy of an image with given </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppoDst</td><td>destination image which is exploited if possible, or otherwise reallocated </td></tr>
    <tr><td class="paramname">roi</td><td>ROI of the new Image </td></tr>
    <tr><td class="paramname">channelIndices</td><td>indices to select from the source image. These channels are shallow-copied into the destination image </td></tr>
    <tr><td class="paramname">fmt</td><td>format of the new image (the channel count that is associated with this format must be equal to the channel count that is implicitely defined by the size of the vector channelIndices </td></tr>
    <tr><td class="paramname">time</td><td>new timestamp for the returned image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shallow-copied image </dd></dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a92b893e072ea4c34fc5fbb0dded87e57">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a62c52a66d446dba08c5e579a189c5d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c52a66d446dba08c5e579a189c5d4c">&#9670;&nbsp;</a></span>shallowCopy() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt;* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::shallowCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; Type &gt; *&#160;</td>
          <td class="paramname"><em>poDst</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a shallow copy of the image. </p>
<p>It exploits the given destination image if possible, i.e. if the pixel depth matches. Else this image is released and a new one is created. Optionally a second argument can be specified to get a new image with the given ROI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poDst</td><td>pointer to the destination image pointer If ppoDst is NULL, a new image is created, if ppoDst points to NULL, a new image is created at *ppoDst; </td></tr>
    <tr><td class="paramname">roi</td><td>new ROI of the new image. If Rect::null, the source images roi is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shallow copy of this image </dd></dl>

</div>
</div>
<a id="a3135fed804f1e3d5d55069802c2eb03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3135fed804f1e3d5d55069802c2eb03b">&#9670;&nbsp;</a></span>subPixelLIN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::subPixelLIN </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sub-pixel access using linear interpolation </p>

</div>
</div>
<a id="a882010c19abeb0e5663d583bdd687aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882010c19abeb0e5663d583bdd687aff">&#9670;&nbsp;</a></span>subPixelNN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::subPixelNN </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sub-pixel access using nearest neighbor interpolation </p>

</div>
</div>
<a id="a17d595b1e23108a51dd1e08b51405588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d595b1e23108a51dd1e08b51405588">&#9670;&nbsp;</a></span>subPixelRA() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::subPixelRA </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>xB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>xE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>yB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>yE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>xBMul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>xEMul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>BMul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>yEMul</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05faebaedbe7403274f88dddd58d292c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05faebaedbe7403274f88dddd58d292c">&#9670;&nbsp;</a></span>subPixelRA() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::subPixelRA </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sub-pixel access using region average interpolation </p>

</div>
</div>
<a id="a41db2a5b8f3f923e5bdc5dc1833b2fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41db2a5b8f3f923e5bdc5dc1833b2fae">&#9670;&nbsp;</a></span>swapChannels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::swapChannels </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iIndexA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iIndexB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap channel A and B. </p>
<p>Swap channel A and B. The channel swap operation is shallow; only the channel pointers are swapped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iIndexA</td><td>Index of channel A; </td></tr>
    <tr><td class="paramname">iIndexB</td><td>Index of channel B </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classicl_1_1core_1_1ImgBase.html#a22656ea79677830c993bd26d11bbfd08">icl::core::ImgBase</a>.</p>

</div>
</div>
<a id="a41f940015b91291e7335c79cdaac4860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f940015b91291e7335c79cdaac4860">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction , class dstType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;dstType&gt;&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL based "transform" implementation applying an Unary function on ROI-pixles with given destination image. </p>
<p>Internally this function uses std::transform. Example:<br  />
</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Quick_8h.html">ICLQt/Quick.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> <a class="code" href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl8u</a> t_func(<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;f){</div>
<div class="line">  <span class="keywordflow">return</span> f&gt;128 ? 0 : 255;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">ImgQ</a> a = <a class="code" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">scale</a>(<a class="code" href="namespaceicl_1_1qt.html#a0535967935289099b53e7035df6d33c8">create</a>(<span class="stringliteral">&quot;parrot&quot;</span>),0.2);</div>
<div class="line">  <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> b(a.getParams());</div>
<div class="line"> </div>
<div class="line">  a.transform(t_func,b);</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a6d5888c806c5f70d6ab41384717d772b">show</a>(<a class="code" href="namespaceicl_1_1qt.html#a4b7ec064d50f72a77db212bdbebbf1fb">cvt</a>(b));</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>unary function of functor implementing "dstType operator()(const Type &amp;val)" </td></tr>
    <tr><td class="paramname">dst</td><td>destination image with identical ROI-size and channel count (compared to this image) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a304bef854c2721778839a13285ab7682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304bef854c2721778839a13285ab7682">&#9670;&nbsp;</a></span>transform_C()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;typename UnaryFunction , class dstType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;dstType&gt;&amp; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::transform_C </td>
          <td>(</td>
          <td class="paramtype">UnaryFunction&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; dstType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>STL based "transform" implementation applying an Unary function on ROI-pixles with given destination image. </p>
<p>Internally this function uses std::transform. Example:<br  />
</p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Quick_8h.html">ICLQt/Quick.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Thresh{</div>
<div class="line">  <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="classicl_1_1core_1_1Img.html#af9fa509c57754dad16b48c7cac3a26c2">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">float</span> &amp;f){ <span class="keywordflow">return</span> f&gt;128 ? 0 : 255; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">ImgQ</a> a = <a class="code" href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">scale</a>(<a class="code" href="namespaceicl_1_1qt.html#a0535967935289099b53e7035df6d33c8">create</a>(<span class="stringliteral">&quot;parrot&quot;</span>),0.2);</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">ImgQ</a> b(a.getParams());</div>
<div class="line"> </div>
<div class="line">  a.transform_C(Thresh(),1,2,b);</div>
<div class="line">  <a class="code" href="namespaceicl_1_1qt.html#a6d5888c806c5f70d6ab41384717d772b">show</a>(b);</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>unary function of functor implementing "dstType operator()(const Type &amp;val)" </td></tr>
    <tr><td class="paramname">srcChannel</td><td>valid channel index for this image </td></tr>
    <tr><td class="paramname">dstChannel</td><td>valid channel index for dst image </td></tr>
    <tr><td class="paramname">dst</td><td>destination image with identical ROI-size to this images ROI-size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af5ebe1b9427826145e1fc3b47687c227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ebe1b9427826145e1fc3b47687c227">&#9670;&nbsp;</a></span>combineImages</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<div class="memtemplate">
template&lt;class ImgType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const friend ImgType* combineImages </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const ImgType * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>ppoDst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a995351d0a5f5902b08320986899dee1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995351d0a5f5902b08320986899dee1e">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const typedef Type* <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const iterator type (just a const pointer) </p>

</div>
</div>
<a id="adecc6a75df36a631d62a98317b121b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecc6a75df36a631d62a98317b121b59">&#9670;&nbsp;</a></span>const_roi_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const typedef <a class="el" href="classicl_1_1core_1_1ImgIterator.html">ImgIterator</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::const_roi_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>type definition for a const ROI iterator </p>

</div>
</div>
<a id="a42c2f621cce7b4ad126bead38dca2058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c2f621cce7b4ad126bead38dca2058">&#9670;&nbsp;</a></span>m_vecChannels</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structicl_1_1utils_1_1SmartArray.html">utils::SmartArray</a>&lt;Type&gt; &gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::m_vecChannels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internally used storage for the image channels </p>

</div>
</div>
<a id="ac0cd34ad63d1ac567d02853fe2e53b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0cd34ad63d1ac567d02853fe2e53b6d">&#9670;&nbsp;</a></span>null</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt;Type&gt; <a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img</a>&lt; Type &gt;::null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>null sized and null channel image </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/icl/icl/ICLCore/src/ICLCore/<a class="el" href="Img_8h_source.html">Img.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassicl_1_1core_1_1Img_html_ace5a29b120d0c8193d826d8b94464008"><div class="ttname"><a href="classicl_1_1core_1_1Img.html#ace5a29b120d0c8193d826d8b94464008">icl::core::Img::append</a></div><div class="ttdeci">void append(const Img&lt; Type &gt; *src, int iChannel=-1)</div><div class="ttdoc">private append function for a specified image channel</div></div>
<div class="ttc" id="anamespaceicl_html_a03c5fb8fe5763e6a400b4651b0eec2d7"><div class="ttname"><a href="namespaceicl.html#a03c5fb8fe5763e6a400b4651b0eec2d7">icl::icl8u</a></div><div class="ttdeci">Ipp8u icl8u</div><div class="ttdoc">8Bit unsigned integer type for the ICL</div><div class="ttdef"><b>Definition:</b> BasicTypes.h:92</div></div>
<div class="ttc" id="aclassicl_1_1core_1_1Img_html_a4129ac9e0f9c554e274505919ef5536c"><div class="ttname"><a href="classicl_1_1core_1_1Img.html#a4129ac9e0f9c554e274505919ef5536c">icl::core::Img::detached</a></div><div class="ttdeci">Img&lt; Type &gt; detached() const</div><div class="ttdoc">Utility method, that returns a detached version of this image.</div><div class="ttdef"><b>Definition:</b> Img.h:810</div></div>
<div class="ttc" id="anamespaceicl_1_1qt_html_a291f81bb37c221edb426e01f88ac0db3"><div class="ttname"><a href="namespaceicl_1_1qt.html#a291f81bb37c221edb426e01f88ac0db3">icl::qt::abs</a></div><div class="ttdeci">ICLQt_API ImgQ abs(const ImgQ &amp;image)</div><div class="ttdoc">calls abs ( each pixel)</div></div>
<div class="ttc" id="agroup__TYPES_html_gga7cc417c2bd265954eaa29e4a17977410a9f11c5f4c5d0e8ddc461f3f9a7d24721"><div class="ttname"><a href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a9f11c5f4c5d0e8ddc461f3f9a7d24721">icl::core::formatMatrix</a></div><div class="ttdeci">@ formatMatrix</div><div class="ttdef"><b>Definition:</b> Types.h:133</div></div>
<div class="ttc" id="anamespaceicl_1_1qt_html_a6d5888c806c5f70d6ab41384717d772b"><div class="ttname"><a href="namespaceicl_1_1qt.html#a6d5888c806c5f70d6ab41384717d772b">icl::qt::show</a></div><div class="ttdeci">ICLQt_API void show(const icl::core::ImgBase &amp;image)</div><div class="ttdoc">shows an image using TestImages::show</div></div>
<div class="ttc" id="aImg_8h_html"><div class="ttname"><a href="Img_8h.html">Img.h</a></div></div>
<div class="ttc" id="agroup__TYPES_html_gga7cc417c2bd265954eaa29e4a17977410a14b76eca3cc1e9ac323ba2308a15f49e"><div class="ttname"><a href="group__TYPES.html#gga7cc417c2bd265954eaa29e4a17977410a14b76eca3cc1e9ac323ba2308a15f49e">icl::core::formatRGB</a></div><div class="ttdeci">@ formatRGB</div><div class="ttdef"><b>Definition:</b> Types.h:128</div></div>
<div class="ttc" id="aQuick_8h_html"><div class="ttname"><a href="Quick_8h.html">Quick.h</a></div></div>
<div class="ttc" id="anamespaceicl_1_1qt_html_a1159e2c52a8cbbad9814a3269ea3156c"><div class="ttname"><a href="namespaceicl_1_1qt.html#a1159e2c52a8cbbad9814a3269ea3156c">icl::qt::ImgQ</a></div><div class="ttdeci">core::Img&lt; ICL_QUICK_TYPE &gt; ImgQ</div><div class="ttdoc">typedef for the quick images type (this time core::Img&lt;icl32f&gt;)</div><div class="ttdef"><b>Definition:</b> Quick.h:106</div></div>
<div class="ttc" id="aclassicl_1_1core_1_1Img_html_ae76b4659e383b4bbeb72dc755aff2d61"><div class="ttname"><a href="classicl_1_1core_1_1Img.html#ae76b4659e383b4bbeb72dc755aff2d61">icl::core::Img::scale</a></div><div class="ttdeci">virtual void scale(const utils::Size &amp;s, scalemode eScaleMode=interpolateNN)</div><div class="ttdoc">perform an in-place resize of the image (keeping the data)</div></div>
<div class="ttc" id="anamespaceicl_1_1qt_html_a708f0f4e044223db05553e6223d3801a"><div class="ttname"><a href="namespaceicl_1_1qt.html#a708f0f4e044223db05553e6223d3801a">icl::qt::norm</a></div><div class="ttdeci">ICLQt_API core::Img&lt; T &gt; norm(const core::Img&lt; T &gt; &amp;image)</div><div class="ttdoc">normalize an images range to [0,255]</div></div>
<div class="ttc" id="anamespaceicl_1_1qt_html_a0535967935289099b53e7035df6d33c8"><div class="ttname"><a href="namespaceicl_1_1qt.html#a0535967935289099b53e7035df6d33c8">icl::qt::create</a></div><div class="ttdeci">ICLQt_API core::Img&lt; T &gt; create(const std::string &amp;name, core::format fmt=icl::core::formatRGB)</div><div class="ttdoc">create a test image (converted to destination core::format) (affinity for floats)</div></div>
<div class="ttc" id="aclassicl_1_1core_1_1Img_html_af9fa509c57754dad16b48c7cac3a26c2"><div class="ttname"><a href="classicl_1_1core_1_1Img.html#af9fa509c57754dad16b48c7cac3a26c2">icl::core::Img::operator()</a></div><div class="ttdeci">Type &amp; operator()(int iX, int iY, int iChannel)</div><div class="ttdoc">pixel access operator</div><div class="ttdef"><b>Definition:</b> Img.h:449</div></div>
<div class="ttc" id="anamespaceicl_1_1qt_html_a4b7ec064d50f72a77db212bdbebbf1fb"><div class="ttname"><a href="namespaceicl_1_1qt.html#a4b7ec064d50f72a77db212bdbebbf1fb">icl::qt::cvt</a></div><div class="ttdeci">ICLQt_API ImgQ cvt(const core::Img8u &amp;image)</div><div class="ttdoc">Converts a given core::Img8u into an ImgQ.</div></div>
<div class="ttc" id="agroup__TYPES_html_gab9ebfd5e35116d194189c8f233607414"><div class="ttname"><a href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">icl::core::Img8u</a></div><div class="ttdeci">Img&lt; icl8u &gt; Img8u</div><div class="ttdoc">typedef for 8bit integer images</div><div class="ttdef"><b>Definition:</b> Types.h:98</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 14:54:51 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
