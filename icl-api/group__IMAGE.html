<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): Image Classes and Support Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Image Classes and Support Functions</div>  </div>
</div><!--header-->
<div class="contents">

<p>ICL is a C++ image processing library, developed in the <a href="www.ni.www.techfak.uni-bielefeld.de">Neuroinformatics Group</a> at the <a href="www.uni-bielefeld.de">University of Bielefeld in Germany</a>. ICL provides a large set of features for image acquisition, image processing and image visualization. During the design and development process, the following main goals took center stage:  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Channel.html">icl::core::Channel&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility helper class for faster and more convenient access to single channel image data.  <a href="classicl_1_1core_1_1Channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1Img.html">icl::core::Img&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> class implements the <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> Image interface with type specific functionalities.  <a href="classicl_1_1core_1_1Img.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1core_1_1ImgBasePtrPtr.html">icl::core::ImgBasePtrPtr&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility class that helps for an implicit conversion between <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>* to ImgBase**  <a href="structicl_1_1core_1_1ImgBasePtrPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgBase.html">icl::core::ImgBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> is the Image-Interface class that provides save access to underlying Img-template.  <a href="classicl_1_1core_1_1ImgBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgIterator.html">icl::core::ImgIterator&lt; Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator class used to iterate through an Images ROI-pixels.  <a href="classicl_1_1core_1_1ImgIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1core_1_1ImgParams.html">icl::core::ImgParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classicl_1_1core_1_1ImgParams.html" title="The ImgParams class stores all image parameters.">ImgParams</a> class stores all image parameters.  <a href="classicl_1_1core_1_1ImgParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga00a4ca4fd769f2fe4f0466235948a6cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga00a4ca4fd769f2fe4f0466235948a6cc">icl::core::imgNew</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d=<a class="el" href="group__TYPES.html#gga53af74cee38afb59cc3738a1042a1ceaabf13298b91874fafb68eedffe1a5f3de">depth8u</a>, const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;params=<a class="el" href="classicl_1_1core_1_1ImgParams.html#a678ccf92d76d27b2acbcd1a5f3c507d3">ImgParams::null</a>)</td></tr>
<tr class="memdesc:ga00a4ca4fd769f2fe4f0466235948a6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new image instance of the given depth type and with given parameters  <a href="group__IMAGE.html#ga00a4ca4fd769f2fe4f0466235948a6cc">More...</a><br /></td></tr>
<tr class="separator:ga00a4ca4fd769f2fe4f0466235948a6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d45bf9adc5c22962102a84d1b509f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga9d45bf9adc5c22962102a84d1b509f70">icl::core::imgNew</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:ga9d45bf9adc5c22962102a84d1b509f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> (see the above function for more details)  <a href="group__IMAGE.html#ga9d45bf9adc5c22962102a84d1b509f70">More...</a><br /></td></tr>
<tr class="separator:ga9d45bf9adc5c22962102a84d1b509f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e36ef7b1ad84ae52d9853be533ea164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga9e36ef7b1ad84ae52d9853be533ea164">icl::core::imgNew</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels=1, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:ga9e36ef7b1ad84ae52d9853be533ea164"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> (see the above function for more details)  <a href="group__IMAGE.html#ga9e36ef7b1ad84ae52d9853be533ea164">More...</a><br /></td></tr>
<tr class="separator:ga9e36ef7b1ad84ae52d9853be533ea164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefe02e15f9f47fa6de8b26084bb4b55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gacefe02e15f9f47fa6de8b26084bb4b55">icl::core::imgNew</a> (<a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:gacefe02e15f9f47fa6de8b26084bb4b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> (see the above function for more details)  <a href="group__IMAGE.html#gacefe02e15f9f47fa6de8b26084bb4b55">More...</a><br /></td></tr>
<tr class="separator:gacefe02e15f9f47fa6de8b26084bb4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34211f4aa82c399e327b88ac97f7acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gaa34211f4aa82c399e327b88ac97f7acc">icl::core::ensureDepth</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoImage, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> eDepth)</td></tr>
<tr class="memdesc:gaa34211f4aa82c399e327b88ac97f7acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has the specified depth  <a href="group__IMAGE.html#gaa34211f4aa82c399e327b88ac97f7acc">More...</a><br /></td></tr>
<tr class="separator:gaa34211f4aa82c399e327b88ac97f7acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e1c2a9513b3034fc6fca1d34d42d05e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga8e1c2a9513b3034fc6fca1d34d42d05e">icl::core::ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;params)</td></tr>
<tr class="memdesc:ga8e1c2a9513b3034fc6fca1d34d42d05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has given depth and parameters  <a href="group__IMAGE.html#ga8e1c2a9513b3034fc6fca1d34d42d05e">More...</a><br /></td></tr>
<tr class="separator:ga8e1c2a9513b3034fc6fca1d34d42d05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32756378c80a568e326011a71765852a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga32756378c80a568e326011a71765852a">icl::core::ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:ga32756378c80a568e326011a71765852a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has given depth, size, number of channels and ROI  <a href="group__IMAGE.html#ga32756378c80a568e326011a71765852a">More...</a><br /></td></tr>
<tr class="separator:ga32756378c80a568e326011a71765852a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1aa2160788b3841e3ed0018fcea84b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga1e1aa2160788b3841e3ed0018fcea84b">icl::core::ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:ga1e1aa2160788b3841e3ed0018fcea84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has given depth, size, format and ROI  <a href="group__IMAGE.html#ga1e1aa2160788b3841e3ed0018fcea84b">More...</a><br /></td></tr>
<tr class="separator:ga1e1aa2160788b3841e3ed0018fcea84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae37ff3722e02895ea9d7226ff7d984e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gae37ff3722e02895ea9d7226ff7d984e9">icl::core::ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, <a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a> d, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size, int channels, <a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a> fmt, const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;roi=<a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a>)</td></tr>
<tr class="memdesc:gae37ff3722e02895ea9d7226ff7d984e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that an image has given parameters  <a href="group__IMAGE.html#gae37ff3722e02895ea9d7226ff7d984e9">More...</a><br /></td></tr>
<tr class="separator:gae37ff3722e02895ea9d7226ff7d984e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d25708989e461d211172a8d6abd91af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga9d25708989e461d211172a8d6abd91af">icl::core::ensureCompatible</a> (<a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **dst, const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *src)</td></tr>
<tr class="memdesc:ga9d25708989e461d211172a8d6abd91af"><td class="mdescLeft">&#160;</td><td class="mdescRight">ensures that the destination image gets same depth, size, channel count, depth, format and ROI as source image  <a href="group__IMAGE.html#ga9d25708989e461d211172a8d6abd91af">More...</a><br /></td></tr>
<tr class="separator:ga9d25708989e461d211172a8d6abd91af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bef8dfe9aaafedf642c6da1d372523"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga05bef8dfe9aaafedf642c6da1d372523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1core_1_1ImgBasePtrPtr.html">ImgBasePtrPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga05bef8dfe9aaafedf642c6da1d372523">icl::core::bpp</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *image)</td></tr>
<tr class="memdesc:ga05bef8dfe9aaafedf642c6da1d372523"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to cast an <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> implicitly into an <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> **  <a href="group__IMAGE.html#ga05bef8dfe9aaafedf642c6da1d372523">More...</a><br /></td></tr>
<tr class="separator:ga05bef8dfe9aaafedf642c6da1d372523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab279f13b8c52fb2b960296fb8f2d171d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab279f13b8c52fb2b960296fb8f2d171d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1core_1_1ImgBasePtrPtr.html">ImgBasePtrPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gab279f13b8c52fb2b960296fb8f2d171d">icl::core::bpp</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; &amp;image)</td></tr>
<tr class="memdesc:gab279f13b8c52fb2b960296fb8f2d171d"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility function to cast an <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>* implicitly into an <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> **  <a href="group__IMAGE.html#gab279f13b8c52fb2b960296fb8f2d171d">More...</a><br /></td></tr>
<tr class="separator:gab279f13b8c52fb2b960296fb8f2d171d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac255b232de05b40341dc48a2c1b1cbfc"><td class="memTemplParams" colspan="2">template&lt;class ImgType &gt; </td></tr>
<tr class="memitem:gac255b232de05b40341dc48a2c1b1cbfc"><td class="memTemplItemLeft" align="right" valign="top">const ImgType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gac255b232de05b40341dc48a2c1b1cbfc">icl::core::combineImages</a> (const std::vector&lt; const ImgType * &gt; &amp;vec)</td></tr>
<tr class="memdesc:gac255b232de05b40341dc48a2c1b1cbfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine several images using shallow copy.  <a href="group__IMAGE.html#gac255b232de05b40341dc48a2c1b1cbfc">More...</a><br /></td></tr>
<tr class="separator:gac255b232de05b40341dc48a2c1b1cbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9748a47b96e8122edbaad78f4b42511b"><td class="memTemplParams" colspan="2">template&lt;class ImgType &gt; </td></tr>
<tr class="memitem:ga9748a47b96e8122edbaad78f4b42511b"><td class="memTemplItemLeft" align="right" valign="top">ImgType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga9748a47b96e8122edbaad78f4b42511b">icl::core::combineImages</a> (const std::vector&lt; ImgType * &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga9748a47b96e8122edbaad78f4b42511b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine several images using shallow copy. Non-const version.  <a href="group__IMAGE.html#ga9748a47b96e8122edbaad78f4b42511b">More...</a><br /></td></tr>
<tr class="separator:ga9748a47b96e8122edbaad78f4b42511b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7e8c4530584e4ca897a65c52a7786f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaea7e8c4530584e4ca897a65c52a7786f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gaea7e8c4530584e4ca897a65c52a7786f">icl::core::deepCopyChannel</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *src, int srcC, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *dst, int dstC)</td></tr>
<tr class="memdesc:gaea7e8c4530584e4ca897a65c52a7786f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the channel from one image to another.  <a href="group__IMAGE.html#gaea7e8c4530584e4ca897a65c52a7786f">More...</a><br /></td></tr>
<tr class="separator:gaea7e8c4530584e4ca897a65c52a7786f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ce00bcf79e53e02b993d7d000932dc"><td class="memTemplParams" colspan="2">template&lt;class S , class D &gt; </td></tr>
<tr class="memitem:ga74ce00bcf79e53e02b993d7d000932dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga74ce00bcf79e53e02b993d7d000932dc">icl::core::convertChannel</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; S &gt; *src, int srcC, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; D &gt; *dst, int dstC)</td></tr>
<tr class="memdesc:ga74ce00bcf79e53e02b993d7d000932dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies/converts the data from one image to another image (IPP-OPTIMIZED)  <a href="group__IMAGE.html#ga74ce00bcf79e53e02b993d7d000932dc">More...</a><br /></td></tr>
<tr class="separator:ga74ce00bcf79e53e02b993d7d000932dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac583e47b8967070361ea3ce603b9070d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac583e47b8967070361ea3ce603b9070d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gac583e47b8967070361ea3ce603b9070d">icl::core::clearChannelROI</a> (<a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *im, int c, T clearVal, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;offs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;size)</td></tr>
<tr class="memdesc:gac583e47b8967070361ea3ce603b9070d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets an arbitrary image ROI to a given value  <a href="group__IMAGE.html#gac583e47b8967070361ea3ce603b9070d">More...</a><br /></td></tr>
<tr class="separator:gac583e47b8967070361ea3ce603b9070d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702018256e7c778be8d75029b4c171a5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga702018256e7c778be8d75029b4c171a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga702018256e7c778be8d75029b4c171a5">icl::core::deepCopyChannelROI</a> (const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *src, int srcC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;srcOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;srcSize, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *dst, int dstC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;dstOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;dstSize)</td></tr>
<tr class="memdesc:ga702018256e7c778be8d75029b4c171a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">copies the channel roi from one image to another  <a href="group__IMAGE.html#ga702018256e7c778be8d75029b4c171a5">More...</a><br /></td></tr>
<tr class="separator:ga702018256e7c778be8d75029b4c171a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
scaling of channel ROIs</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpd35635495181165c1fe2e8499aaa1aa6"></a> scales an image channels ROI into another images ROI (with implicit type conversion) (IPP-OPTIMIZED) </p>
</td></tr>
<tr class="memitem:ga88f84be8075e9ce4bf05c7707996d8bf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga88f84be8075e9ce4bf05c7707996d8bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga88f84be8075e9ce4bf05c7707996d8bf">icl::core::flippedCopyChannelROI</a> (<a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a> eAxis, const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *src, int srcC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;srcOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;srcSize, <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *dst, int dstC, const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;dstOffs, const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;dstSize)</td></tr>
<tr class="memdesc:ga88f84be8075e9ce4bf05c7707996d8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror copy ROI data from one image to the ROI of another image (IPP-OPTIMIZED)  <a href="group__IMAGE.html#ga88f84be8075e9ce4bf05c7707996d8bf">More...</a><br /></td></tr>
<tr class="separator:ga88f84be8075e9ce4bf05c7707996d8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7343097d928bee1057f6356b38cb3ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#ga7343097d928bee1057f6356b38cb3ec5">icl::core::flippedCopy</a> (<a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a> eAxis, const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poSrc, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0)</td></tr>
<tr class="memdesc:ga7343097d928bee1057f6356b38cb3ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror copy of an image from source to destination image (1:1 copy)  <a href="group__IMAGE.html#ga7343097d928bee1057f6356b38cb3ec5">More...</a><br /></td></tr>
<tr class="separator:ga7343097d928bee1057f6356b38cb3ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9dad01f2988ee2ff540f4ad900a2e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__IMAGE.html#gab9dad01f2988ee2ff540f4ad900a2e1a">icl::core::flippedCopyROI</a> (<a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a> eAxis, const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *poSrc, <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **ppoDst=0)</td></tr>
<tr class="memdesc:gab9dad01f2988ee2ff540f4ad900a2e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">mirror copy of an images ROI into a destination images ROI  <a href="group__IMAGE.html#gab9dad01f2988ee2ff540f4ad900a2e1a">More...</a><br /></td></tr>
<tr class="separator:gab9dad01f2988ee2ff540f4ad900a2e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ICL is a C++ image processing library, developed in the <a href="www.ni.www.techfak.uni-bielefeld.de">Neuroinformatics Group</a> at the <a href="www.uni-bielefeld.de">University of Bielefeld in Germany</a>. ICL provides a large set of features for image acquisition, image processing and image visualization. During the design and development process, the following main goals took center stage: </p>
<ul>
<li>Optimal Performace (ensured by internal use of Intel IPP, see <a class="el" href="group__IMAGE.html#IPP_MKL">IPP/MKL-optimization</a>)</li>
<li>Simple and easy to use C++-interface (see <a class="el" href="group__IMAGE.html#EXAMPLE">Simple Viewer Application for Arbitrary Camera Sources</a>)</li>
<li>Platform-Independence (currently linux and MacOS-X are supported)</li>
<li>No compulsory software dependencies (see <a class="el" href="group__IMAGE.html#EXTERNAL_DEPS">Optional 3rd Party Dependencies</a>)</li>
</ul>
<p>ICL provides all necessary building blocks for the development of complex computer-vision applications.</p>
<h1><a class="anchor" id="EXAMPLE"></a>
Simple Viewer Application for Arbitrary Camera Sources</h1>
<table border="0">
<tr>
<td><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Common_8h.html">ICLQt/Common.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">GUI gui;</div>
<div class="line">GenericGrabber grabber;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> init(){</div>
<div class="line">  grabber.init(<a class="code" href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">pa</a>(<span class="stringliteral">&quot;-i&quot;</span>));</div>
<div class="line">  gui &lt;&lt; Image().handle(<span class="stringliteral">&quot;image&quot;</span>) &lt;&lt; Show();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> run(){</div>
<div class="line">  gui[<span class="stringliteral">&quot;image&quot;</span>] = grabber.grab();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> n, <span class="keywordtype">char</span> **args){</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceicl_1_1qt.html#a88710c0c58ee1df2517ef4b57894d05d">ICLApp</a>(n,args,<span class="stringliteral">&quot;-input|-i(2)&quot;</span>,init,run).<a class="code" href="classicl_1_1qt_1_1ICLApplication.html#a117474bd97aa1702e0884d8d37372752">exec</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p class="endtd"></p>
</td><td><div class="image">
<img src="viewer.jpg" alt=""/>
</div>
 </td></tr>
</table>
<ul>
<li>Save this file as <code>viewer.cpp</code></li>
<li>Setup your <code>PKG_CONFIG_PATH</code> variable</li>
<li>Compile with <code>CXXFLAGS=<code>pkg-config --libs --cflags icl</code> make viewer</code></li>
<li>Plug in a camera</li>
<li>Run your application e.g. with <code>./viewer -input unicap '*'</code></li>
</ul>
<p>More examples for using ICL are given in the online ICL-tutorial on &lt;a href="<a href="http://www.iclcv.org">http://www.iclcv.org</a>&gt;ICL's website</p>
<h1><a class="anchor" id="PACKAGES"></a>
Packages</h1>
<table border="0">
<tr>
<td><p class="starttd">ICL consists of currently 11 packages that are listed in the main menu at the left.</p>
<ul>
<li><b>ICLUtils</b> Contains general purpose functions and classes that are currently not part of the C++-STL (e.g. threads or matrices).</li>
<li><b>ICLCore</b> basically provides class definitions for ICL's image classes Img and ImgBase and related global functions.</li>
<li><b>ICLCC</b> provides functions and classes for color conversion.</li>
<li><b>ICLIO</b> extends the range of functions by input and output classes. Camera grabbers different camera types (e.g. IEEE-1394 or Video-4-Linux) can be found here as well a video file grabber or a file writer class.</li>
<li><b>ICLCV</b> contains classes for blob detection and tracking and for connected component analysis.</li>
<li><b>ICLFilter</b> provides classes for most common image filters like linear filters and morphological operators.</li>
<li><b>ICLQuick</b> provides almost 100 functions and functors for rapid prototyping (no longer exists)</li>
<li><b>ICLGeom</b> contains classes for 3D-modelling and camera calibration.</li>
<li><b>ICLQt*</b> contains a Qt-4 based GUI-API that facilitates creation of simple and complex GUI applications significantly. And of course a powerful image visualisation widget called ICLWidget is provided.</li>
<li><b>ICLMarkers</b> contains a generic Fiducial Marker detection framework</li>
<li><b>ICLMath</b> contains high level classes like a hough-transformation-based line detector or generic self organizing map (SOM) implementation.</li>
<li><b>ICLOpenCV*</b> offers functions for shallow and deep copies from ICL-images types into OpenCV's images types and v.v.</li>
</ul>
<p class="intertd">(*) The packages ICLQt and ICLOpenCV depend compulsorily on the corresponding external software dependencies Qt4 and OpenCV. Consequently these packages are not available if these dependencies are missing.</p>
<p class="endtd"></p>
</td><td><div class="image">
<img src="icl-components.png" alt=""/>
<div class="caption">
ICL's component collaboration diagram</div></div>
 </td></tr>
</table>
<h1><a class="anchor" id="THE_IMAGE"></a>
The Image Classes</h1>
<table border="0">
<tr>
<td><p class="starttd"></p>
<p class="intertd">We use inheritance and class templates for ICL's image representation: The ImgBase class defines an abstract interface, that manages all image information except image pixel data. These abstract image features are:</p>
<ul>
<li>size (in pixels)</li>
<li>channel count (see <b>channel concept</b>)</li>
<li>type of pixels (see <b>data types</b>)</li>
<li>color format (see <b>color formats</b>)</li>
<li>raw image data access</li>
<li>Region of Interest (see <b>Region of Interests</b> <a class="el" href="group__IMAGE.html#ROI">ROI-Support</a> (ROI))</li>
<li>a time stamp</li>
</ul>
<p class="intertd">The ImgBase interface is implemented by the template class <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> which implements all abstract ImgBase-functions and aggregates a vector of planar image channel data pointers. Internally, these channel data pointers use reference counting to allow shallow image copies. <br  />
<b>Img's copy-constructor and assignment operator use shallow copy on default!</b></p>
<p class="intertd">The <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> template also adds functions for type-safe data access:</p>
<ul>
<li>access to channel data pointers (using <code>getData(channel)</code> or <code>begin(channel)</code>)</li>
<li>extraction of single image channels (using <code>operator [](int)</code>)</li>
<li>extraction of single image pixels (using <code>operator()(x,y,channel-index)</code> for single values or <code>operator()(x,y)</code> to obtain a pixel vector)</li>
<li>iterator based access to data of a given channel (using <code>begin(channel)</code> and <code>end(channel)</code>)</li>
<li>iterator based access to the ROI-pixels of a given channel (using <code>beginROI(channel)</code> and <code>endROI(channel)</code>)</li>
</ul>
<p class="endtd"></p>
</td><td><div class="image">
<img src="image-sketch.png" alt=""/>
<div class="caption">
A sketch of ICL's image type Img&lt;T&gt;</div></div>
 </td></tr>
</table>
<h1><a class="anchor" id="SEC_DATA_ORIGN"></a>
Data Origin</h1>
<p>As most common image formats image processing use the upper left image corner as data origen, ICL follows this convention as well. Howerver, many image operation like filtering or thresholding works without regarding the image contents at all. Nonetheless, we suggest to use this standard, as it is particularly important for I/O-routines or image visualization and - not at least - whenever discussing about ICL images.</p>
<h1><a class="anchor" id="Channel-Concept"></a>
Channel-Concept</h1>
<p>The Img treats images as a stack of image slices &ndash; <b>channels</b>. Channels can be shared by multiple Img instances, which is especially important for fast shallow images copies. Actually, it is possible to freely compose existing channels (within several "parent images") to another new image.</p>
<p>Attention: The newly <em>composed</em> image shares its channel data with the original images, such that modifications will effect all images equally. In order to get an independent image a deep-copy as well as a so called detach method are provided. The latter replaces the "shared" image channel(s) with new independent ones. Shared channel data are stored using the boost-like shared pointer class SmartPtr, which uses reference counting for autonomous garbage collection in order to realease <em>unused</em> image channels.</p>
<h1><a class="anchor" id="DATA_TYPES"></a>
Data-Types</h1>
<p>The Img template is not implemented completely inline to reduce compilation expense. Therefore, the Img template is instantiated for the following types T</p>
<ul>
<li><b>icl8u</b> 8bit unsigned char</li>
<li><b>icl16s</b> 16bit signed integer (short)</li>
<li><b>icl32s</b> 32bit signed integer (int)</li>
<li><b>icl32f</b> 32bit single precision float (float)</li>
<li><b>icl64f</b> 64bit double precision float (double)</li>
</ul>
<p>Derived from this types, Img-classes are predefined as follows</p><ul>
<li><a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;icl8u&gt;</a> : public ImgBase <b>typedef'd to Img8u</b></li>
<li>Img&lt;icl16s&gt; : public ImgBase <b>typedef'd to Img16s</b></li>
<li>Img&lt;icl32s&gt; : public ImgBase <b>typedef'd to Img32s</b></li>
<li><a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;icl32f&gt;</a> : public ImgBase <b>typedef'd to Img32f</b></li>
<li>Img&lt;icl64f&gt; : public ImgBase <b>typedef'd to Img64f</b></li>
</ul>
<p>Each of these data types has several advantages/disadvantages. The greatest disadvantage of the integer types, is their bounded range (e.g. 0-255 for icl8u), which has the effect, that all information has to be scaled to this range, and all image processing functions must take care that no range-overflow occurs during calculation. Furthermore the limited range may cause loss of information - particular in complex systems. However integer types can often be processed significantly faster. In particular the use of 8-bit unsigned integer images relieves the the memory interface due to it's lower memory usage.</p>
<p><b>A nice rule of thumb is: If processing speed matters, use Img8u images whenever it's possible and avoid Img64f because double processing is much slower on (still common) 32 bit machines (as long as you do not really need double precision)</b></p>
<h1><a class="anchor" id="ROI"></a>
ROI-Support</h1>
<p>Each image can be set up with a rectangular region of interest. Nearly all algorithms work only on the pixels within the ROI. If a function does not support ROI handling it will be noticed in the documentation. There are several ways to realize ROI handling in functions. The most common way is to use the ImgIterator with can be accessed using the STL-style functions beginROI(channel) and endROI(channel).</p>
<h1><a class="anchor" id="Color"></a>
Formats</h1>
<p>An ImgBase image provides information about the (color) format, that is associated with the image data represented by the images channels. Color is written in brackets, as not all available formats imply color-information. The most known color space is probably the RGB color space. If an ImgBase image has the format <em>formatRGB</em>, than this implies the following:</p><ul>
<li>the image has exactly 3 channels</li>
<li>the first channel contains RED-Data in range [0,255]</li>
<li>the second channel contains GREEN-Data in range [0,255]</li>
<li>the third channel contains BLUE-Data in range [0,255]</li>
</ul>
<p>All additional implemented functions and classes regard this information. The currently available Img formats are member of the enum Format. A special format: formatMatrix can be used for arbitrary purpose.</p>
<h1><a class="anchor" id="CONST_SEC"></a>
Const-Concept</h1>
<p>ICL Images use the const concept of C++ to ensure pixel data of const Images (of type const ImgBase or more precisely const <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>) is not changed, i.e. it is only accessible for reading. Unfortunately this leads to a conflict with the "shallow-copy" concept of ICL images. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> func(<span class="keyword">const</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> &amp;image){</div>
<div class="line">  <span class="comment">// given image is const -&gt; data must not be changed</span></div>
<div class="line">  <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> x = image;</div>
<div class="line">  <span class="comment">// x is a shallow copy of image (data is shared)</span></div>
<div class="line">  x.<a class="code" href="classicl_1_1core_1_1Img.html#a1da0eda1f6dddd31381b65c794a37983">clear</a>();</div>
<div class="line">  <span class="comment">// this affects also the data of image (which shall not</span></div>
<div class="line">  <span class="comment">// be permitted</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> To avoid this conflict, we tried to forbid creating un-const shallow copies of const images by implementing no default copy constructor: </p><div class="fragment"><div class="line">Img&lt;T&gt;(<span class="keyword">const</span> Img&lt;T&gt; &amp;other) {... }</div>
</div><!-- fragment --><p> but an un-const version of this: </p><div class="fragment"><div class="line">Img&lt;T&gt;(Img&lt;T&gt; &amp;other) {... }</div>
</div><!-- fragment --><p> Here we face some GCC related problem, because gcc is not able for an implicit cast of an <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> to an <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>&amp; in constructor calls: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>Img&lt;T&gt;{ ... };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> create_image(){</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> a = create_image();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here, the compiler gives error: "Can't find constructor Img&lt;T&gt;(Img&lt;T&gt;)". In fact, this constructor can not exist: it must have the following syntax: <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;(Img&lt;T&gt;&amp;)</a></p>
<p>Probably further gcc versions will fix this problem!</p>
<p><b>Until then, we accept the const leak at constructor and assignment operator and reimplemented them as ..(const <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> &amp;other) </b></p>
<h1><a class="anchor" id="IPP_MKL"></a>
IPP/MKL-optimization</h1>
<p>The Intel Integrated Performance Primitives (Intel IPP) and the Intel Math Kernel Library (Intel MKL) are assembler libraries that provide a C-interface to a large set of highly optimized and hardware accelerated functions for image processing, and other numerical problems for all processors providing MMX and SSE instruction sets, i.e. most common Intel and AMD processors. As far as we know, Intel IPP and Intel MKL can be used freely for non-commercial use,<b> but not for research</b>. Fortunately, IPP/MKL support is purely optional. Therefore you can simply develop your application with an ICL-build without IPP/MKL-optimization and re-link it against an optimized ICL-build lateron.</p>
<h2><a class="anchor" id="IPP"></a>
IPP Acceleration</h2>
<p>If Intel IPP is available, it is highly integrated into ICL:</p>
<ul>
<li>a large number of image processing functions are IPP-accelerated</li>
<li>iclXX data types are typedef'ed to ippXX data types rather than to default types from the &lt;stdint.h&gt; header</li>
<li>icl::Size extends the IppSize struct which enables the programmer to pass an icl::Size instance directly to an ipp-function call</li>
<li>the same is true for icl::Point and icl::Rect</li>
<li>all ipp-headers will we available, so IPP-functions can be used directly</li>
</ul>
<p>We tuned the Img-class to facilitate the use of IPP functions.</p>
<h2><a class="anchor" id="MKL"></a>
Intel MKL</h2>
<p>In contrast to the matrix package for small matrices, which is optimized for matrices up to dimensions of 6x6, Intel MKL is optimized for larger matrices. As under certain conditions, MKL is more then 100 times faster, we decided to add MKL support as well. However, MKL is currently only used in the implementation of some DynMatrix multiplication functions in the ICLUtils package.</p>
<h1><a class="anchor" id="ICLCore"></a>
Modules</h1>
<p>If you like to explore the ICLCore documentation by your own, take a look a the following sub modules:<br  />
</p><ol type="1">
<li><a class="el" href="classicl_1_1math_1_1KMeans.html#TYPES">Vector Types</a></li>
<li><a class="el" href="classicl_1_1cv_1_1RunLengthEncoder.html#GENERAL">General Information</a></li>
<li><a class="el" href="group__IMAGE.html">Image Classes and Support Functions</a></li>
<li>STRUTILS</li>
</ol>
<h1><a class="anchor" id="EXTERNAL_DEPS"></a>
Optional 3rd Party Dependencies</h1>
<p>The list of 3rd party dependencies is given on &lt;a href="<a href="http://www.iclcv.org">http://www.iclcv.org</a>&gt;ICL's website </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab279f13b8c52fb2b960296fb8f2d171d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab279f13b8c52fb2b960296fb8f2d171d">&#9670;&nbsp;</a></span>bpp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1core_1_1ImgBasePtrPtr.html">ImgBasePtrPtr</a>&lt;T&gt; icl::core::bpp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>utility function to cast an <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>* implicitly into an <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> ** </p>
<p>see the above function for more details </p>

</div>
</div>
<a id="ga05bef8dfe9aaafedf642c6da1d372523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05bef8dfe9aaafedf642c6da1d372523">&#9670;&nbsp;</a></span>bpp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1core_1_1ImgBasePtrPtr.html">ImgBasePtrPtr</a>&lt;T&gt; icl::core::bpp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>utility function to cast an <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> implicitly into an <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> ** </p>
<p>This function may be useful, whenever you are working with <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> objects are Pointers. As some functions expect ImgBase** arguments to ensure, that the destination image can be adapted even in its depth, this function can be used to get an ImgBase** that points to a pointer of the given image. This is a necessary concept, but mutch additional work, if you are just want to try out some algorithm on your <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>. If you are shure, that the result image will not be adapted by the function you can easily use the bpp-function, which will additionally warn you if this assumption was wrong. The following code example demonstrates this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> apply_func(ImageBase **dst){</div>
<div class="line">   ...</div>
<div class="line">   <span class="comment">// this function may realloc dst</span></div>
<div class="line">}</div>
<div class="line"><a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> src;</div>
<div class="line"><a class="code" href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">Img8u</a> dst;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// without bpp function</span></div>
<div class="line">ImgBase *pDst= &amp;Dst;</div>
<div class="line">apply_func(&amp;src,&amp;pDst);  <span class="comment">// this will cause an error if pDst is reallocated</span></div>
<div class="line">                         <span class="comment">// because stack objects may not be released</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// with bpp function</span></div>
<div class="line">apply_func(&amp;src,<a class="code" href="group__IMAGE.html#ga05bef8dfe9aaafedf642c6da1d372523">bpp</a>(dst)); <span class="comment">// this will cause a warning at maxinum</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="gac583e47b8967070361ea3ce603b9070d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac583e47b8967070361ea3ce603b9070d">&#9670;&nbsp;</a></span>clearChannelROI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icl::core::clearChannelROI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>clearVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets an arbitrary image ROI to a given value </p>
<p>This function is used as basic operation for higher level image operation like Img&lt;T&gt;::clear(T value). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">im</td><td>image </td></tr>
    <tr><td class="paramname">c</td><td>channel </td></tr>
    <tr><td class="paramname">clearVal</td><td>value for the cleared pixels </td></tr>
    <tr><td class="paramname">offs</td><td>lower left point for the to-be-cleared region </td></tr>
    <tr><td class="paramname">size</td><td>size of the to-be-cleared region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac255b232de05b40341dc48a2c1b1cbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac255b232de05b40341dc48a2c1b1cbfc">&#9670;&nbsp;</a></span>combineImages() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ImgType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ImgType* icl::core::combineImages </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const ImgType * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine several images using shallow copy. </p>

</div>
</div>
<a id="ga9748a47b96e8122edbaad78f4b42511b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9748a47b96e8122edbaad78f4b42511b">&#9670;&nbsp;</a></span>combineImages() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ImgType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ImgType* icl::core::combineImages </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ImgType * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine several images using shallow copy. Non-const version. </p>

</div>
</div>
<a id="ga74ce00bcf79e53e02b993d7d000932dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ce00bcf79e53e02b993d7d000932dc">&#9670;&nbsp;</a></span>convertChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icl::core::convertChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; S &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; D &gt; *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies/converts the data from one image to another image (IPP-OPTIMIZED) </p>
<p>The deepCopyChannel function is a higher lever wrapper for the icl::copy(..) function. It extracts the data pointers and data dimension from the source- and destination image to call icl::copy(..) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image </td></tr>
    <tr><td class="paramname">srcC</td><td>source images channel </td></tr>
    <tr><td class="paramname">dst</td><td>destination image </td></tr>
    <tr><td class="paramname">dstC</td><td>destination image channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea7e8c4530584e4ca897a65c52a7786f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea7e8c4530584e4ca897a65c52a7786f">&#9670;&nbsp;</a></span>deepCopyChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icl::core::deepCopyChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the channel from one image to another. </p>

</div>
</div>
<a id="ga702018256e7c778be8d75029b4c171a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga702018256e7c778be8d75029b4c171a5">&#9670;&nbsp;</a></span>deepCopyChannelROI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void icl::core::deepCopyChannelROI </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>srcOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>dstOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>dstSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copies the channel roi from one image to another </p>
<p>{{{ check function }}} Essential deep copy function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image </td></tr>
    <tr><td class="paramname">srcC</td><td>source channel </td></tr>
    <tr><td class="paramname">srcOffs</td><td>source images ROI offset </td></tr>
    <tr><td class="paramname">srcSize</td><td>source images ROI size </td></tr>
    <tr><td class="paramname">dst</td><td>destination image </td></tr>
    <tr><td class="paramname">dstC</td><td>destination channel </td></tr>
    <tr><td class="paramname">dstOffs</td><td>destination images ROI offset </td></tr>
    <tr><td class="paramname">dstSize</td><td>destination images ROI size (must be equal to srcSize) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d25708989e461d211172a8d6abd91af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d25708989e461d211172a8d6abd91af">&#9670;&nbsp;</a></span>ensureCompatible() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::ensureCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ensures that the destination image gets same depth, size, channel count, depth, format and ROI as source image </p>
<p>If the given pointer to the destination image is 0, a new image is created as a deep copy of poSrc. Else the image properties are checked and adapted to the new values if neccessary. <b>Note:</b> If the destination images depth differs from the source images depth, it is adapted by deleting the <em>old</em> destination pointer by calling <em>delete *ppoDst</em> and creating a <em>brand new</em> <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a> where T is the destination images depth. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>points the destination ImgBase*. If the images depth has to be converted, then a new <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>* is created, at (*ppoDst). </td></tr>
    <tr><td class="paramname">src</td><td>source image. All params of this image are extracted to define the destination parameters for *ppoDst. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e1c2a9513b3034fc6fca1d34d42d05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e1c2a9513b3034fc6fca1d34d42d05e">&#9670;&nbsp;</a></span>ensureCompatible() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::ensureCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ensures that an image has given depth and parameters </p>

</div>
</div>
<a id="ga1e1aa2160788b3841e3ed0018fcea84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e1aa2160788b3841e3ed0018fcea84b">&#9670;&nbsp;</a></span>ensureCompatible() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::ensureCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em> = <code><a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ensures that an image has given depth, size, format and ROI </p>

</div>
</div>
<a id="ga32756378c80a568e326011a71765852a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32756378c80a568e326011a71765852a">&#9670;&nbsp;</a></span>ensureCompatible() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::ensureCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em> = <code><a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ensures that an image has given depth, size, number of channels and ROI </p>
<p>If the given pointer to the destination image is 0, a new image with appropriate properties is created. Else the image properties are checked and adapted to the new values if neccessary. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>points the destination ImgBase*. If the images depth hasa to be converted, then a new <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>* is created at (*dst). </td></tr>
    <tr><td class="paramname">d</td><td>desired image depth </td></tr>
    <tr><td class="paramname">size</td><td>desired image size </td></tr>
    <tr><td class="paramname">channels</td><td>desired number of channels, if eFormat == formatMatrix for other format, the number of channels is determined by the format </td></tr>
    <tr><td class="paramname">roi</td><td>desired ROI rectangle. If the ROI parameters are not given, the ROI will comprise the whole image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae37ff3722e02895ea9d7226ff7d984e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae37ff3722e02895ea9d7226ff7d984e9">&#9670;&nbsp;</a></span>ensureCompatible() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::ensureCompatible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em> = <code><a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ensures that an image has given parameters </p>
<p>The given format must be compatible to the given channel count. <b>If not:</b> The format is set to "formatMatrix" and an exception is thrown. </p>

</div>
</div>
<a id="gaa34211f4aa82c399e327b88ac97f7acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa34211f4aa82c399e327b88ac97f7acc">&#9670;&nbsp;</a></span>ensureDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::ensureDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>ppoImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td>
          <td class="paramname"><em>eDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ensures that an image has the specified depth </p>
<p>This function will delete the original image pointed by (*ppoImage) and create a new one with identical parameters, if the given depth parameter is not the images depth. If the given image pointer (*ppoImage) is NULL, then an empty image of specified depth es created at *ppoImage. If ppoImage is NULL a new Image is created and returned. call: </p><pre>
void func(ImgBase **ppoDst){
   <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> *poDst = ensureDepth(ppoDst,anyDepth);
}
</pre><p> to ensure that an image is valid. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppoImage</td><td>pointer to the image-pointer </td></tr>
    <tr><td class="paramname">eDepth</td><td>destination depth of the image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new image (this can be used e.g. if ppoImage is NULL) </dd></dl>

</div>
</div>
<a id="ga7343097d928bee1057f6356b38cb3ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7343097d928bee1057f6356b38cb3ec5">&#9670;&nbsp;</a></span>flippedCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::flippedCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a>&#160;</td>
          <td class="paramname"><em>eAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>poSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>ppoDst</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mirror copy of an image from source to destination image (1:1 copy) </p>
<p>This function creates a flipped instance of this image. Even the ROI is flipped internally. Example: </p><pre>
  ......                    ......     r = roi
  ..rrrr  -&gt; flipped x -&gt;   rrrr..
  ..rrrr                    rrrr..
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eAxis</td><td>axis to flip </td></tr>
    <tr><td class="paramname">poSrc</td><td>source image </td></tr>
    <tr><td class="paramname">ppoDst</td><td>image. This image is exploited if possible. It is adjusted to the source image in depth, size,channels,format,and time </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88f84be8075e9ce4bf05c7707996d8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88f84be8075e9ce4bf05c7707996d8bf">&#9670;&nbsp;</a></span>flippedCopyChannelROI()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::flippedCopyChannelROI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a>&#160;</td>
          <td class="paramname"><em>eAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>srcOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>srcSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1Img.html">Img</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Point.html">utils::Point</a> &amp;&#160;</td>
          <td class="paramname"><em>dstOffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>dstSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mirror copy ROI data from one image to the ROI of another image (IPP-OPTIMIZED) </p>
<p>This function is used by flippedCopyROI and Mirror operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eAxis</td><td>mirror axis (axisHorz, axisVert or axisBoth) </td></tr>
    <tr><td class="paramname">src</td><td>source image </td></tr>
    <tr><td class="paramname">srcC</td><td>source image channel </td></tr>
    <tr><td class="paramname">srcOffs</td><td>source images ROI-offset (src-&gt;getROIOffset() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">srcSize</td><td>source images ROI-size (src-&gt;getROISize() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">dst</td><td>destination image </td></tr>
    <tr><td class="paramname">dstC</td><td>destination image channel </td></tr>
    <tr><td class="paramname">dstOffs</td><td>destination images ROI-offset (dst-&gt;getROIOffset() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">dstSize</td><td>destination images ROI-size (dst-&gt;getROISize() is <b>not</b> regarded) </td></tr>
    <tr><td class="paramname">dstSize</td><td>destination images ROI-size (dst-&gt;getROISize() is <b>not</b> regarded) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab9dad01f2988ee2ff540f4ad900a2e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9dad01f2988ee2ff540f4ad900a2e1a">&#9670;&nbsp;</a></span>flippedCopyROI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> void icl::core::flippedCopyROI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga3f4cf5ea5da57318ad28638b79fc3714">axis</a>&#160;</td>
          <td class="paramname"><em>eAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> *&#160;</td>
          <td class="paramname"><em>poSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a> **&#160;</td>
          <td class="paramname"><em>ppoDst</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mirror copy of an images ROI into a destination images ROI </p>
<p>Example: </p><pre>
  ......                    ......    R,r = roi
  ..RRrr  -&gt; flipped x -&gt;   rrRR..
  ..RRrr                    rrRR..
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eAxis</td><td>axis to flip </td></tr>
    <tr><td class="paramname">poSrc</td><td>source image </td></tr>
    <tr><td class="paramname">ppoDst</td><td>destination image (expoited if possible). This images ROI size must be equal to ppoDst's ROI size otherwise an errormessage is shown, and the function returns 0. If ppoDst is null, a new image is created with size of this images ROI size. If ppoDst points to NULL, the new image is created at *ppoDst. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>flippedCopy </dd></dl>

</div>
</div>
<a id="ga9d45bf9adc5c22962102a84d1b509f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d45bf9adc5c22962102a84d1b509f70">&#9670;&nbsp;</a></span>imgNew() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::imgNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em> = <code><a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a new <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> (see the above function for more details) </p>

</div>
</div>
<a id="gacefe02e15f9f47fa6de8b26084bb4b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacefe02e15f9f47fa6de8b26084bb4b55">&#9670;&nbsp;</a></span>imgNew() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::imgNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga7cc417c2bd265954eaa29e4a17977410">format</a>&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em> = <code><a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a new <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> (see the above function for more details) </p>

</div>
</div>
<a id="ga9e36ef7b1ad84ae52d9853be533ea164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e36ef7b1ad84ae52d9853be533ea164">&#9670;&nbsp;</a></span>imgNew() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::imgNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Size.html">utils::Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channels</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1Rect.html">utils::Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>roi</em> = <code><a class="el" href="classicl_1_1utils_1_1Rect.html#a692ed91359801a89a4219e74f158fdd4">utils::Rect::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a new <a class="el" href="classicl_1_1core_1_1Img.html" title="The Img class implements the ImgBase Image interface with type specific functionalities.">Img</a> (see the above function for more details) </p>

</div>
</div>
<a id="ga00a4ca4fd769f2fe4f0466235948a6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00a4ca4fd769f2fe4f0466235948a6cc">&#9670;&nbsp;</a></span>imgNew() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="CompatMacros_8h.html#a228288ee05bc452beda281b8afdc4cb8">ICLCore_API</a> <a class="el" href="classicl_1_1core_1_1ImgBase.html">ImgBase</a>* icl::core::imgNew </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TYPES.html#ga53af74cee38afb59cc3738a1042a1cea">depth</a>&#160;</td>
          <td class="paramname"><em>d</em> = <code><a class="el" href="group__TYPES.html#gga53af74cee38afb59cc3738a1042a1ceaabf13298b91874fafb68eedffe1a5f3de">depth8u</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicl_1_1core_1_1ImgParams.html">ImgParams</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code><a class="el" href="classicl_1_1core_1_1ImgParams.html#a678ccf92d76d27b2acbcd1a5f3c507d3">ImgParams::null</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new image instance of the given depth type and with given parameters </p>
<p>This function provides a common interface to instantiate images of arbitrary depth, selecting the appropriate constructor of the derived class <a class="el" href="classicl_1_1core_1_1Img.html">Img&lt;T&gt;</a>.</p>
<p>Instead of selecting the correct constructor by yourself, you can simply call this common constructor function. To illustrate the advantage, look at the following example: </p><pre>
  class Foo{
     public:
     Foo(...,Depth eDepth,...):
         poImage(eDepth==depth8u ? new Img8u(...) : new Img32f(...)){
     }
     private:
     <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> *poImage;
  };
</pre><p> This will work, but the "?:"-statement makes the code hardly readable. The following code extract will show the advantage of using the imgNew instantiator: </p><pre>
  class Foo{
     public:
     Foo(...,Depth eDepth,...):
         poImage(imgNew(eDepth,...)){
     }
     private:
     <a class="el" href="classicl_1_1core_1_1ImgBase.html" title="ImgBase is the Image-Interface class that provides save access to underlying Img-template.">ImgBase</a> *poImage;
  };
</pre><p> The readability of the code is much better.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>depth of the image that should be created </td></tr>
    <tr><td class="paramname">params</td><td>struct containing all neccessary parameters like: size: size of the new image fmt: format of the new image channels: number of channels (of an formatMatrix-type image) roi: ROI rectangle of the new image </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new ImgBase* with underlying Img&lt;Type&gt;, where Type is depending on the first parameter eDepth </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceicl_1_1qt_html_a88710c0c58ee1df2517ef4b57894d05d"><div class="ttname"><a href="namespaceicl_1_1qt.html#a88710c0c58ee1df2517ef4b57894d05d">icl::qt::ICLApp</a></div><div class="ttdeci">ICLApplication ICLApp</div><div class="ttdoc">this is just a shortcut typedef</div><div class="ttdef"><b>Definition:</b> Application.h:299</div></div>
<div class="ttc" id="aclassicl_1_1qt_1_1ICLApplication_html_a117474bd97aa1702e0884d8d37372752"><div class="ttname"><a href="classicl_1_1qt_1_1ICLApplication.html#a117474bd97aa1702e0884d8d37372752">icl::qt::ICLApplication::exec</a></div><div class="ttdeci">int exec()</div><div class="ttdoc">executes this ICLApplication</div></div>
<div class="ttc" id="aCommon_8h_html"><div class="ttname"><a href="Common_8h.html">Common.h</a></div></div>
<div class="ttc" id="anamespaceicl_1_1utils_html_ac1c1a1e771ecc0681b8f277040cc2c99"><div class="ttname"><a href="namespaceicl_1_1utils.html#ac1c1a1e771ecc0681b8f277040cc2c99">icl::utils::pa</a></div><div class="ttdeci">const ProgArg pa(const std::string &amp;id, unsigned int subargidx=0)</div><div class="ttdoc">returns given program argument</div><div class="ttdef"><b>Definition:</b> ProgArg.h:360</div></div>
<div class="ttc" id="agroup__IMAGE_html_ga05bef8dfe9aaafedf642c6da1d372523"><div class="ttname"><a href="group__IMAGE.html#ga05bef8dfe9aaafedf642c6da1d372523">icl::core::bpp</a></div><div class="ttdeci">ImgBasePtrPtr&lt; T &gt; bpp(Img&lt; T &gt; *image)</div><div class="ttdoc">utility function to cast an Img&lt;T&gt; implicitly into an ImgBase **</div><div class="ttdef"><b>Definition:</b> Img.h:1631</div></div>
<div class="ttc" id="agroup__TYPES_html_gab9ebfd5e35116d194189c8f233607414"><div class="ttname"><a href="group__TYPES.html#gab9ebfd5e35116d194189c8f233607414">icl::core::Img8u</a></div><div class="ttdeci">Img&lt; icl8u &gt; Img8u</div><div class="ttdoc">typedef for 8bit integer images</div><div class="ttdef"><b>Definition:</b> Types.h:98</div></div>
<div class="ttc" id="aclassicl_1_1core_1_1Img_html_a1da0eda1f6dddd31381b65c794a37983"><div class="ttname"><a href="classicl_1_1core_1_1Img.html#a1da0eda1f6dddd31381b65c794a37983">icl::core::Img::clear</a></div><div class="ttdeci">void clear(int iChannel=-1, Type tValue=0, bool bROIOnly=true)</div><div class="ttdoc">Sets the ROI pixels of one or all channels to a specified value.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 15:28:20 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
