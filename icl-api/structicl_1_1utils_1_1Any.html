<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::utils::Any Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="structicl_1_1utils_1_1Any.html">Any</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structicl_1_1utils_1_1Any-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icl::utils::Any Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Simple generic data type implementation that uses a string based data representation.  
 <a href="structicl_1_1utils_1_1Any.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Any_8h_source.html">Any.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for icl::utils::Any:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structicl_1_1utils_1_1Any.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a47c906fc762d12dc9c247446b70c38f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html#a47c906fc762d12dc9c247446b70c38f7">Any</a> ()</td></tr>
<tr class="memdesc:a47c906fc762d12dc9c247446b70c38f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty constructor.  <a href="structicl_1_1utils_1_1Any.html#a47c906fc762d12dc9c247446b70c38f7">More...</a><br /></td></tr>
<tr class="separator:a47c906fc762d12dc9c247446b70c38f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398de610cec53a0d6f38e292e1135646"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a398de610cec53a0d6f38e292e1135646"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html#a398de610cec53a0d6f38e292e1135646">Any</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a398de610cec53a0d6f38e292e1135646"><td class="mdescLeft">&#160;</td><td class="mdescRight">real constructor with any given source type  <a href="structicl_1_1utils_1_1Any.html#a398de610cec53a0d6f38e292e1135646">More...</a><br /></td></tr>
<tr class="separator:a398de610cec53a0d6f38e292e1135646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd39d4a1e9d67d56ee784c06645ac75"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7cd39d4a1e9d67d56ee784c06645ac75"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html#a7cd39d4a1e9d67d56ee784c06645ac75">operator T</a> () const</td></tr>
<tr class="memdesc:a7cd39d4a1e9d67d56ee784c06645ac75"><td class="mdescLeft">&#160;</td><td class="mdescRight">implicit cast operator that allows for casts into any type  <a href="structicl_1_1utils_1_1Any.html#a7cd39d4a1e9d67d56ee784c06645ac75">More...</a><br /></td></tr>
<tr class="separator:a7cd39d4a1e9d67d56ee784c06645ac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b4e2095b08ec90ff61de2505143f82"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae2b4e2095b08ec90ff61de2505143f82"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html#ae2b4e2095b08ec90ff61de2505143f82">as</a> () const</td></tr>
<tr class="memdesc:ae2b4e2095b08ec90ff61de2505143f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">explict cast method (if implicit cast is ambiguous)  <a href="structicl_1_1utils_1_1Any.html#ae2b4e2095b08ec90ff61de2505143f82">More...</a><br /></td></tr>
<tr class="separator:ae2b4e2095b08ec90ff61de2505143f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6f631cb6ee52ebf3b817ed40be751aa0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6f631cb6ee52ebf3b817ed40be751aa0"><td class="memTemplItemLeft" align="right" valign="top">static T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html#a6f631cb6ee52ebf3b817ed40be751aa0">ptr</a> (const <a class="el" href="structicl_1_1utils_1_1Any.html">Any</a> &amp;any)</td></tr>
<tr class="memdesc:a6f631cb6ee52ebf3b817ed40be751aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">this method can be used to extract a pointer that was encoded as <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a>  <a href="structicl_1_1utils_1_1Any.html#a6f631cb6ee52ebf3b817ed40be751aa0">More...</a><br /></td></tr>
<tr class="separator:a6f631cb6ee52ebf3b817ed40be751aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb4a1668839ac11f59c023164c86f6e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9fb4a1668839ac11f59c023164c86f6e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structicl_1_1utils_1_1Any.html">Any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html#a9fb4a1668839ac11f59c023164c86f6e">ptr</a> (const T *p)</td></tr>
<tr class="memdesc:a9fb4a1668839ac11f59c023164c86f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">this method can be used to create an any that contains a binary encoded pointer  <a href="structicl_1_1utils_1_1Any.html#a9fb4a1668839ac11f59c023164c86f6e">More...</a><br /></td></tr>
<tr class="separator:a9fb4a1668839ac11f59c023164c86f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0429724da36243ee39e8b22304d38f9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html#a0429724da36243ee39e8b22304d38f9e">Any</a> (size_t n, char c)</td></tr>
<tr class="memdesc:a0429724da36243ee39e8b22304d38f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">for direct creation of the parent string (used in the static ptr methods)  <a href="structicl_1_1utils_1_1Any.html#a0429724da36243ee39e8b22304d38f9e">More...</a><br /></td></tr>
<tr class="separator:a0429724da36243ee39e8b22304d38f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4af07a8d9f3e3c4eabc561dfa48d01dd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html#a4af07a8d9f3e3c4eabc561dfa48d01dd">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="structicl_1_1utils_1_1Any.html">Any</a> &amp;any)</td></tr>
<tr class="memdesc:a4af07a8d9f3e3c4eabc561dfa48d01dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">remembers the ostream-operator&lt;&lt; that <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> is of type std::string  <a href="structicl_1_1utils_1_1Any.html#a4af07a8d9f3e3c4eabc561dfa48d01dd">More...</a><br /></td></tr>
<tr class="separator:a4af07a8d9f3e3c4eabc561dfa48d01dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f2ca5252534d30871c720c4a0e8b25"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1utils_1_1Any.html#a43f2ca5252534d30871c720c4a0e8b25">operator&gt;&gt;</a> (std::istream &amp;s, <a class="el" href="structicl_1_1utils_1_1Any.html">Any</a> &amp;any)</td></tr>
<tr class="memdesc:a43f2ca5252534d30871c720c4a0e8b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">remembers the istream-operator&lt;&lt; that <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> is of type std::string  <a href="structicl_1_1utils_1_1Any.html#a43f2ca5252534d30871c720c4a0e8b25">More...</a><br /></td></tr>
<tr class="separator:a43f2ca5252534d30871c720c4a0e8b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simple generic data type implementation that uses a string based data representation. </p>
<p>Instances of class <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> can simply be created from any data type that implements the ostream-operator&lt;&lt; and it can be converted implicitly to any data type that implements the istream-operator&gt;&gt;. For cases, where C++ cannot infer the correct type an explicit conversion template-method <a class="el" href="structicl_1_1utils_1_1Any.html#ae2b4e2095b08ec90ff61de2505143f82" title="explict cast method (if implicit cast is ambiguous)">as&lt;T&gt;()</a> is also provided. <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> does not allow for type checks.</p>
<h1><a class="anchor" id="STR"></a>
std::string representation</h1>
<p>Internally, an instance of type <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> contains not more than the string representation of the serialized type. Since <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> inherits the std::string class, the string-serialized version is also available.</p>
<h1><a class="anchor" id="PTR"></a>
Representing Pointers</h1>
<p>The <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> class can also be used to represent pointers. though the default machanism (i.e. operators &gt;&gt; and &lt;&lt;) could be overloaded to work with ascii-encoded pointers as well. The <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> class provides a more efficient implementation for this. The static template functions <a class="el" href="structicl_1_1utils_1_1Any.html#a6f631cb6ee52ebf3b817ed40be751aa0" title="this method can be used to extract a pointer that was encoded as Any">Any::ptr</a> can be used to create a binary encoded pointer representation.<br  />
If you want to use any instance of <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> to pass a pointer, it is strongly recommended to use the binary representation instead of using ascii encoded pointers. The only drawback for the binary encoded pointers is that they cannot be used as std::string anymore.</p>
<h2><a class="anchor" id="VEC"></a>
encoding vectors</h2>
<p>An a very few cases, one might want to encode vector data as an <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> instance This would, however entail having to concatenate the whole vector data int a string first, and later having to perform an expensive string parsing. To avoid this, the <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> classe's "Constructor(T)" and "as&lt;T&gt;" are specialized for the basic vector types "std::vector&lt;float&gt;" and "std::vector&lt;int&gt;". These are simply encoded in a binary manner, leading to an incredible performance boost of about factor 1000.</p>
<h2><a class="anchor" id="BENCH"></a>
Benchmarks:</h2>
<p>Times were taken on an Intel 1.6GHz Core2Duo (ULV) laptop on 32Bit ubuntu. The times are given per million calls, and we did not use gcc optimizations because most operations were optimized out in this case. However the speed advatange seemed to less then about 30%.</p>
<p>ASCII Encoded Pointers<br  />
 <code>int <em>p = new int[5]; <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> a(int)p; int *p2 = (int</em>)a.as&lt;int&gt;(); </code><br  />
 <b><a class="el" href="classicl_1_1utils_1_1Time.html" title="ICL Time class (taken from the Ice lib)">Time</a>: ~ 1/250 ms</b><br  />
 Binary Encoded Pointers<br  />
 <code>int *p = new int[5]; <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> a = Any::ptr(p); int *p2 = Any::ptr&lt;int&gt;(a); </code><br  />
 <b><a class="el" href="classicl_1_1utils_1_1Time.html" title="ICL Time class (taken from the Ice lib)">Time</a>: ~ 1/3000 ms</b><br  />
 Here, we also benchmarked the steps separatly and we found out, that the creation of the any instance took more than 99.9% of the time. Therefore, we can conclude that parsing a binary endocded <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> instance is close the using a raw-pointer instead:</p>
<p>C++ Pointers: <br  />
 <b><a class="el" href="classicl_1_1utils_1_1Time.html" title="ICL Time class (taken from the Ice lib)">Time</a>: ~ 1/10000 ms</b><br  />
 Performance measurement for vector types (Core2Duo 2.4GHz, Ubuntu 12.04 32bit), std::vector&lt;float&gt; V, with 1000 entries.</p>
<p>x = <a class="el" href="namespaceicl_1_1utils.html#acc1429a32f96ec90c4569b243d7a2020" title="concatinates at string-vector to a single string">icl::utils::cat</a>(V,","); icl::parseVecStr&lt;float&gt;(x); : 2.5ms <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> a = v; std::vector&lt;float&gt; b = a; : 2.3 *10^3ms </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a47c906fc762d12dc9c247446b70c38f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c906fc762d12dc9c247446b70c38f7">&#9670;&nbsp;</a></span>Any() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">icl::utils::Any::Any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty constructor. </p>

</div>
</div>
<a id="a398de610cec53a0d6f38e292e1135646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398de610cec53a0d6f38e292e1135646">&#9670;&nbsp;</a></span>Any() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">icl::utils::Any::Any </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>real constructor with any given source type </p>
<p>This constructor can only be used for types that implement the ostream-operator&lt;&lt;. If this is not true, you can either overload the ostream-operator&gt;&gt; for instances of type T, or you can pass an already serialized (as std::string) version of T. </p>

</div>
</div>
<a id="a0429724da36243ee39e8b22304d38f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0429724da36243ee39e8b22304d38f9e">&#9670;&nbsp;</a></span>Any() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">icl::utils::Any::Any </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for direct creation of the parent string (used in the static ptr methods) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae2b4e2095b08ec90ff61de2505143f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b4e2095b08ec90ff61de2505143f82">&#9670;&nbsp;</a></span>as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T icl::utils::Any::as </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explict cast method (if implicit cast is ambiguous) </p>
<p>In many situations, C++ can not automatically infer the correct destination type if the implicit cast operator is implemented as a template method. E.g.: </p><div class="fragment"><div class="line"><a class="code" href="structicl_1_1utils_1_1Any.html#a47c906fc762d12dc9c247446b70c38f7">Any</a> myInt(7);</div>
<div class="line"><span class="keywordtype">int</span> i = myInt; <span class="comment">// Works -&gt; implicit cast to int</span></div>
<div class="line"><span class="keywordtype">int</span> j;</div>
<div class="line">j = myInt; <span class="comment">// Error: cast is ambiguous</span></div>
<div class="line"><span class="comment">// instead:</span></div>
<div class="line">j = myInt.as&lt;<span class="keywordtype">int</span>&gt;(); <span class="comment">// Works -&gt; explicit cast to int</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7cd39d4a1e9d67d56ee784c06645ac75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd39d4a1e9d67d56ee784c06645ac75">&#9670;&nbsp;</a></span>operator T()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">icl::utils::Any::operator T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implicit cast operator that allows for casts into any type </p>
<p>This operator does only work if the istream-operator&gt;&gt; is overloded for instances of type T. If this operator does not exist, you can either implement it, or parse this instance of type <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a>, which is also an instance of type std::string manually. </p>

</div>
</div>
<a id="a6f631cb6ee52ebf3b817ed40be751aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f631cb6ee52ebf3b817ed40be751aa0">&#9670;&nbsp;</a></span>ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T* icl::utils::Any::ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"><em>any</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this method can be used to extract a pointer that was encoded as <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structicl_1_1utils_1_1Any.html#PTR">Representing Pointers</a> </dd></dl>

</div>
</div>
<a id="a9fb4a1668839ac11f59c023164c86f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb4a1668839ac11f59c023164c86f6e">&#9670;&nbsp;</a></span>ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structicl_1_1utils_1_1Any.html">Any</a> icl::utils::Any::ptr </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this method can be used to create an any that contains a binary encoded pointer </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structicl_1_1utils_1_1Any.html#PTR">Representing Pointers</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4af07a8d9f3e3c4eabc561dfa48d01dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af07a8d9f3e3c4eabc561dfa48d01dd">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1utils_1_1Any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"><em>any</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remembers the ostream-operator&lt;&lt; that <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> is of type std::string </p>

</div>
</div>
<a id="a43f2ca5252534d30871c720c4a0e8b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f2ca5252534d30871c720c4a0e8b25">&#9670;&nbsp;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1utils_1_1Any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"><em>any</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remembers the istream-operator&lt;&lt; that <a class="el" href="structicl_1_1utils_1_1Any.html" title="Simple generic data type implementation that uses a string based data representation.">Any</a> is of type std::string </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/runner/work/icl/icl/ICLUtils/src/ICLUtils/<a class="el" href="Any_8h_source.html">Any.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="astructicl_1_1utils_1_1Any_html_a47c906fc762d12dc9c247446b70c38f7"><div class="ttname"><a href="structicl_1_1utils_1_1Any.html#a47c906fc762d12dc9c247446b70c38f7">icl::utils::Any::Any</a></div><div class="ttdeci">Any()</div><div class="ttdoc">Empty constructor.</div><div class="ttdef"><b>Definition:</b> Any.h:195</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 14:54:54 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
