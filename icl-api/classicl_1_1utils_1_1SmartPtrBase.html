<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::utils::SmartPtrBase&lt; T, delOp &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1utils.html">utils</a></li><li class="navelem"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classicl_1_1utils_1_1SmartPtrBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icl::utils::SmartPtrBase&lt; T, delOp &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for reference counting smart-pointers.  
 <a href="classicl_1_1utils_1_1SmartPtrBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="SmartPtrBase_8h_source.html">SmartPtrBase.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4f7bfd4804450fe0bbcd89cf0dd8042b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a4f7bfd4804450fe0bbcd89cf0dd8042b">SmartPtrBase</a> ()</td></tr>
<tr class="memdesc:a4f7bfd4804450fe0bbcd89cf0dd8042b"><td class="mdescLeft">&#160;</td><td class="mdescRight">e and c will become NULL  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a4f7bfd4804450fe0bbcd89cf0dd8042b">More...</a><br /></td></tr>
<tr class="separator:a4f7bfd4804450fe0bbcd89cf0dd8042b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7a4c563aef78d22a2fc9f1164c243f"><td class="memTemplParams" colspan="2">template&lt;class DerivedT &gt; </td></tr>
<tr class="memitem:afe7a4c563aef78d22a2fc9f1164c243f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#afe7a4c563aef78d22a2fc9f1164c243f">SmartPtrBase</a> (DerivedT *ptData, bool bOwn=true)</td></tr>
<tr class="memdesc:afe7a4c563aef78d22a2fc9f1164c243f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ptData is given, reference counter is set to 1  <a href="classicl_1_1utils_1_1SmartPtrBase.html#afe7a4c563aef78d22a2fc9f1164c243f">More...</a><br /></td></tr>
<tr class="separator:afe7a4c563aef78d22a2fc9f1164c243f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e56071f2149420c0e370da8f73735d"><td class="memTemplParams" colspan="2">template&lt;class DerivedT &gt; </td></tr>
<tr class="memitem:ae2e56071f2149420c0e370da8f73735d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#ae2e56071f2149420c0e370da8f73735d">SmartPtrBase</a> (const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; DerivedT, delOp &gt; &amp;r)</td></tr>
<tr class="memdesc:ae2e56071f2149420c0e370da8f73735d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of given smart pointer with more general type.  <a href="classicl_1_1utils_1_1SmartPtrBase.html#ae2e56071f2149420c0e370da8f73735d">More...</a><br /></td></tr>
<tr class="separator:ae2e56071f2149420c0e370da8f73735d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eedc6a5f1447e5749afc38b16a1a2a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a5eedc6a5f1447e5749afc38b16a1a2a4">SmartPtrBase</a> (const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; T, delOp &gt; &amp;r)</td></tr>
<tr class="memdesc:a5eedc6a5f1447e5749afc38b16a1a2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a copy of given smart pointer.  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a5eedc6a5f1447e5749afc38b16a1a2a4">More...</a><br /></td></tr>
<tr class="separator:a5eedc6a5f1447e5749afc38b16a1a2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb096aac536f0776e69ebf77dc2b51f"><td class="memTemplParams" colspan="2">template&lt;class DerivedT &gt; </td></tr>
<tr class="memitem:afcb096aac536f0776e69ebf77dc2b51f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; T, delOp &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#afcb096aac536f0776e69ebf77dc2b51f">operator=</a> (const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; DerivedT, delOp &gt; &amp;r)</td></tr>
<tr class="memdesc:afcb096aac536f0776e69ebf77dc2b51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the pointer to hold another reference  <a href="classicl_1_1utils_1_1SmartPtrBase.html#afcb096aac536f0776e69ebf77dc2b51f">More...</a><br /></td></tr>
<tr class="separator:afcb096aac536f0776e69ebf77dc2b51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92b094520a6eae1c313e89fd06a5234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; T, delOp &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#ae92b094520a6eae1c313e89fd06a5234">operator=</a> (const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; T, delOp &gt; &amp;r)</td></tr>
<tr class="memdesc:ae92b094520a6eae1c313e89fd06a5234"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicit implmentation of the same type assignment operator  <a href="classicl_1_1utils_1_1SmartPtrBase.html#ae92b094520a6eae1c313e89fd06a5234">More...</a><br /></td></tr>
<tr class="separator:ae92b094520a6eae1c313e89fd06a5234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aee8ea3e4cdeb56a7493af30994213d"><td class="memTemplParams" colspan="2">template&lt;class DerivedT &gt; </td></tr>
<tr class="memitem:a4aee8ea3e4cdeb56a7493af30994213d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; T, delOp &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a4aee8ea3e4cdeb56a7493af30994213d">operator=</a> (DerivedT *p)</td></tr>
<tr class="memdesc:a4aee8ea3e4cdeb56a7493af30994213d"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows for direct assignment of pointers to a <a class="el" href="structicl_1_1utils_1_1SmartPtr.html" title="Specialization of the SmartPtrBase class for Pointers.">SmartPtr</a> object  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a4aee8ea3e4cdeb56a7493af30994213d">More...</a><br /></td></tr>
<tr class="separator:a4aee8ea3e4cdeb56a7493af30994213d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa6ca86166c8f54dab473d79e51be4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; T, delOp &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a1aa6ca86166c8f54dab473d79e51be4d">operator=</a> (T *p)</td></tr>
<tr class="memdesc:a1aa6ca86166c8f54dab473d79e51be4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">allows for direct assignment of pointers to a <a class="el" href="structicl_1_1utils_1_1SmartPtr.html" title="Specialization of the SmartPtrBase class for Pointers.">SmartPtr</a> object  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a1aa6ca86166c8f54dab473d79e51be4d">More...</a><br /></td></tr>
<tr class="separator:a1aa6ca86166c8f54dab473d79e51be4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ecf006d2147ef9a09fb05f5375d37a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a00ecf006d2147ef9a09fb05f5375d37a">~SmartPtrBase</a> ()</td></tr>
<tr class="memdesc:a00ecf006d2147ef9a09fb05f5375d37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">decreases the reference counter (cleanup on demand)  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a00ecf006d2147ef9a09fb05f5375d37a">More...</a><br /></td></tr>
<tr class="separator:a00ecf006d2147ef9a09fb05f5375d37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23703904b7b7ce8da402d71ebf82b8b3"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a23703904b7b7ce8da402d71ebf82b8b3">operator*</a> ()</td></tr>
<tr class="memdesc:a23703904b7b7ce8da402d71ebf82b8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a reference of the currently hold element  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a23703904b7b7ce8da402d71ebf82b8b3">More...</a><br /></td></tr>
<tr class="separator:a23703904b7b7ce8da402d71ebf82b8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cfdf653e30d5539bde1079573a9384"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a82cfdf653e30d5539bde1079573a9384">operator*</a> () const</td></tr>
<tr class="memdesc:a82cfdf653e30d5539bde1079573a9384"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a reference of the currently hold element (const)  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a82cfdf653e30d5539bde1079573a9384">More...</a><br /></td></tr>
<tr class="separator:a82cfdf653e30d5539bde1079573a9384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b943945b6ee2f7f7de6dfacc8f9bba"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a31b943945b6ee2f7f7de6dfacc8f9bba">get</a> ()</td></tr>
<tr class="memdesc:a31b943945b6ee2f7f7de6dfacc8f9bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pointer to the data  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a31b943945b6ee2f7f7de6dfacc8f9bba">More...</a><br /></td></tr>
<tr class="separator:a31b943945b6ee2f7f7de6dfacc8f9bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad551da367736891410ad79b1b794aa91"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#ad551da367736891410ad79b1b794aa91">get</a> () const</td></tr>
<tr class="memdesc:ad551da367736891410ad79b1b794aa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pointer to the data (const)  <a href="classicl_1_1utils_1_1SmartPtrBase.html#ad551da367736891410ad79b1b794aa91">More...</a><br /></td></tr>
<tr class="separator:ad551da367736891410ad79b1b794aa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629b81576cf48d56653dca1b43b96607"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a629b81576cf48d56653dca1b43b96607">operator-&gt;</a> ()</td></tr>
<tr class="memdesc:a629b81576cf48d56653dca1b43b96607"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the currently hold element  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a629b81576cf48d56653dca1b43b96607">More...</a><br /></td></tr>
<tr class="separator:a629b81576cf48d56653dca1b43b96607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecca34afee355a164c86d192cb0b898"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a7ecca34afee355a164c86d192cb0b898">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a7ecca34afee355a164c86d192cb0b898"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the currently hold element (const)  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a7ecca34afee355a164c86d192cb0b898">More...</a><br /></td></tr>
<tr class="separator:a7ecca34afee355a164c86d192cb0b898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1327299b38087adc39deaaa63adcfbe4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a1327299b38087adc39deaaa63adcfbe4">operator bool</a> () const</td></tr>
<tr class="memdesc:a1327299b38087adc39deaaa63adcfbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">this may be used to check if * or -&gt; operator may be used  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a1327299b38087adc39deaaa63adcfbe4">More...</a><br /></td></tr>
<tr class="separator:a1327299b38087adc39deaaa63adcfbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed98c42879a4c0f7f80315af1b9b6cfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#aed98c42879a4c0f7f80315af1b9b6cfa">use_count</a> () const</td></tr>
<tr class="memdesc:aed98c42879a4c0f7f80315af1b9b6cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">current reference count  <a href="classicl_1_1utils_1_1SmartPtrBase.html#aed98c42879a4c0f7f80315af1b9b6cfa">More...</a><br /></td></tr>
<tr class="separator:aed98c42879a4c0f7f80315af1b9b6cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff6d0eac8d31894b8ed58f527a72ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a7ff6d0eac8d31894b8ed58f527a72ec1">setNull</a> ()</td></tr>
<tr class="memdesc:a7ff6d0eac8d31894b8ed58f527a72ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the smart pointer to null  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a7ff6d0eac8d31894b8ed58f527a72ec1">More...</a><br /></td></tr>
<tr class="separator:a7ff6d0eac8d31894b8ed58f527a72ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa4ab444e1d3594fa0e2e3e544a4dc329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#aa4ab444e1d3594fa0e2e3e544a4dc329">inc</a> ()</td></tr>
<tr class="memdesc:aa4ab444e1d3594fa0e2e3e544a4dc329"><td class="mdescLeft">&#160;</td><td class="mdescRight">save reference counter increment  <a href="classicl_1_1utils_1_1SmartPtrBase.html#aa4ab444e1d3594fa0e2e3e544a4dc329">More...</a><br /></td></tr>
<tr class="separator:aa4ab444e1d3594fa0e2e3e544a4dc329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6165cedd3576e3197d79288278e593fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a6165cedd3576e3197d79288278e593fa">dec</a> ()</td></tr>
<tr class="memdesc:a6165cedd3576e3197d79288278e593fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">save reference counter decrement (cleanup on demand)  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a6165cedd3576e3197d79288278e593fa">More...</a><br /></td></tr>
<tr class="separator:a6165cedd3576e3197d79288278e593fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5db044a36cbb20c7a344dd566ea030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a2a5db044a36cbb20c7a344dd566ea030">set</a> (T *<a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a4d9bc4b8c61512b0f16f21636c1f690e">e</a>, int *<a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a4192d4fc69b6fc732296b36751fc2898">c</a>, bool <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#af749744c70d36baaf383847342706fa6">d</a>)</td></tr>
<tr class="memdesc:a2a5db044a36cbb20c7a344dd566ea030"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets e and c  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a2a5db044a36cbb20c7a344dd566ea030">More...</a><br /></td></tr>
<tr class="separator:a2a5db044a36cbb20c7a344dd566ea030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf22524f12887c42f77a2667e4de1641"><td class="memTemplParams" colspan="2">template&lt;class DerivedT &gt; </td></tr>
<tr class="memitem:acf22524f12887c42f77a2667e4de1641"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; T, delOp &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#acf22524f12887c42f77a2667e4de1641">assign</a> (const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; DerivedT, delOp &gt; &amp;r)</td></tr>
<tr class="memdesc:acf22524f12887c42f77a2667e4de1641"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility assignment method used in the <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a> assignment operators  <a href="classicl_1_1utils_1_1SmartPtrBase.html#acf22524f12887c42f77a2667e4de1641">More...</a><br /></td></tr>
<tr class="separator:acf22524f12887c42f77a2667e4de1641"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4d9bc4b8c61512b0f16f21636c1f690e"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a4d9bc4b8c61512b0f16f21636c1f690e">e</a></td></tr>
<tr class="separator:a4d9bc4b8c61512b0f16f21636c1f690e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4192d4fc69b6fc732296b36751fc2898"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a4192d4fc69b6fc732296b36751fc2898">c</a></td></tr>
<tr class="separator:a4192d4fc69b6fc732296b36751fc2898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af749744c70d36baaf383847342706fa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#af749744c70d36baaf383847342706fa6">d</a></td></tr>
<tr class="separator:af749744c70d36baaf383847342706fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a491d7160ad8d4af66416d834762c662f"><td class="memTemplParams" colspan="2">template&lt;class A , class B &gt; </td></tr>
<tr class="memitem:a491d7160ad8d4af66416d834762c662f"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html#a491d7160ad8d4af66416d834762c662f">SmartPtrBase</a></td></tr>
<tr class="memdesc:a491d7160ad8d4af66416d834762c662f"><td class="mdescLeft">&#160;</td><td class="mdescRight">for template-based assignment  <a href="classicl_1_1utils_1_1SmartPtrBase.html#a491d7160ad8d4af66416d834762c662f">More...</a><br /></td></tr>
<tr class="separator:a491d7160ad8d4af66416d834762c662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class delOp = ArrayDelOp&gt;<br />
class icl::utils::SmartPtrBase&lt; T, delOp &gt;</h3>

<p>Base class for reference counting smart-pointers. </p>
<h1><a class="anchor" id="Gen"></a>
General Information</h1>
<p>The icl::SmartPtrBase class defines an abstract interface for managed pointers that use reference counting for save memory management It is not recommended to use the <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a> class itself. Most of the time, either The icl::SmartPtr or the icl::SmartArray</p>
<p><b>Important:</b> The data of a <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a> is released using the second template class parameter delOp::delete_func. Predefined delOps are:</p><ul>
<li><a class="el" href="structicl_1_1utils_1_1PointerDelOp.html" title="Pointer delete operation class for the SmartPtr class.">PointerDelOp</a> (using delete [])</li>
<li><a class="el" href="structicl_1_1utils_1_1ArrayDelOp.html" title="Array delete operation class for the SmartPtr class.">ArrayDelOp</a> (using delete []) [ default ]</li>
<li><a class="el" href="structicl_1_1utils_1_1FreeDelOp.html" title="C-Style delete operation class for the SmartPtr class.">FreeDelOp</a> (using free) Take care, that shared data, which is given to a specific <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a>, is allocated using the correct allocation method (new, new[] or malloc). <b>Use the derived classes <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a> and <a class="el" href="structicl_1_1utils_1_1SmartArray.html" title="Specialization of the SmartPtrBase class for Arrays.">SmartArray</a> in order to avoid misunderstandings </b></li>
</ul>
<h2>How a <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a> works</h2>
<p>In contrast with the auto pointers provided by the stdlib an <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a> has an internal reference counter, which is used to care about the deletion of the managed data segment. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4f7bfd4804450fe0bbcd89cf0dd8042b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7bfd4804450fe0bbcd89cf0dd8042b">&#9670;&nbsp;</a></span>SmartPtrBase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::<a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>e and c will become NULL </p>

</div>
</div>
<a id="afe7a4c563aef78d22a2fc9f1164c243f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7a4c563aef78d22a2fc9f1164c243f">&#9670;&nbsp;</a></span>SmartPtrBase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<div class="memtemplate">
template&lt;class DerivedT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::<a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a> </td>
          <td>(</td>
          <td class="paramtype">DerivedT *&#160;</td>
          <td class="paramname"><em>ptData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOwn</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ptData is given, reference counter is set to 1 </p>

</div>
</div>
<a id="ae2e56071f2149420c0e370da8f73735d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e56071f2149420c0e370da8f73735d">&#9670;&nbsp;</a></span>SmartPtrBase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<div class="memtemplate">
template&lt;class DerivedT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::<a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; DerivedT, delOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of given smart pointer with more general type. </p>
<p>This does of course only work, if DeriveT is T or if it extends T </p>

</div>
</div>
<a id="a5eedc6a5f1447e5749afc38b16a1a2a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eedc6a5f1447e5749afc38b16a1a2a4">&#9670;&nbsp;</a></span>SmartPtrBase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::<a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; T, delOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a copy of given smart pointer. </p>
<p>This does of course only work, if DeriveT is T or if it extends T </p>

</div>
</div>
<a id="a00ecf006d2147ef9a09fb05f5375d37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ecf006d2147ef9a09fb05f5375d37a">&#9670;&nbsp;</a></span>~SmartPtrBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::~<a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decreases the reference counter (cleanup on demand) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf22524f12887c42f77a2667e4de1641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf22524f12887c42f77a2667e4de1641">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<div class="memtemplate">
template&lt;class DerivedT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt;T,delOp&gt;&amp; <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; DerivedT, delOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility assignment method used in the <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html" title="Base class for reference counting smart-pointers.">SmartPtrBase</a> assignment operators </p>

</div>
</div>
<a id="a6165cedd3576e3197d79288278e593fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6165cedd3576e3197d79288278e593fa">&#9670;&nbsp;</a></span>dec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::dec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>save reference counter decrement (cleanup on demand) </p>

</div>
</div>
<a id="a31b943945b6ee2f7f7de6dfacc8f9bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b943945b6ee2f7f7de6dfacc8f9bba">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the pointer to the data </p>
<p>If the element pointer is null, an error will terminate the program with -1; </p>

</div>
</div>
<a id="ad551da367736891410ad79b1b794aa91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad551da367736891410ad79b1b794aa91">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the pointer to the data (const) </p>
<p>If the element pointer is null, an error will terminate the program with -1; </p>

</div>
</div>
<a id="aa4ab444e1d3594fa0e2e3e544a4dc329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ab444e1d3594fa0e2e3e544a4dc329">&#9670;&nbsp;</a></span>inc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::inc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>save reference counter increment </p>

</div>
</div>
<a id="a1327299b38087adc39deaaa63adcfbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1327299b38087adc39deaaa63adcfbe4">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this may be used to check if * or -&gt; operator may be used </p>

</div>
</div>
<a id="a23703904b7b7ce8da402d71ebf82b8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23703904b7b7ce8da402d71ebf82b8b3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a reference of the currently hold element </p>
<p>If the element pointer is null, an error will terminate the program with -1; </p>

</div>
</div>
<a id="a82cfdf653e30d5539bde1079573a9384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cfdf653e30d5539bde1079573a9384">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a reference of the currently hold element (const) </p>
<p>If the element pointer is null, an error will terminate the program with -1; </p>

</div>
</div>
<a id="a629b81576cf48d56653dca1b43b96607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629b81576cf48d56653dca1b43b96607">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the currently hold element </p>
<p>If the element pointer is null, an error will terminate the program with -1; </p>

</div>
</div>
<a id="a7ecca34afee355a164c86d192cb0b898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecca34afee355a164c86d192cb0b898">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the currently hold element (const) </p>
<p>If the element pointer is null, an error will terminate the program with -1; </p>

</div>
</div>
<a id="afcb096aac536f0776e69ebf77dc2b51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb096aac536f0776e69ebf77dc2b51f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<div class="memtemplate">
template&lt;class DerivedT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt;T,delOp&gt;&amp; <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; DerivedT, delOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the pointer to hold another reference </p>
<p>If the new reference r.e is identical to the current reference, nothing is done at all. Else, the current reference counter is decreased by 1, if it becomes NULL, the hold reference is deleted. Following, the current reference and reference counter is copied from the given r. At the end, the copied reference counter is increased by 1. </p>

</div>
</div>
<a id="ae92b094520a6eae1c313e89fd06a5234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92b094520a6eae1c313e89fd06a5234">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt;T,delOp&gt;&amp; <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt; T, delOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicit implmentation of the same type assignment operator </p>
<p>This operator needs to be implemented explicitly because the template based assignment operator does not match the default assignment operator type for some reason. </p>

</div>
</div>
<a id="a4aee8ea3e4cdeb56a7493af30994213d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aee8ea3e4cdeb56a7493af30994213d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<div class="memtemplate">
template&lt;class DerivedT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt;T,delOp&gt;&amp; <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">DerivedT *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allows for direct assignment of pointers to a <a class="el" href="structicl_1_1utils_1_1SmartPtr.html" title="Specialization of the SmartPtrBase class for Pointers.">SmartPtr</a> object </p>
<p>Rvalue pointer must be of type T of a type is derived from T </p>

</div>
</div>
<a id="a1aa6ca86166c8f54dab473d79e51be4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa6ca86166c8f54dab473d79e51be4d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a>&lt;T,delOp&gt;&amp; <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allows for direct assignment of pointers to a <a class="el" href="structicl_1_1utils_1_1SmartPtr.html" title="Specialization of the SmartPtrBase class for Pointers.">SmartPtr</a> object </p>

</div>
</div>
<a id="a2a5db044a36cbb20c7a344dd566ea030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5db044a36cbb20c7a344dd566ea030">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::set </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets e and c </p>

</div>
</div>
<a id="a7ff6d0eac8d31894b8ed58f527a72ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff6d0eac8d31894b8ed58f527a72ec1">&#9670;&nbsp;</a></span>setNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::setNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets the smart pointer to null </p>
<p>This is equivalent to </p><div class="fragment"><div class="line">SmartPtr&lt;X&gt; p(<span class="keyword">new</span> X);</div>
<div class="line">p = SmartPtr&lt;X&gt;();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aed98c42879a4c0f7f80315af1b9b6cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed98c42879a4c0f7f80315af1b9b6cfa">&#9670;&nbsp;</a></span>use_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>current reference count </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a491d7160ad8d4af66416d834762c662f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491d7160ad8d4af66416d834762c662f">&#9670;&nbsp;</a></span>SmartPtrBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<div class="memtemplate">
template&lt;class A , class B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">SmartPtrBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for template-based assignment </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4192d4fc69b6fc732296b36751fc2898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4192d4fc69b6fc732296b36751fc2898">&#9670;&nbsp;</a></span>c</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::c</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>reference counters </p>

</div>
</div>
<a id="af749744c70d36baaf383847342706fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af749744c70d36baaf383847342706fa6">&#9670;&nbsp;</a></span>d</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::d</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>deletion flag (indicates if the hold data must be deleted) </p>

</div>
</div>
<a id="a4d9bc4b8c61512b0f16f21636c1f690e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9bc4b8c61512b0f16f21636c1f690e">&#9670;&nbsp;</a></span>e</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class delOp  = ArrayDelOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classicl_1_1utils_1_1SmartPtrBase.html">icl::utils::SmartPtrBase</a>&lt; T, delOp &gt;::e</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>corresponding data element </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/icl/icl/ICLUtils/src/ICLUtils/<a class="el" href="SmartPtrBase_8h_source.html">SmartPtrBase.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 14:54:55 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
