<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::math::DynMatrix&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1math.html">math</a></li><li class="navelem"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="structicl_1_1math_1_1DynMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icl::math::DynMatrix&lt; T &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__LINALG.html">Linear algebra classes and functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Highly flexible and optimized matrix class implementation.  
 <a href="structicl_1_1math_1_1DynMatrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DynMatrix_8h_source.html">DynMatrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for icl::math::DynMatrix&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structicl_1_1math_1_1DynMatrix.png" usemap="#icl::math::DynMatrix_3C_20T_20_3E_map" alt=""/>
  <map id="icl::math::DynMatrix_3C_20T_20_3E_map" name="icl::math::DynMatrix_3C_20T_20_3E_map">
<area href="structicl_1_1math_1_1DynColVector.html" title="Extension class for the DynMatrix&lt;T&gt; template, that restricts the the matrix column count to &#39;one&#39;." alt="icl::math::DynColVector&lt; T &gt;" shape="rect" coords="0,56,179,80"/>
<area href="structicl_1_1math_1_1DynRowVector.html" alt="icl::math::DynRowVector&lt; T &gt;" shape="rect" coords="189,56,368,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix_1_1col__iterator.html">col_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal column iterator struct (using height-stride)  <a href="structicl_1_1math_1_1DynMatrix_1_1col__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html">DynMatrixColumn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used Utility structure referencing a matrix column shallowly.  <a href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac9d42828615aac0caac6c29b45a8045f"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ac9d42828615aac0caac6c29b45a8045f">iterator</a></td></tr>
<tr class="memdesc:ac9d42828615aac0caac6c29b45a8045f"><td class="mdescLeft">&#160;</td><td class="mdescRight">default iterator type (just a data-pointer)  <a href="structicl_1_1math_1_1DynMatrix.html#ac9d42828615aac0caac6c29b45a8045f">More...</a><br /></td></tr>
<tr class="separator:ac9d42828615aac0caac6c29b45a8045f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab270c26102e39f8899f7421bbd15591c"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab270c26102e39f8899f7421bbd15591c">row_iterator</a></td></tr>
<tr class="memdesc:ab270c26102e39f8899f7421bbd15591c"><td class="mdescLeft">&#160;</td><td class="mdescRight">comples row_iterator type  <a href="structicl_1_1math_1_1DynMatrix.html#ab270c26102e39f8899f7421bbd15591c">More...</a><br /></td></tr>
<tr class="separator:ab270c26102e39f8899f7421bbd15591c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bcb2e89a1a64f18cc3d2c21a33ab2e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab7bcb2e89a1a64f18cc3d2c21a33ab2e">GESDD</a>) (const char *, const int *, const int *, T *, const int *, T *, T *, const int *, T *, const int *, T *, const int *, int *, int *)</td></tr>
<tr class="separator:ab7bcb2e89a1a64f18cc3d2c21a33ab2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4e508192704d0b034d1fdfbca176a7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a8c4e508192704d0b034d1fdfbca176a7">CBLAS_GEMM</a>) (CBLAS_ORDER, CBLAS_TRANSPOSE, CBLAS_TRANSPOSE, int, int, int, T, const T *, int, const T *, int, T, T *, int)</td></tr>
<tr class="separator:a8c4e508192704d0b034d1fdfbca176a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afded5b848be8a787873aa4790d5b7b67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#afded5b848be8a787873aa4790d5b7b67">DynMatrix</a> (const <a class="el" href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html">DynMatrixColumn</a> &amp;column)</td></tr>
<tr class="memdesc:afded5b848be8a787873aa4790d5b7b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a column matrix from given column of other matrix  <a href="structicl_1_1math_1_1DynMatrix.html#afded5b848be8a787873aa4790d5b7b67">More...</a><br /></td></tr>
<tr class="separator:afded5b848be8a787873aa4790d5b7b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b0fecc4e198b10c72b68a690dc8574"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab0b0fecc4e198b10c72b68a690dc8574">DynMatrix</a> ()</td></tr>
<tr class="memdesc:ab0b0fecc4e198b10c72b68a690dc8574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default empty constructor creates a null-matrix.  <a href="structicl_1_1math_1_1DynMatrix.html#ab0b0fecc4e198b10c72b68a690dc8574">More...</a><br /></td></tr>
<tr class="separator:ab0b0fecc4e198b10c72b68a690dc8574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b5b9fa1ff19a2061c646b0706df39e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a18b5b9fa1ff19a2061c646b0706df39e">DynMatrix</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a06b8be83f6d36b95723daa0403ab4d55">cols</a>, unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a87aa61cb0482e28f53b874999fb5d722">rows</a>, const T &amp;initValue=0)</td></tr>
<tr class="memdesc:a18b5b9fa1ff19a2061c646b0706df39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dyn matrix with given dimensions (and optional initialValue)  <a href="structicl_1_1math_1_1DynMatrix.html#a18b5b9fa1ff19a2061c646b0706df39e">More...</a><br /></td></tr>
<tr class="separator:a18b5b9fa1ff19a2061c646b0706df39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63285a42de3570e7ca3f028d47c2c3a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a63285a42de3570e7ca3f028d47c2c3a6">DynMatrix</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a06b8be83f6d36b95723daa0403ab4d55">cols</a>, unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a87aa61cb0482e28f53b874999fb5d722">rows</a>, T *<a class="el" href="structicl_1_1math_1_1DynMatrix.html#a730c7185310fb60477d2d5dd5dad2e5f">data</a>, bool deepCopy=true)</td></tr>
<tr class="memdesc:a63285a42de3570e7ca3f028d47c2c3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix with given data.  <a href="structicl_1_1math_1_1DynMatrix.html#a63285a42de3570e7ca3f028d47c2c3a6">More...</a><br /></td></tr>
<tr class="separator:a63285a42de3570e7ca3f028d47c2c3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccba7dc73e50da40435adc139a57ade"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a5ccba7dc73e50da40435adc139a57ade">DynMatrix</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a06b8be83f6d36b95723daa0403ab4d55">cols</a>, unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a87aa61cb0482e28f53b874999fb5d722">rows</a>, const T *<a class="el" href="structicl_1_1math_1_1DynMatrix.html#a730c7185310fb60477d2d5dd5dad2e5f">data</a>)</td></tr>
<tr class="memdesc:a5ccba7dc73e50da40435adc139a57ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix with given data (const version: deepCopy only)  <a href="structicl_1_1math_1_1DynMatrix.html#a5ccba7dc73e50da40435adc139a57ade">More...</a><br /></td></tr>
<tr class="separator:a5ccba7dc73e50da40435adc139a57ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1050678033ac039ab268e04874fc83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a5c1050678033ac039ab268e04874fc83">DynMatrix</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;other)</td></tr>
<tr class="memdesc:a5c1050678033ac039ab268e04874fc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="structicl_1_1math_1_1DynMatrix.html#a5c1050678033ac039ab268e04874fc83">More...</a><br /></td></tr>
<tr class="separator:a5c1050678033ac039ab268e04874fc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948bbcb9cfeba3b43fa7a36a95e855f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a948bbcb9cfeba3b43fa7a36a95e855f8">DynMatrix</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a948bbcb9cfeba3b43fa7a36a95e855f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new <a class="el" href="structicl_1_1math_1_1DynMatrix.html" title="Highly flexible and optimized matrix class implementation.">DynMatrix</a> from given csv filename  <a href="structicl_1_1math_1_1DynMatrix.html#a948bbcb9cfeba3b43fa7a36a95e855f8">More...</a><br /></td></tr>
<tr class="separator:a948bbcb9cfeba3b43fa7a36a95e855f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d4769a2a3ea619e53b3ff057a9d2ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ad6d4769a2a3ea619e53b3ff057a9d2ba">saveCSV</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:ad6d4769a2a3ea619e53b3ff057a9d2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes the current matrix to a csv file  <a href="structicl_1_1math_1_1DynMatrix.html#ad6d4769a2a3ea619e53b3ff057a9d2ba">More...</a><br /></td></tr>
<tr class="separator:ad6d4769a2a3ea619e53b3ff057a9d2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292d54229b55e288cf7dbd0da744fa09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a292d54229b55e288cf7dbd0da744fa09">isNull</a> () const</td></tr>
<tr class="memdesc:a292d54229b55e288cf7dbd0da744fa09"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns with this matrix has a valid data pointer  <a href="structicl_1_1math_1_1DynMatrix.html#a292d54229b55e288cf7dbd0da744fa09">More...</a><br /></td></tr>
<tr class="separator:a292d54229b55e288cf7dbd0da744fa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cfcf75fdcdffefb3e890594e5f80ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a12cfcf75fdcdffefb3e890594e5f80ea">~DynMatrix</a> ()</td></tr>
<tr class="memdesc:a12cfcf75fdcdffefb3e890594e5f80ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (deletes data if no wrapped shallowly)  <a href="structicl_1_1math_1_1DynMatrix.html#a12cfcf75fdcdffefb3e890594e5f80ea">More...</a><br /></td></tr>
<tr class="separator:a12cfcf75fdcdffefb3e890594e5f80ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba0018db73a7bc063551efd335c8414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a1ba0018db73a7bc063551efd335c8414">operator=</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;other)</td></tr>
<tr class="memdesc:a1ba0018db73a7bc063551efd335c8414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator (using deep/shallow-copy)  <a href="structicl_1_1math_1_1DynMatrix.html#a1ba0018db73a7bc063551efd335c8414">More...</a><br /></td></tr>
<tr class="separator:a1ba0018db73a7bc063551efd335c8414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a56b7ea708e375e6a68e1cdec2536cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a8a56b7ea708e375e6a68e1cdec2536cc">setBounds</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a06b8be83f6d36b95723daa0403ab4d55">cols</a>, unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a87aa61cb0482e28f53b874999fb5d722">rows</a>, bool holdContent=false, const T &amp;initializer=0)</td></tr>
<tr class="memdesc:a8a56b7ea708e375e6a68e1cdec2536cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets matrix dimensions  <a href="structicl_1_1math_1_1DynMatrix.html#a8a56b7ea708e375e6a68e1cdec2536cc">More...</a><br /></td></tr>
<tr class="separator:a8a56b7ea708e375e6a68e1cdec2536cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf8e311a5f539a1548ed5838f95b300"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a6cf8e311a5f539a1548ed5838f95b300">isSimilar</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;other, T tollerance=T(0.0001)) const</td></tr>
<tr class="memdesc:a6cf8e311a5f539a1548ed5838f95b300"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests weather a matrix is enough similar to another matrix  <a href="structicl_1_1math_1_1DynMatrix.html#a6cf8e311a5f539a1548ed5838f95b300">More...</a><br /></td></tr>
<tr class="separator:a6cf8e311a5f539a1548ed5838f95b300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf3ced1498d6bb7a858e1a0e5c8d48a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#adaf3ced1498d6bb7a858e1a0e5c8d48a">operator==</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:adaf3ced1498d6bb7a858e1a0e5c8d48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise comparison (==)  <a href="structicl_1_1math_1_1DynMatrix.html#adaf3ced1498d6bb7a858e1a0e5c8d48a">More...</a><br /></td></tr>
<tr class="separator:adaf3ced1498d6bb7a858e1a0e5c8d48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dfb53af4a5a0526d8d15427dcbf48f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ad3dfb53af4a5a0526d8d15427dcbf48f">operator!=</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:ad3dfb53af4a5a0526d8d15427dcbf48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise comparison (!=)  <a href="structicl_1_1math_1_1DynMatrix.html#ad3dfb53af4a5a0526d8d15427dcbf48f">More...</a><br /></td></tr>
<tr class="separator:ad3dfb53af4a5a0526d8d15427dcbf48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f43ae818407c4e6ab10a3bfc1cb4195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a3f43ae818407c4e6ab10a3bfc1cb4195">operator*</a> (T f) const</td></tr>
<tr class="memdesc:a3f43ae818407c4e6ab10a3bfc1cb4195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply elements with scalar.  <a href="structicl_1_1math_1_1DynMatrix.html#a3f43ae818407c4e6ab10a3bfc1cb4195">More...</a><br /></td></tr>
<tr class="separator:a3f43ae818407c4e6ab10a3bfc1cb4195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de01d1ec4cb7d933217c40b57908862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a7de01d1ec4cb7d933217c40b57908862">mult</a> (T f, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;dst) const</td></tr>
<tr class="memdesc:a7de01d1ec4cb7d933217c40b57908862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply elements with scalar (in source destination fashion)  <a href="structicl_1_1math_1_1DynMatrix.html#a7de01d1ec4cb7d933217c40b57908862">More...</a><br /></td></tr>
<tr class="separator:a7de01d1ec4cb7d933217c40b57908862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f31cffedde0537c9fd77fba3654d27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a86f31cffedde0537c9fd77fba3654d27">operator*=</a> (T f)</td></tr>
<tr class="memdesc:a86f31cffedde0537c9fd77fba3654d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply elements with scalar (inplace)  <a href="structicl_1_1math_1_1DynMatrix.html#a86f31cffedde0537c9fd77fba3654d27">More...</a><br /></td></tr>
<tr class="separator:a86f31cffedde0537c9fd77fba3654d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7189d560790930eb3799129b56b1a674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a7189d560790930eb3799129b56b1a674">operator/</a> (T f) const</td></tr>
<tr class="memdesc:a7189d560790930eb3799129b56b1a674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device elements by scalar.  <a href="structicl_1_1math_1_1DynMatrix.html#a7189d560790930eb3799129b56b1a674">More...</a><br /></td></tr>
<tr class="separator:a7189d560790930eb3799129b56b1a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a31d1ec360c609e3fbb89a738c5563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a64a31d1ec360c609e3fbb89a738c5563">operator/=</a> (T f)</td></tr>
<tr class="memdesc:a64a31d1ec360c609e3fbb89a738c5563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device elements by scalar (inplace)  <a href="structicl_1_1math_1_1DynMatrix.html#a64a31d1ec360c609e3fbb89a738c5563">More...</a><br /></td></tr>
<tr class="separator:a64a31d1ec360c609e3fbb89a738c5563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e164c5d093b6b8b01aeaecb7a249a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a526e164c5d093b6b8b01aeaecb7a249a">mult</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;dst) const</td></tr>
<tr class="memdesc:a526e164c5d093b6b8b01aeaecb7a249a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication (in source destination fashion) [IPP-Supported].  <a href="structicl_1_1math_1_1DynMatrix.html#a526e164c5d093b6b8b01aeaecb7a249a">More...</a><br /></td></tr>
<tr class="separator:a526e164c5d093b6b8b01aeaecb7a249a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e89bc1d3c71b19048dedcd167f1c4e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a9e89bc1d3c71b19048dedcd167f1c4e0">elementwise_mult</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;dst) const</td></tr>
<tr class="memdesc:a9e89bc1d3c71b19048dedcd167f1c4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise matrix multiplication (in source destination fashion) [IPP-Supported].  <a href="structicl_1_1math_1_1DynMatrix.html#a9e89bc1d3c71b19048dedcd167f1c4e0">More...</a><br /></td></tr>
<tr class="separator:a9e89bc1d3c71b19048dedcd167f1c4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8710e37516d7f38eca87b9ee03bbafec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a8710e37516d7f38eca87b9ee03bbafec">elementwise_mult</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m) const</td></tr>
<tr class="memdesc:a8710e37516d7f38eca87b9ee03bbafec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise matrix multiplication (without destination matrix) [IPP-Supported].  <a href="structicl_1_1math_1_1DynMatrix.html#a8710e37516d7f38eca87b9ee03bbafec">More...</a><br /></td></tr>
<tr class="separator:a8710e37516d7f38eca87b9ee03bbafec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a86f40e987dcd02d5a087d27eed15d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a9a86f40e987dcd02d5a087d27eed15d3">elementwise_div</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;dst) const</td></tr>
<tr class="memdesc:a9a86f40e987dcd02d5a087d27eed15d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise division (in source destination fashion) [IPP-Supported].  <a href="structicl_1_1math_1_1DynMatrix.html#a9a86f40e987dcd02d5a087d27eed15d3">More...</a><br /></td></tr>
<tr class="separator:a9a86f40e987dcd02d5a087d27eed15d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e93701cb0f13ded02812463179cf16f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a4e93701cb0f13ded02812463179cf16f">elementwise_div</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m) const</td></tr>
<tr class="memdesc:a4e93701cb0f13ded02812463179cf16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise matrix multiplication (without destination matrix) [IPP-Supported].  <a href="structicl_1_1math_1_1DynMatrix.html#a4e93701cb0f13ded02812463179cf16f">More...</a><br /></td></tr>
<tr class="separator:a4e93701cb0f13ded02812463179cf16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa621498523dfda0865ac7fd81be645f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#aa621498523dfda0865ac7fd81be645f0">operator*</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m) const</td></tr>
<tr class="memdesc:aa621498523dfda0865ac7fd81be645f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Essential matrix multiplication [IPP-Supported].  <a href="structicl_1_1math_1_1DynMatrix.html#aa621498523dfda0865ac7fd81be645f0">More...</a><br /></td></tr>
<tr class="separator:aa621498523dfda0865ac7fd81be645f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefd212657e38869cd252df32071818a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#aeefd212657e38869cd252df32071818a">operator*=</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m)</td></tr>
<tr class="memdesc:aeefd212657e38869cd252df32071818a"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace matrix multiplication applying this = this*m [IPP-Supported]  <a href="structicl_1_1math_1_1DynMatrix.html#aeefd212657e38869cd252df32071818a">More...</a><br /></td></tr>
<tr class="separator:aeefd212657e38869cd252df32071818a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a127fba99451e0062ef7cce514f1cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a4a127fba99451e0062ef7cce514f1cb7">operator/</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m) const</td></tr>
<tr class="memdesc:a4a127fba99451e0062ef7cce514f1cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace matrix devision (calling this/m.inv()) [IPP-Supported]  <a href="structicl_1_1math_1_1DynMatrix.html#a4a127fba99451e0062ef7cce514f1cb7">More...</a><br /></td></tr>
<tr class="separator:a4a127fba99451e0062ef7cce514f1cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9922440d61c4abac17eb47160de5108b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a9922440d61c4abac17eb47160de5108b">operator/=</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m) const</td></tr>
<tr class="memdesc:a9922440d61c4abac17eb47160de5108b"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace matrix devision (calling this/m.inv()) (inplace)  <a href="structicl_1_1math_1_1DynMatrix.html#a9922440d61c4abac17eb47160de5108b">More...</a><br /></td></tr>
<tr class="separator:a9922440d61c4abac17eb47160de5108b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf1df5b40051a752ff644b173ed6952"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#abbf1df5b40051a752ff644b173ed6952">operator+</a> (const T &amp;t) const</td></tr>
<tr class="memdesc:abbf1df5b40051a752ff644b173ed6952"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a scalar to each element  <a href="structicl_1_1math_1_1DynMatrix.html#abbf1df5b40051a752ff644b173ed6952">More...</a><br /></td></tr>
<tr class="separator:abbf1df5b40051a752ff644b173ed6952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df3f276083ef6ddf06d0da007230b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a0df3f276083ef6ddf06d0da007230b9c">operator-</a> (const T &amp;t) const</td></tr>
<tr class="memdesc:a0df3f276083ef6ddf06d0da007230b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">substacts a scalar from each element  <a href="structicl_1_1math_1_1DynMatrix.html#a0df3f276083ef6ddf06d0da007230b9c">More...</a><br /></td></tr>
<tr class="separator:a0df3f276083ef6ddf06d0da007230b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9afb7d5e86071b1f2fdbb501d4e7963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab9afb7d5e86071b1f2fdbb501d4e7963">operator+=</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ab9afb7d5e86071b1f2fdbb501d4e7963"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a scalar to each element (inplace)  <a href="structicl_1_1math_1_1DynMatrix.html#ab9afb7d5e86071b1f2fdbb501d4e7963">More...</a><br /></td></tr>
<tr class="separator:ab9afb7d5e86071b1f2fdbb501d4e7963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a32515dfd7b51612a090cf5dd01751"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a19a32515dfd7b51612a090cf5dd01751">operator-=</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a19a32515dfd7b51612a090cf5dd01751"><td class="mdescLeft">&#160;</td><td class="mdescRight">substacts a scalar from each element (inplace)  <a href="structicl_1_1math_1_1DynMatrix.html#a19a32515dfd7b51612a090cf5dd01751">More...</a><br /></td></tr>
<tr class="separator:a19a32515dfd7b51612a090cf5dd01751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e53b2595a345ac950e1d6e8b61b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ae33e53b2595a345ac950e1d6e8b61b39">operator+</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m) const</td></tr>
<tr class="memdesc:ae33e53b2595a345ac950e1d6e8b61b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix addition.  <a href="structicl_1_1math_1_1DynMatrix.html#ae33e53b2595a345ac950e1d6e8b61b39">More...</a><br /></td></tr>
<tr class="separator:ae33e53b2595a345ac950e1d6e8b61b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cf2f37ab2e332881231aaa668043b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ae4cf2f37ab2e332881231aaa668043b3">operator-</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m) const</td></tr>
<tr class="memdesc:ae4cf2f37ab2e332881231aaa668043b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix substraction.  <a href="structicl_1_1math_1_1DynMatrix.html#ae4cf2f37ab2e332881231aaa668043b3">More...</a><br /></td></tr>
<tr class="separator:ae4cf2f37ab2e332881231aaa668043b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fbdb50dbe12dd2410403f9dbdc2cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ad5fbdb50dbe12dd2410403f9dbdc2cff">operator+=</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m)</td></tr>
<tr class="memdesc:ad5fbdb50dbe12dd2410403f9dbdc2cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix addition (inplace)  <a href="structicl_1_1math_1_1DynMatrix.html#ad5fbdb50dbe12dd2410403f9dbdc2cff">More...</a><br /></td></tr>
<tr class="separator:ad5fbdb50dbe12dd2410403f9dbdc2cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3db8f6686dffc6ab0b57f478d59e517"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ae3db8f6686dffc6ab0b57f478d59e517">operator-=</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;m)</td></tr>
<tr class="memdesc:ae3db8f6686dffc6ab0b57f478d59e517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix substraction (inplace)  <a href="structicl_1_1math_1_1DynMatrix.html#ae3db8f6686dffc6ab0b57f478d59e517">More...</a><br /></td></tr>
<tr class="separator:ae3db8f6686dffc6ab0b57f478d59e517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c12abd5a40dddc119ddb7b382f81b16"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a4c12abd5a40dddc119ddb7b382f81b16">operator()</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>, unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>)</td></tr>
<tr class="memdesc:a4c12abd5a40dddc119ddb7b382f81b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">element access operator (x,y)-access index begin 0!  <a href="structicl_1_1math_1_1DynMatrix.html#a4c12abd5a40dddc119ddb7b382f81b16">More...</a><br /></td></tr>
<tr class="separator:a4c12abd5a40dddc119ddb7b382f81b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a09f7862c9afc83821da277b56e1b8"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a32a09f7862c9afc83821da277b56e1b8">operator()</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>, unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>) const</td></tr>
<tr class="memdesc:a32a09f7862c9afc83821da277b56e1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">element access operator (x,y)-access index begin 0! (const)  <a href="structicl_1_1math_1_1DynMatrix.html#a32a09f7862c9afc83821da277b56e1b8">More...</a><br /></td></tr>
<tr class="separator:a32a09f7862c9afc83821da277b56e1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee25e09582694b927e4d6b8e0d540ca3"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#aee25e09582694b927e4d6b8e0d540ca3">at</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>, unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>)</td></tr>
<tr class="memdesc:aee25e09582694b927e4d6b8e0d540ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">element access with index check  <a href="structicl_1_1math_1_1DynMatrix.html#aee25e09582694b927e4d6b8e0d540ca3">More...</a><br /></td></tr>
<tr class="separator:aee25e09582694b927e4d6b8e0d540ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4ec62fb6a2fccecb8a17b541b1dbbc"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a5d4ec62fb6a2fccecb8a17b541b1dbbc">at</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>, unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>) const</td></tr>
<tr class="memdesc:a5d4ec62fb6a2fccecb8a17b541b1dbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">element access with index check (const)  <a href="structicl_1_1math_1_1DynMatrix.html#a5d4ec62fb6a2fccecb8a17b541b1dbbc">More...</a><br /></td></tr>
<tr class="separator:a5d4ec62fb6a2fccecb8a17b541b1dbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d187d409b26fdb01013258b042e1d1"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a69d187d409b26fdb01013258b042e1d1">operator[]</a> (unsigned int idx)</td></tr>
<tr class="memdesc:a69d187d409b26fdb01013258b042e1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear access to actual data array  <a href="structicl_1_1math_1_1DynMatrix.html#a69d187d409b26fdb01013258b042e1d1">More...</a><br /></td></tr>
<tr class="separator:a69d187d409b26fdb01013258b042e1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62ab3342979ff658a747f43f6b71abc"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#af62ab3342979ff658a747f43f6b71abc">operator[]</a> (unsigned int idx) const</td></tr>
<tr class="memdesc:af62ab3342979ff658a747f43f6b71abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear access to actual data array (const)  <a href="structicl_1_1math_1_1DynMatrix.html#af62ab3342979ff658a747f43f6b71abc">More...</a><br /></td></tr>
<tr class="separator:af62ab3342979ff658a747f43f6b71abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7ddd429e9ba1d2ae0f8a1c86654470"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a9e7ddd429e9ba1d2ae0f8a1c86654470">norm</a> (double l=2) const</td></tr>
<tr class="memdesc:a9e7ddd429e9ba1d2ae0f8a1c86654470"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies an L_l norm on the matrix elements (all elements are treated as vector)  <a href="structicl_1_1math_1_1DynMatrix.html#a9e7ddd429e9ba1d2ae0f8a1c86654470">More...</a><br /></td></tr>
<tr class="separator:a9e7ddd429e9ba1d2ae0f8a1c86654470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2e1590d8196a2131c71146cb7dd44d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#aaf2e1590d8196a2131c71146cb7dd44d">sqrDistanceTo</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:aaf2e1590d8196a2131c71146cb7dd44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the squared distance of the inner data vectors (linearly interpreted) (IPP accelerated)  <a href="structicl_1_1math_1_1DynMatrix.html#aaf2e1590d8196a2131c71146cb7dd44d">More...</a><br /></td></tr>
<tr class="separator:aaf2e1590d8196a2131c71146cb7dd44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0640d7e91eff9045485519a7c13f2c94"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a0640d7e91eff9045485519a7c13f2c94">distanceTo</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:a0640d7e91eff9045485519a7c13f2c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the distance of the inner data vectors (linearly interpreted) (IPP accelerated)  <a href="structicl_1_1math_1_1DynMatrix.html#a0640d7e91eff9045485519a7c13f2c94">More...</a><br /></td></tr>
<tr class="separator:a0640d7e91eff9045485519a7c13f2c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87aa61cb0482e28f53b874999fb5d722"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a87aa61cb0482e28f53b874999fb5d722">rows</a> () const</td></tr>
<tr class="memdesc:a87aa61cb0482e28f53b874999fb5d722"><td class="mdescLeft">&#160;</td><td class="mdescRight">height of the matrix (number of rows)  <a href="structicl_1_1math_1_1DynMatrix.html#a87aa61cb0482e28f53b874999fb5d722">More...</a><br /></td></tr>
<tr class="separator:a87aa61cb0482e28f53b874999fb5d722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b8be83f6d36b95723daa0403ab4d55"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a06b8be83f6d36b95723daa0403ab4d55">cols</a> () const</td></tr>
<tr class="memdesc:a06b8be83f6d36b95723daa0403ab4d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">width of the matrix (number of columns)  <a href="structicl_1_1math_1_1DynMatrix.html#a06b8be83f6d36b95723daa0403ab4d55">More...</a><br /></td></tr>
<tr class="separator:a06b8be83f6d36b95723daa0403ab4d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730c7185310fb60477d2d5dd5dad2e5f"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a730c7185310fb60477d2d5dd5dad2e5f">data</a> ()</td></tr>
<tr class="memdesc:a730c7185310fb60477d2d5dd5dad2e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal data pointer  <a href="structicl_1_1math_1_1DynMatrix.html#a730c7185310fb60477d2d5dd5dad2e5f">More...</a><br /></td></tr>
<tr class="separator:a730c7185310fb60477d2d5dd5dad2e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e306422c97f10ecbf04d5f7cc3d2815"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a6e306422c97f10ecbf04d5f7cc3d2815">data</a> () const</td></tr>
<tr class="memdesc:a6e306422c97f10ecbf04d5f7cc3d2815"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal data pointer (const)  <a href="structicl_1_1math_1_1DynMatrix.html#a6e306422c97f10ecbf04d5f7cc3d2815">More...</a><br /></td></tr>
<tr class="separator:a6e306422c97f10ecbf04d5f7cc3d2815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c06d2247b472fedc05d8894a5fb582"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ae1c06d2247b472fedc05d8894a5fb582">dim</a> () const</td></tr>
<tr class="memdesc:ae1c06d2247b472fedc05d8894a5fb582"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix dimension (width*height) or (cols*rows)  <a href="structicl_1_1math_1_1DynMatrix.html#ae1c06d2247b472fedc05d8894a5fb582">More...</a><br /></td></tr>
<tr class="separator:ae1c06d2247b472fedc05d8894a5fb582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea77388cac36a51092804540dab5d73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#aaea77388cac36a51092804540dab5d73">stride0</a> () const</td></tr>
<tr class="memdesc:aaea77388cac36a51092804540dab5d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sizeof (T)*dim()  <a href="structicl_1_1math_1_1DynMatrix.html#aaea77388cac36a51092804540dab5d73">More...</a><br /></td></tr>
<tr class="separator:aaea77388cac36a51092804540dab5d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd47232663031e25ca432cf29a7c813"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a7fd47232663031e25ca432cf29a7c813">stride1</a> () const</td></tr>
<tr class="memdesc:a7fd47232663031e25ca432cf29a7c813"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sizeof(T)*cols()  <a href="structicl_1_1math_1_1DynMatrix.html#a7fd47232663031e25ca432cf29a7c813">More...</a><br /></td></tr>
<tr class="separator:a7fd47232663031e25ca432cf29a7c813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba7d61f8e4a06c42b748e6419cd10c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a2ba7d61f8e4a06c42b748e6419cd10c2">stride2</a> () const</td></tr>
<tr class="memdesc:a2ba7d61f8e4a06c42b748e6419cd10c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sizeof (T)  <a href="structicl_1_1math_1_1DynMatrix.html#a2ba7d61f8e4a06c42b748e6419cd10c2">More...</a><br /></td></tr>
<tr class="separator:a2ba7d61f8e4a06c42b748e6419cd10c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc99de9a8c4d5a4b883af4490567764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a1fc99de9a8c4d5a4b883af4490567764">operator=</a> (const <a class="el" href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html">DynMatrixColumn</a> &amp;<a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>)</td></tr>
<tr class="separator:a1fc99de9a8c4d5a4b883af4490567764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebcb8042f1dba49bbd91b87c5b0a6c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ac9d42828615aac0caac6c29b45a8045f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#acebcb8042f1dba49bbd91b87c5b0a6c7">begin</a> ()</td></tr>
<tr class="memdesc:acebcb8042f1dba49bbd91b87c5b0a6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the begin of internal data array  <a href="structicl_1_1math_1_1DynMatrix.html#acebcb8042f1dba49bbd91b87c5b0a6c7">More...</a><br /></td></tr>
<tr class="separator:acebcb8042f1dba49bbd91b87c5b0a6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce9e205cd07d91be4bb294f96412e46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ac9d42828615aac0caac6c29b45a8045f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#acce9e205cd07d91be4bb294f96412e46">end</a> ()</td></tr>
<tr class="memdesc:acce9e205cd07d91be4bb294f96412e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the end of internal data array  <a href="structicl_1_1math_1_1DynMatrix.html#acce9e205cd07d91be4bb294f96412e46">More...</a><br /></td></tr>
<tr class="separator:acce9e205cd07d91be4bb294f96412e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb558fa575e7b0259286e5ef8d3fb932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a91bcd84b01ce44f98685cdb7e9fea845">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#abb558fa575e7b0259286e5ef8d3fb932">begin</a> () const</td></tr>
<tr class="memdesc:abb558fa575e7b0259286e5ef8d3fb932"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the begin of internal data array (const)  <a href="structicl_1_1math_1_1DynMatrix.html#abb558fa575e7b0259286e5ef8d3fb932">More...</a><br /></td></tr>
<tr class="separator:abb558fa575e7b0259286e5ef8d3fb932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b08ebf4a6da0b2cc495ae909989ba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a91bcd84b01ce44f98685cdb7e9fea845">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a97b08ebf4a6da0b2cc495ae909989ba7">end</a> () const</td></tr>
<tr class="memdesc:a97b08ebf4a6da0b2cc495ae909989ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator to the end of internal data array (const)  <a href="structicl_1_1math_1_1DynMatrix.html#a97b08ebf4a6da0b2cc495ae909989ba7">More...</a><br /></td></tr>
<tr class="separator:a97b08ebf4a6da0b2cc495ae909989ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608a629c92c25dd56f3f7034c7f9e416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix_1_1col__iterator.html">col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a608a629c92c25dd56f3f7034c7f9e416">col_begin</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>)</td></tr>
<tr class="memdesc:a608a629c92c25dd56f3f7034c7f9e416"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator running through a certain matrix column  <a href="structicl_1_1math_1_1DynMatrix.html#a608a629c92c25dd56f3f7034c7f9e416">More...</a><br /></td></tr>
<tr class="separator:a608a629c92c25dd56f3f7034c7f9e416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b17a691d44690031937b5f1c3a18b0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix_1_1col__iterator.html">col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a4b17a691d44690031937b5f1c3a18b0d">col_end</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>)</td></tr>
<tr class="memdesc:a4b17a691d44690031937b5f1c3a18b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator end of a certain matrix column  <a href="structicl_1_1math_1_1DynMatrix.html#a4b17a691d44690031937b5f1c3a18b0d">More...</a><br /></td></tr>
<tr class="separator:a4b17a691d44690031937b5f1c3a18b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfd005234c39f494826dcf1241365f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#af578b8c18a067c0b4d0b9ac93f0973c7">const_col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#aadfd005234c39f494826dcf1241365f0">col_begin</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>) const</td></tr>
<tr class="memdesc:aadfd005234c39f494826dcf1241365f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator running through a certain matrix column (const)  <a href="structicl_1_1math_1_1DynMatrix.html#aadfd005234c39f494826dcf1241365f0">More...</a><br /></td></tr>
<tr class="separator:aadfd005234c39f494826dcf1241365f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c19d3b914d76213dde3c79e34e0308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#af578b8c18a067c0b4d0b9ac93f0973c7">const_col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ae2c19d3b914d76213dde3c79e34e0308">col_end</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>) const</td></tr>
<tr class="memdesc:ae2c19d3b914d76213dde3c79e34e0308"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator end of a certain matrix column (const)  <a href="structicl_1_1math_1_1DynMatrix.html#ae2c19d3b914d76213dde3c79e34e0308">More...</a><br /></td></tr>
<tr class="separator:ae2c19d3b914d76213dde3c79e34e0308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af74d0695a04804fdfa39aeda79160c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab270c26102e39f8899f7421bbd15591c">row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a6af74d0695a04804fdfa39aeda79160c">row_begin</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>)</td></tr>
<tr class="memdesc:a6af74d0695a04804fdfa39aeda79160c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator running through a certain matrix row  <a href="structicl_1_1math_1_1DynMatrix.html#a6af74d0695a04804fdfa39aeda79160c">More...</a><br /></td></tr>
<tr class="separator:a6af74d0695a04804fdfa39aeda79160c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586be79b9c904b87eb5ca6a737cc0686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab270c26102e39f8899f7421bbd15591c">row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a586be79b9c904b87eb5ca6a737cc0686">row_end</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>)</td></tr>
<tr class="memdesc:a586be79b9c904b87eb5ca6a737cc0686"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator of a certains row's end  <a href="structicl_1_1math_1_1DynMatrix.html#a586be79b9c904b87eb5ca6a737cc0686">More...</a><br /></td></tr>
<tr class="separator:a586be79b9c904b87eb5ca6a737cc0686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a754435395ee39c12b2aa2b4f624ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a02dcebb3dacf9da7f15664393146b9d2">const_row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a03a754435395ee39c12b2aa2b4f624ae">row_begin</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>) const</td></tr>
<tr class="memdesc:a03a754435395ee39c12b2aa2b4f624ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator running through a certain matrix row (const)  <a href="structicl_1_1math_1_1DynMatrix.html#a03a754435395ee39c12b2aa2b4f624ae">More...</a><br /></td></tr>
<tr class="separator:a03a754435395ee39c12b2aa2b4f624ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c50d646775f493ea284538b043a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a02dcebb3dacf9da7f15664393146b9d2">const_row_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a6e3c50d646775f493ea284538b043a64">row_end</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>) const</td></tr>
<tr class="memdesc:a6e3c50d646775f493ea284538b043a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an iterator of a certains row's end (const)  <a href="structicl_1_1math_1_1DynMatrix.html#a6e3c50d646775f493ea284538b043a64">More...</a><br /></td></tr>
<tr class="separator:a6e3c50d646775f493ea284538b043a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39db10eaa46b7f2992b305d3d66baa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a> (int row)</td></tr>
<tr class="memdesc:ab39db10eaa46b7f2992b305d3d66baa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a shallow copied matrix row.  <a href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">More...</a><br /></td></tr>
<tr class="separator:ab39db10eaa46b7f2992b305d3d66baa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c218986527d009f42b206838d0dd71"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a09c218986527d009f42b206838d0dd71">row</a> (int row) const</td></tr>
<tr class="memdesc:a09c218986527d009f42b206838d0dd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a shallow copied matrix row (const)  <a href="structicl_1_1math_1_1DynMatrix.html#a09c218986527d009f42b206838d0dd71">More...</a><br /></td></tr>
<tr class="separator:a09c218986527d009f42b206838d0dd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d56ad4f15d86d12298ffeb12c9b522"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html">DynMatrixColumn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a> (int col)</td></tr>
<tr class="memdesc:a99d56ad4f15d86d12298ffeb12c9b522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a shallow copied matrix column.  <a href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">More...</a><br /></td></tr>
<tr class="separator:a99d56ad4f15d86d12298ffeb12c9b522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ddbc1b8a56297b3ee258f2fe1d5789"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html">DynMatrixColumn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ae1ddbc1b8a56297b3ee258f2fe1d5789">col</a> (int col) const</td></tr>
<tr class="separator:ae1ddbc1b8a56297b3ee258f2fe1d5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a98b1ca4c7b1293bf6c80ffff7ae3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ad4a98b1ca4c7b1293bf6c80ffff7ae3e">decompose_QR</a> (<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;Q, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;R) const</td></tr>
<tr class="memdesc:ad4a98b1ca4c7b1293bf6c80ffff7ae3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies QR-decomposition using stabilized Gram-Schmidt orthonormalization (only for icl32f and icl64f)  <a href="structicl_1_1math_1_1DynMatrix.html#ad4a98b1ca4c7b1293bf6c80ffff7ae3e">More...</a><br /></td></tr>
<tr class="separator:ad4a98b1ca4c7b1293bf6c80ffff7ae3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94605e7c335033e0ce5aa4bd4b3db106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a94605e7c335033e0ce5aa4bd4b3db106">decompose_RQ</a> (<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;R, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;Q) const</td></tr>
<tr class="memdesc:a94605e7c335033e0ce5aa4bd4b3db106"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies RQ-decomposition (by exploiting implemnetation of QR-decomposition) (only for icl32f, and icl64f)  <a href="structicl_1_1math_1_1DynMatrix.html#a94605e7c335033e0ce5aa4bd4b3db106">More...</a><br /></td></tr>
<tr class="separator:a94605e7c335033e0ce5aa4bd4b3db106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8dfa0494c5ef760be4a2efc6defa307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab8dfa0494c5ef760be4a2efc6defa307">decompose_LU</a> (<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;L, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;U, T zeroThreshold=T(1E-16)) const</td></tr>
<tr class="memdesc:ab8dfa0494c5ef760be4a2efc6defa307"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies LU-decomposition (without using partial pivoting) (only for icl32f and icl64f)  <a href="structicl_1_1math_1_1DynMatrix.html#ab8dfa0494c5ef760be4a2efc6defa307">More...</a><br /></td></tr>
<tr class="separator:ab8dfa0494c5ef760be4a2efc6defa307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd5678f404061bf57cec32b1618cc27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a8fd5678f404061bf57cec32b1618cc27">solve_upper_triangular</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;b) const</td></tr>
<tr class="memdesc:a8fd5678f404061bf57cec32b1618cc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves Mx=b for M=*this (only if M is a squared upper triangular matrix) (only for icl32f and icl64f)  <a href="structicl_1_1math_1_1DynMatrix.html#a8fd5678f404061bf57cec32b1618cc27">More...</a><br /></td></tr>
<tr class="separator:a8fd5678f404061bf57cec32b1618cc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b1c32ead7366cdf9f97bd95c5e61e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a39b1c32ead7366cdf9f97bd95c5e61e5">solve_lower_triangular</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;b) const</td></tr>
<tr class="memdesc:a39b1c32ead7366cdf9f97bd95c5e61e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves Mx=b for M=*this (only if M is a squared lower triangular matrix) (only for icl32f and icl64f)  <a href="structicl_1_1math_1_1DynMatrix.html#a39b1c32ead7366cdf9f97bd95c5e61e5">More...</a><br /></td></tr>
<tr class="separator:a39b1c32ead7366cdf9f97bd95c5e61e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f15be51279fd30075923615167fd45b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a2f15be51279fd30075923615167fd45b">solve</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;b, const std::string &amp;method=&quot;lu&quot;, T zeroThreshold=T(1E-16))</td></tr>
<tr class="memdesc:a2f15be51279fd30075923615167fd45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves Mx=b for M=*this (only for icl32f and icl64f)  <a href="structicl_1_1math_1_1DynMatrix.html#a2f15be51279fd30075923615167fd45b">More...</a><br /></td></tr>
<tr class="separator:a2f15be51279fd30075923615167fd45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8411b9f5ee93f2a239cf860b2e9a4a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a8411b9f5ee93f2a239cf860b2e9a4a16">inv</a> () const</td></tr>
<tr class="memdesc:a8411b9f5ee93f2a239cf860b2e9a4a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">invert the matrix (only for icl32f and icl64f)  <a href="structicl_1_1math_1_1DynMatrix.html#a8411b9f5ee93f2a239cf860b2e9a4a16">More...</a><br /></td></tr>
<tr class="separator:a8411b9f5ee93f2a239cf860b2e9a4a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f52db1d603c036c1c6e82b290fe38a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a2f52db1d603c036c1c6e82b290fe38a2">eigen</a> (<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;eigenvectors, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;eigenvalues) const</td></tr>
<tr class="memdesc:a2f52db1d603c036c1c6e82b290fe38a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the matrix's eigenvalues and eigenvectors.  <a href="structicl_1_1math_1_1DynMatrix.html#a2f52db1d603c036c1c6e82b290fe38a2">More...</a><br /></td></tr>
<tr class="separator:a2f52db1d603c036c1c6e82b290fe38a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925d12155ba95dcdeef1fa63834b4326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a925d12155ba95dcdeef1fa63834b4326">svd</a> (<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;U, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;S, <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> &amp;V) const</td></tr>
<tr class="memdesc:a925d12155ba95dcdeef1fa63834b4326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Singular Value Decomposition of a matrix - decomposes A into USV'.  <a href="structicl_1_1math_1_1DynMatrix.html#a925d12155ba95dcdeef1fa63834b4326">More...</a><br /></td></tr>
<tr class="separator:a925d12155ba95dcdeef1fa63834b4326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4551b37598970f5ebd64f9a0d4843ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a4551b37598970f5ebd64f9a0d4843ff6">pinv</a> (bool useSVD=false, T zeroThreshold=T(1E-16)) const</td></tr>
<tr class="memdesc:a4551b37598970f5ebd64f9a0d4843ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the Moore-Penrose pseudo-inverse (only implemented for icl32f and icl64f)  <a href="structicl_1_1math_1_1DynMatrix.html#a4551b37598970f5ebd64f9a0d4843ff6">More...</a><br /></td></tr>
<tr class="separator:a4551b37598970f5ebd64f9a0d4843ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fdf2d2f1bb39d2018d3d29062101a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ae9fdf2d2f1bb39d2018d3d29062101a6">big_matrix_pinv</a> (T zeroThreshold=T(1E-16)) const</td></tr>
<tr class="memdesc:ae9fdf2d2f1bb39d2018d3d29062101a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the Moore-Penrose pseudo-inverse (specialized for big matrices)  <a href="structicl_1_1math_1_1DynMatrix.html#ae9fdf2d2f1bb39d2018d3d29062101a6">More...</a><br /></td></tr>
<tr class="separator:ae9fdf2d2f1bb39d2018d3d29062101a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad32142b806afd47022dfcc43c10b20f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#aad32142b806afd47022dfcc43c10b20f">big_matrix_pinv</a> (T zeroThreshold, <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab7bcb2e89a1a64f18cc3d2c21a33ab2e">GESDD</a> gesdd, <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a8c4e508192704d0b034d1fdfbca176a7">CBLAS_GEMM</a> cblas_gemm) const</td></tr>
<tr class="separator:aad32142b806afd47022dfcc43c10b20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dd25df17bfeee9450e469e8ff4b6ef"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a46dd25df17bfeee9450e469e8ff4b6ef">det</a> () const</td></tr>
<tr class="memdesc:a46dd25df17bfeee9450e469e8ff4b6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix determinant (only for icl32f and icl64f)  <a href="structicl_1_1math_1_1DynMatrix.html#a46dd25df17bfeee9450e469e8ff4b6ef">More...</a><br /></td></tr>
<tr class="separator:a46dd25df17bfeee9450e469e8ff4b6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff0a60ea0fce98cd7fc90b352bb6b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#adff0a60ea0fce98cd7fc90b352bb6b8f">transp</a> () const</td></tr>
<tr class="memdesc:adff0a60ea0fce98cd7fc90b352bb6b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix transposed  <a href="structicl_1_1math_1_1DynMatrix.html#adff0a60ea0fce98cd7fc90b352bb6b8f">More...</a><br /></td></tr>
<tr class="separator:adff0a60ea0fce98cd7fc90b352bb6b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410ed7757fb3c544f32807825b454788"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a410ed7757fb3c544f32807825b454788">shallowTransposed</a> () const</td></tr>
<tr class="memdesc:a410ed7757fb3c544f32807825b454788"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a shallow transposed copy of this matrix (dimensions are swapped, data is not re-aranged) (const)  <a href="structicl_1_1math_1_1DynMatrix.html#a410ed7757fb3c544f32807825b454788">More...</a><br /></td></tr>
<tr class="separator:a410ed7757fb3c544f32807825b454788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3848f54865dc90b0b6addcfe30e3e93"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#af3848f54865dc90b0b6addcfe30e3e93">shallowTransposed</a> ()</td></tr>
<tr class="memdesc:af3848f54865dc90b0b6addcfe30e3e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a shallow transposed copy of this matrix (dimensions are swapped, data is not re-aranged)  <a href="structicl_1_1math_1_1DynMatrix.html#af3848f54865dc90b0b6addcfe30e3e93">More...</a><br /></td></tr>
<tr class="separator:af3848f54865dc90b0b6addcfe30e3e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6c1ac2738c8735a149d090f05ed7bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a3f6c1ac2738c8735a149d090f05ed7bb">reshape</a> (int newCols, int newRows)</td></tr>
<tr class="memdesc:a3f6c1ac2738c8735a149d090f05ed7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the matrix dimensions without changing the content  <a href="structicl_1_1math_1_1DynMatrix.html#a3f6c1ac2738c8735a149d090f05ed7bb">More...</a><br /></td></tr>
<tr class="separator:a3f6c1ac2738c8735a149d090f05ed7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbd5129535915f3f75901949e67a419"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a7dbd5129535915f3f75901949e67a419">element_wise_inner_product</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a7dbd5129535915f3f75901949e67a419"><td class="mdescLeft">&#160;</td><td class="mdescRight">inner product of data pointers (not matrix-mulitiplication)  <a href="structicl_1_1math_1_1DynMatrix.html#a7dbd5129535915f3f75901949e67a419">More...</a><br /></td></tr>
<tr class="separator:a7dbd5129535915f3f75901949e67a419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b738def3285791d129aa3fa776ed1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#af3b738def3285791d129aa3fa776ed1d">dot</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;M) const</td></tr>
<tr class="memdesc:af3b738def3285791d129aa3fa776ed1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the inner product of two matrices (i.e. dot-product)  <a href="structicl_1_1math_1_1DynMatrix.html#af3b738def3285791d129aa3fa776ed1d">More...</a><br /></td></tr>
<tr class="separator:af3b738def3285791d129aa3fa776ed1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada56d439c9b3c072d4f3f75ba61ef556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ada56d439c9b3c072d4f3f75ba61ef556">diag</a> () const</td></tr>
<tr class="memdesc:ada56d439c9b3c072d4f3f75ba61ef556"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns diagonal-elements as column-vector  <a href="structicl_1_1math_1_1DynMatrix.html#ada56d439c9b3c072d4f3f75ba61ef556">More...</a><br /></td></tr>
<tr class="separator:ada56d439c9b3c072d4f3f75ba61ef556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299d7a07df7e8c36068a319dfaf35a45"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a299d7a07df7e8c36068a319dfaf35a45">trace</a> () const</td></tr>
<tr class="memdesc:a299d7a07df7e8c36068a319dfaf35a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the sum of all diagonal elements  <a href="structicl_1_1math_1_1DynMatrix.html#a299d7a07df7e8c36068a319dfaf35a45">More...</a><br /></td></tr>
<tr class="separator:a299d7a07df7e8c36068a319dfaf35a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda8bb07191dda612b7ee5d802313bfc"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#abda8bb07191dda612b7ee5d802313bfc">cond</a> (const double p=2) const</td></tr>
<tr class="memdesc:abda8bb07191dda612b7ee5d802313bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the condition of a matrix  <a href="structicl_1_1math_1_1DynMatrix.html#abda8bb07191dda612b7ee5d802313bfc">More...</a><br /></td></tr>
<tr class="separator:abda8bb07191dda612b7ee5d802313bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568f127e1c498e9247e9508adc67146d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a568f127e1c498e9247e9508adc67146d">set_data</a> (T *newData)</td></tr>
<tr class="memdesc:a568f127e1c498e9247e9508adc67146d"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets new data internally and returns old data pointer (for experts only!)  <a href="structicl_1_1math_1_1DynMatrix.html#a568f127e1c498e9247e9508adc67146d">More...</a><br /></td></tr>
<tr class="separator:a568f127e1c498e9247e9508adc67146d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0064a6e67113570e4789dd555f18342f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a0064a6e67113570e4789dd555f18342f">loadCSV</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a0064a6e67113570e4789dd555f18342f"><td class="mdescLeft">&#160;</td><td class="mdescRight">loads a dynmatrix from given CSV file  <a href="structicl_1_1math_1_1DynMatrix.html#a0064a6e67113570e4789dd555f18342f">More...</a><br /></td></tr>
<tr class="separator:a0064a6e67113570e4789dd555f18342f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3c14249c627150c0ab794d887e379f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#abb3c14249c627150c0ab794d887e379f">cross</a> (const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;x, const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:abb3c14249c627150c0ab794d887e379f"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the cross product  <a href="structicl_1_1math_1_1DynMatrix.html#abb3c14249c627150c0ab794d887e379f">More...</a><br /></td></tr>
<tr class="separator:abb3c14249c627150c0ab794d887e379f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0837980613fff242363f5c7df9db7648"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a0837980613fff242363f5c7df9db7648">id</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ae1c06d2247b472fedc05d8894a5fb582">dim</a>)</td></tr>
<tr class="memdesc:a0837980613fff242363f5c7df9db7648"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a dim-D identity Matrix  <a href="structicl_1_1math_1_1DynMatrix.html#a0837980613fff242363f5c7df9db7648">More...</a><br /></td></tr>
<tr class="separator:a0837980613fff242363f5c7df9db7648"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a91bcd84b01ce44f98685cdb7e9fea845"><td class="memItemLeft" align="right" valign="top">const typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a91bcd84b01ce44f98685cdb7e9fea845">const_iterator</a></td></tr>
<tr class="memdesc:a91bcd84b01ce44f98685cdb7e9fea845"><td class="mdescLeft">&#160;</td><td class="mdescRight">dafault const_iterator type (just a data-pointer)  <a href="structicl_1_1math_1_1DynMatrix.html#a91bcd84b01ce44f98685cdb7e9fea845">More...</a><br /></td></tr>
<tr class="separator:a91bcd84b01ce44f98685cdb7e9fea845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02dcebb3dacf9da7f15664393146b9d2"><td class="memItemLeft" align="right" valign="top">const typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a02dcebb3dacf9da7f15664393146b9d2">const_row_iterator</a></td></tr>
<tr class="memdesc:a02dcebb3dacf9da7f15664393146b9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">complex const_row_iterator type  <a href="structicl_1_1math_1_1DynMatrix.html#a02dcebb3dacf9da7f15664393146b9d2">More...</a><br /></td></tr>
<tr class="separator:a02dcebb3dacf9da7f15664393146b9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af578b8c18a067c0b4d0b9ac93f0973c7"><td class="memItemLeft" align="right" valign="top">const typedef <a class="el" href="structicl_1_1math_1_1DynMatrix_1_1col__iterator.html">col_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#af578b8c18a067c0b4d0b9ac93f0973c7">const_col_iterator</a></td></tr>
<tr class="memdesc:af578b8c18a067c0b4d0b9ac93f0973c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">const column iterator typedef  <a href="structicl_1_1math_1_1DynMatrix.html#af578b8c18a067c0b4d0b9ac93f0973c7">More...</a><br /></td></tr>
<tr class="separator:af578b8c18a067c0b4d0b9ac93f0973c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:abeb2807e82791f246907cc450d8ae309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#abeb2807e82791f246907cc450d8ae309">row_check</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>) const</td></tr>
<tr class="separator:abeb2807e82791f246907cc450d8ae309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422c26bbd581e449c8c7c37eefbde97a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a422c26bbd581e449c8c7c37eefbde97a">col_check</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>) const</td></tr>
<tr class="separator:a422c26bbd581e449c8c7c37eefbde97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66254c9de4fba2eb8590450045cef3d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a66254c9de4fba2eb8590450045cef3d7">idx_check</a> (unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a99d56ad4f15d86d12298ffeb12c9b522">col</a>, unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab39db10eaa46b7f2992b305d3d66baa4">row</a>) const</td></tr>
<tr class="separator:a66254c9de4fba2eb8590450045cef3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092b31ceb564ea137ccd504f6247b0ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a092b31ceb564ea137ccd504f6247b0ea">idx_check</a> (unsigned int idx) const</td></tr>
<tr class="separator:a092b31ceb564ea137ccd504f6247b0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7853efc7ab8f01c03e65a217e1bbe006"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a7853efc7ab8f01c03e65a217e1bbe006">m_rows</a></td></tr>
<tr class="separator:a7853efc7ab8f01c03e65a217e1bbe006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcda0bea91c2cc59c89b15a1b22a6e11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#afcda0bea91c2cc59c89b15a1b22a6e11">m_cols</a></td></tr>
<tr class="separator:afcda0bea91c2cc59c89b15a1b22a6e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8787c2f7082a7134f61706cb590cb3b0"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a8787c2f7082a7134f61706cb590cb3b0">m_data</a></td></tr>
<tr class="separator:a8787c2f7082a7134f61706cb590cb3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a8947dc78624efb508c2ec829781ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a90a8947dc78624efb508c2ec829781ae">m_ownData</a></td></tr>
<tr class="separator:a90a8947dc78624efb508c2ec829781ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
struct icl::math::DynMatrix&lt; T &gt;</h3>

<p>Highly flexible and optimized matrix class implementation. </p>
<p>In contrast to the <a class="el" href="classicl_1_1math_1_1FixedMatrix.html" title="Powerful and highly flexible matrix class implementation.">FixedMatrix</a> template class, the <a class="el" href="structicl_1_1math_1_1DynMatrix.html" title="Highly flexible and optimized matrix class implementation.">DynMatrix</a> instances are dynamically sized at runtime The template class is instantiated for the common ICL types uint8_t, int16_t, int32_t, float and double </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8c4e508192704d0b034d1fdfbca176a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4e508192704d0b034d1fdfbca176a7">&#9670;&nbsp;</a></span>CBLAS_GEMM</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::CBLAS_GEMM) (CBLAS_ORDER, CBLAS_TRANSPOSE, CBLAS_TRANSPOSE, int, int, int, T, const T *, int, const T *, int, T, T *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7bcb2e89a1a64f18cc3d2c21a33ab2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bcb2e89a1a64f18cc3d2c21a33ab2e">&#9670;&nbsp;</a></span>GESDD</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::GESDD) (const char *, const int *, const int *, T *, const int *, T *, T *, const int *, T *, const int *, T *, const int *, int *, int *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9d42828615aac0caac6c29b45a8045f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d42828615aac0caac6c29b45a8045f">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::<a class="el" href="structicl_1_1math_1_1DynMatrix.html#ac9d42828615aac0caac6c29b45a8045f">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default iterator type (just a data-pointer) </p>

</div>
</div>
<a id="ab270c26102e39f8899f7421bbd15591c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab270c26102e39f8899f7421bbd15591c">&#9670;&nbsp;</a></span>row_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::<a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab270c26102e39f8899f7421bbd15591c">row_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>comples row_iterator type </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afded5b848be8a787873aa4790d5b7b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afded5b848be8a787873aa4790d5b7b67">&#9670;&nbsp;</a></span>DynMatrix() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html">DynMatrixColumn</a> &amp;&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a column matrix from given column of other matrix </p>

</div>
</div>
<a id="ab0b0fecc4e198b10c72b68a690dc8574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b0fecc4e198b10c72b68a690dc8574">&#9670;&nbsp;</a></span>DynMatrix() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default empty constructor creates a null-matrix. </p>

</div>
</div>
<a id="a18b5b9fa1ff19a2061c646b0706df39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b5b9fa1ff19a2061c646b0706df39e">&#9670;&nbsp;</a></span>DynMatrix() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a dyn matrix with given dimensions (and optional initialValue) </p>

</div>
</div>
<a id="a63285a42de3570e7ca3f028d47c2c3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63285a42de3570e7ca3f028d47c2c3a6">&#9670;&nbsp;</a></span>DynMatrix() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deepCopy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matrix with given data. </p>
<p>Data can be wrapped deeply or shallowly. If the latter is true, given data pointer will not be released in the destructor </p>

</div>
</div>
<a id="a5ccba7dc73e50da40435adc139a57ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccba7dc73e50da40435adc139a57ade">&#9670;&nbsp;</a></span>DynMatrix() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matrix with given data (const version: deepCopy only) </p>

</div>
</div>
<a id="a5c1050678033ac039ab268e04874fc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1050678033ac039ab268e04874fc83">&#9670;&nbsp;</a></span>DynMatrix() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<a id="a948bbcb9cfeba3b43fa7a36a95e855f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948bbcb9cfeba3b43fa7a36a95e855f8">&#9670;&nbsp;</a></span>DynMatrix() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a new <a class="el" href="structicl_1_1math_1_1DynMatrix.html" title="Highly flexible and optimized matrix class implementation.">DynMatrix</a> from given csv filename </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a0064a6e67113570e4789dd555f18342f" title="loads a dynmatrix from given CSV file">DynMatrix&lt;T&gt;::loadCSV</a> </dd></dl>

</div>
</div>
<a id="a12cfcf75fdcdffefb3e890594e5f80ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cfcf75fdcdffefb3e890594e5f80ea">&#9670;&nbsp;</a></span>~DynMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::~<a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor (deletes data if no wrapped shallowly) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aee25e09582694b927e4d6b8e0d540ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee25e09582694b927e4d6b8e0d540ca3">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element access with index check </p>

</div>
</div>
<a id="a5d4ec62fb6a2fccecb8a17b541b1dbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4ec62fb6a2fccecb8a17b541b1dbbc">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element access with index check (const) </p>

</div>
</div>
<a id="acebcb8042f1dba49bbd91b87c5b0a6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebcb8042f1dba49bbd91b87c5b0a6c7">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ac9d42828615aac0caac6c29b45a8045f">iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the begin of internal data array </p>

</div>
</div>
<a id="abb558fa575e7b0259286e5ef8d3fb932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb558fa575e7b0259286e5ef8d3fb932">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a91bcd84b01ce44f98685cdb7e9fea845">const_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the begin of internal data array (const) </p>

</div>
</div>
<a id="aad32142b806afd47022dfcc43c10b20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad32142b806afd47022dfcc43c10b20f">&#9670;&nbsp;</a></span>big_matrix_pinv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::big_matrix_pinv </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>zeroThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab7bcb2e89a1a64f18cc3d2c21a33ab2e">GESDD</a>&#160;</td>
          <td class="paramname"><em>gesdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a8c4e508192704d0b034d1fdfbca176a7">CBLAS_GEMM</a>&#160;</td>
          <td class="paramname"><em>cblas_gemm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9fdf2d2f1bb39d2018d3d29062101a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fdf2d2f1bb39d2018d3d29062101a6">&#9670;&nbsp;</a></span>big_matrix_pinv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::big_matrix_pinv </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>zeroThreshold</em> = <code>T(1E-16)</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the Moore-Penrose pseudo-inverse (specialized for big matrices) </p>
<p>Calculate pseudo inverse of given matrix using Intel MKL if possible. Based on singular value decomposition (SVD) and divide &amp; conquer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zeroThreshold</td><td>singular values below threshold are set to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pseudo inverse </dd></dl>

</div>
</div>
<a id="a99d56ad4f15d86d12298ffeb12c9b522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d56ad4f15d86d12298ffeb12c9b522">&#9670;&nbsp;</a></span>col() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html">DynMatrixColumn</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::col </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a shallow copied matrix column. </p>

</div>
</div>
<a id="ae1ddbc1b8a56297b3ee258f2fe1d5789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ddbc1b8a56297b3ee258f2fe1d5789">&#9670;&nbsp;</a></span>col() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html">DynMatrixColumn</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::col </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a608a629c92c25dd56f3f7034c7f9e416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608a629c92c25dd56f3f7034c7f9e416">&#9670;&nbsp;</a></span>col_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix_1_1col__iterator.html">col_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::col_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator running through a certain matrix column </p>

</div>
</div>
<a id="aadfd005234c39f494826dcf1241365f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfd005234c39f494826dcf1241365f0">&#9670;&nbsp;</a></span>col_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#af578b8c18a067c0b4d0b9ac93f0973c7">const_col_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::col_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator running through a certain matrix column (const) </p>

</div>
</div>
<a id="a422c26bbd581e449c8c7c37eefbde97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422c26bbd581e449c8c7c37eefbde97a">&#9670;&nbsp;</a></span>col_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::col_check </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b17a691d44690031937b5f1c3a18b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b17a691d44690031937b5f1c3a18b0d">&#9670;&nbsp;</a></span>col_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix_1_1col__iterator.html">col_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::col_end </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator end of a certain matrix column </p>

</div>
</div>
<a id="ae2c19d3b914d76213dde3c79e34e0308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c19d3b914d76213dde3c79e34e0308">&#9670;&nbsp;</a></span>col_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#af578b8c18a067c0b4d0b9ac93f0973c7">const_col_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::col_end </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator end of a certain matrix column (const) </p>

</div>
</div>
<a id="a06b8be83f6d36b95723daa0403ab4d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b8be83f6d36b95723daa0403ab4d55">&#9670;&nbsp;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>width of the matrix (number of columns) </p>

</div>
</div>
<a id="abda8bb07191dda612b7ee5d802313bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda8bb07191dda612b7ee5d802313bfc">&#9670;&nbsp;</a></span>cond()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::cond </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>p</em> = <code>2</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the condition of a matrix </p>

</div>
</div>
<a id="abb3c14249c627150c0ab794d887e379f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3c14249c627150c0ab794d887e379f">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt;T&gt; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the cross product </p>

</div>
</div>
<a id="a730c7185310fb60477d2d5dd5dad2e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730c7185310fb60477d2d5dd5dad2e5f">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal data pointer </p>

</div>
</div>
<a id="a6e306422c97f10ecbf04d5f7cc3d2815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e306422c97f10ecbf04d5f7cc3d2815">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal data pointer (const) </p>

</div>
</div>
<a id="ab8dfa0494c5ef760be4a2efc6defa307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8dfa0494c5ef760be4a2efc6defa307">&#9670;&nbsp;</a></span>decompose_LU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::decompose_LU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>zeroThreshold</em> = <code>T(1E-16)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>applies LU-decomposition (without using partial pivoting) (only for icl32f and icl64f) </p>
<p>Even though, implementation also works for non-sqared matrices, it's not recommended to apply this function on non-sqared matrices </p>

</div>
</div>
<a id="ad4a98b1ca4c7b1293bf6c80ffff7ae3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a98b1ca4c7b1293bf6c80ffff7ae3e">&#9670;&nbsp;</a></span>decompose_QR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::decompose_QR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>applies QR-decomposition using stabilized Gram-Schmidt orthonormalization (only for icl32f and icl64f) </p>

</div>
</div>
<a id="a94605e7c335033e0ce5aa4bd4b3db106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94605e7c335033e0ce5aa4bd4b3db106">&#9670;&nbsp;</a></span>decompose_RQ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::decompose_RQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>applies RQ-decomposition (by exploiting implemnetation of QR-decomposition) (only for icl32f, and icl64f) </p>

</div>
</div>
<a id="a46dd25df17bfeee9450e469e8ff4b6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46dd25df17bfeee9450e469e8ff4b6ef">&#9670;&nbsp;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::det </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>matrix determinant (only for icl32f and icl64f) </p>

</div>
</div>
<a id="ada56d439c9b3c072d4f3f75ba61ef556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada56d439c9b3c072d4f3f75ba61ef556">&#9670;&nbsp;</a></span>diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt;T&gt; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::diag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns diagonal-elements as column-vector </p>

</div>
</div>
<a id="ae1c06d2247b472fedc05d8894a5fb582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c06d2247b472fedc05d8894a5fb582">&#9670;&nbsp;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>matrix dimension (width*height) or (cols*rows) </p>

</div>
</div>
<a id="a0640d7e91eff9045485519a7c13f2c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0640d7e91eff9045485519a7c13f2c94">&#9670;&nbsp;</a></span>distanceTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::distanceTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the distance of the inner data vectors (linearly interpreted) (IPP accelerated) </p>

</div>
</div>
<a id="af3b738def3285791d129aa3fa776ed1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b738def3285791d129aa3fa776ed1d">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt;T&gt; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the inner product of two matrices (i.e. dot-product) </p>
<p>A.dot(B) is equivalent to A.transp() * B TODO: optimize implementation (current implementation <em>is</em> A.transp() * B) </p>

</div>
</div>
<a id="a2f52db1d603c036c1c6e82b290fe38a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f52db1d603c036c1c6e82b290fe38a2">&#9670;&nbsp;</a></span>eigen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::eigen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the matrix's eigenvalues and eigenvectors. </p>
<p>This function only works on squared symmetric matrices. Resulting eigenvalues are ordered in descending order. The destination matrices' sizes are adapted automatically.</p>
<p>The function is only available for icl32f and icl64f and it is IPP-accelerated in case of having Intel-IPP-Support. The Fallback implementation was basically taken from the Visualization Toolkit VTK (Version 5.6.0)</p>
<p>Note: There is no internal check if the matrix is really symmetric. If it is not symmetric, the behaviour of this function is not predictable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigenvectors</td><td>contains the resulting eigenvectors in it's columns </td></tr>
    <tr><td class="paramname">eigenvalues</td><td>becomes a N-dimensional column vector which ith element is the eigenvalue that corresponds to the ith column of eigenvectors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dbd5129535915f3f75901949e67a419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbd5129535915f3f75901949e67a419">&#9670;&nbsp;</a></span>element_wise_inner_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::element_wise_inner_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inner product of data pointers (not matrix-mulitiplication) </p>
<p>computes the inner-product of data vectors </p>

</div>
</div>
<a id="a4e93701cb0f13ded02812463179cf16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e93701cb0f13ded02812463179cf16f">&#9670;&nbsp;</a></span>elementwise_div() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::elementwise_div </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise matrix multiplication (without destination matrix) [IPP-Supported]. </p>

</div>
</div>
<a id="a9a86f40e987dcd02d5a087d27eed15d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a86f40e987dcd02d5a087d27eed15d3">&#9670;&nbsp;</a></span>elementwise_div() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::elementwise_div </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise division (in source destination fashion) [IPP-Supported]. </p>

</div>
</div>
<a id="a8710e37516d7f38eca87b9ee03bbafec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8710e37516d7f38eca87b9ee03bbafec">&#9670;&nbsp;</a></span>elementwise_mult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::elementwise_mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise matrix multiplication (without destination matrix) [IPP-Supported]. </p>

</div>
</div>
<a id="a9e89bc1d3c71b19048dedcd167f1c4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e89bc1d3c71b19048dedcd167f1c4e0">&#9670;&nbsp;</a></span>elementwise_mult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::elementwise_mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Elementwise matrix multiplication (in source destination fashion) [IPP-Supported]. </p>

</div>
</div>
<a id="acce9e205cd07d91be4bb294f96412e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce9e205cd07d91be4bb294f96412e46">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ac9d42828615aac0caac6c29b45a8045f">iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the end of internal data array </p>

</div>
</div>
<a id="a97b08ebf4a6da0b2cc495ae909989ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b08ebf4a6da0b2cc495ae909989ba7">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a91bcd84b01ce44f98685cdb7e9fea845">const_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator to the end of internal data array (const) </p>

</div>
</div>
<a id="a0837980613fff242363f5c7df9db7648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0837980613fff242363f5c7df9db7648">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::id </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a dim-D identity Matrix </p>

</div>
</div>
<a id="a66254c9de4fba2eb8590450045cef3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66254c9de4fba2eb8590450045cef3d7">&#9670;&nbsp;</a></span>idx_check() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::idx_check </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a092b31ceb564ea137ccd504f6247b0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092b31ceb564ea137ccd504f6247b0ea">&#9670;&nbsp;</a></span>idx_check() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::idx_check </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8411b9f5ee93f2a239cf860b2e9a4a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8411b9f5ee93f2a239cf860b2e9a4a16">&#9670;&nbsp;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::inv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>invert the matrix (only for icl32f and icl64f) </p>

</div>
</div>
<a id="a292d54229b55e288cf7dbd0da744fa09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292d54229b55e288cf7dbd0da744fa09">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns with this matrix has a valid data pointer </p>

</div>
</div>
<a id="a6cf8e311a5f539a1548ed5838f95b300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf8e311a5f539a1548ed5838f95b300">&#9670;&nbsp;</a></span>isSimilar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::isSimilar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tollerance</em> = <code>T(0.0001)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>tests weather a matrix is enough similar to another matrix </p>

</div>
</div>
<a id="a0064a6e67113570e4789dd555f18342f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0064a6e67113570e4789dd555f18342f">&#9670;&nbsp;</a></span>loadCSV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt;T&gt; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::loadCSV </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>loads a dynmatrix from given CSV file </p>
<p>supported types T are all icl8u, icl16s, icl32s, icl32f, icl64f. Each row of the CSV file becomes a matrix row. The column delimiter is ',' Rows, that begin with '#' or with ' ' or that have no length are ignored </p>

</div>
</div>
<a id="a526e164c5d093b6b8b01aeaecb7a249a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526e164c5d093b6b8b01aeaecb7a249a">&#9670;&nbsp;</a></span>mult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix multiplication (in source destination fashion) [IPP-Supported]. </p>

</div>
</div>
<a id="a7de01d1ec4cb7d933217c40b57908862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7de01d1ec4cb7d933217c40b57908862">&#9670;&nbsp;</a></span>mult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply elements with scalar (in source destination fashion) </p>

</div>
</div>
<a id="a9e7ddd429e9ba1d2ae0f8a1c86654470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7ddd429e9ba1d2ae0f8a1c86654470">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::norm </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l</em> = <code>2</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies an L_l norm on the matrix elements (all elements are treated as vector) </p>

</div>
</div>
<a id="ad3dfb53af4a5a0526d8d15427dcbf48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dfb53af4a5a0526d8d15427dcbf48f">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>elementwise comparison (!=) </p>

</div>
</div>
<a id="a4c12abd5a40dddc119ddb7b382f81b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c12abd5a40dddc119ddb7b382f81b16">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element access operator (x,y)-access index begin 0! </p>

</div>
</div>
<a id="a32a09f7862c9afc83821da277b56e1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a09f7862c9afc83821da277b56e1b8">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element access operator (x,y)-access index begin 0! (const) </p>

</div>
</div>
<a id="aa621498523dfda0865ac7fd81be645f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa621498523dfda0865ac7fd81be645f0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Essential matrix multiplication [IPP-Supported]. </p>

</div>
</div>
<a id="a3f43ae818407c4e6ab10a3bfc1cb4195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f43ae818407c4e6ab10a3bfc1cb4195">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply elements with scalar. </p>

</div>
</div>
<a id="aeefd212657e38869cd252df32071818a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefd212657e38869cd252df32071818a">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inplace matrix multiplication applying this = this*m [IPP-Supported] </p>

</div>
</div>
<a id="a86f31cffedde0537c9fd77fba3654d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f31cffedde0537c9fd77fba3654d27">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply elements with scalar (inplace) </p>

</div>
</div>
<a id="ae33e53b2595a345ac950e1d6e8b61b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33e53b2595a345ac950e1d6e8b61b39">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix addition. </p>

</div>
</div>
<a id="abbf1df5b40051a752ff644b173ed6952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf1df5b40051a752ff644b173ed6952">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a scalar to each element </p>

</div>
</div>
<a id="ad5fbdb50dbe12dd2410403f9dbdc2cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fbdb50dbe12dd2410403f9dbdc2cff">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix addition (inplace) </p>

</div>
</div>
<a id="ab9afb7d5e86071b1f2fdbb501d4e7963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9afb7d5e86071b1f2fdbb501d4e7963">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adds a scalar to each element (inplace) </p>

</div>
</div>
<a id="ae4cf2f37ab2e332881231aaa668043b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cf2f37ab2e332881231aaa668043b3">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix substraction. </p>

</div>
</div>
<a id="a0df3f276083ef6ddf06d0da007230b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df3f276083ef6ddf06d0da007230b9c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>substacts a scalar from each element </p>

</div>
</div>
<a id="ae3db8f6686dffc6ab0b57f478d59e517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3db8f6686dffc6ab0b57f478d59e517">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix substraction (inplace) </p>

</div>
</div>
<a id="a19a32515dfd7b51612a090cf5dd01751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a32515dfd7b51612a090cf5dd01751">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>substacts a scalar from each element (inplace) </p>

</div>
</div>
<a id="a4a127fba99451e0062ef7cce514f1cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a127fba99451e0062ef7cce514f1cb7">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inplace matrix devision (calling this/m.inv()) [IPP-Supported] </p>

</div>
</div>
<a id="a7189d560790930eb3799129b56b1a674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7189d560790930eb3799129b56b1a674">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Device elements by scalar. </p>

</div>
</div>
<a id="a9922440d61c4abac17eb47160de5108b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9922440d61c4abac17eb47160de5108b">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inplace matrix devision (calling this/m.inv()) (inplace) </p>

</div>
</div>
<a id="a64a31d1ec360c609e3fbb89a738c5563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a31d1ec360c609e3fbb89a738c5563">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Device elements by scalar (inplace) </p>

</div>
</div>
<a id="a1ba0018db73a7bc063551efd335c8414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba0018db73a7bc063551efd335c8414">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator (using deep/shallow-copy) </p>
<p>In general, the assignment operator applys a deep copy only in case of (*this) is not initialized and other is a shallow copy, (*this) will also become a shallow copy of the data referenced by other </p>

</div>
</div>
<a id="a1fc99de9a8c4d5a4b883af4490567764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc99de9a8c4d5a4b883af4490567764">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicl_1_1math_1_1DynMatrix_1_1DynMatrixColumn.html">DynMatrixColumn</a> &amp;&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adaf3ced1498d6bb7a858e1a0e5c8d48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaf3ced1498d6bb7a858e1a0e5c8d48a">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>elementwise comparison (==) </p>

</div>
</div>
<a id="a69d187d409b26fdb01013258b042e1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d187d409b26fdb01013258b042e1d1">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>linear access to actual data array </p>

</div>
</div>
<a id="af62ab3342979ff658a747f43f6b71abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62ab3342979ff658a747f43f6b71abc">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>linear access to actual data array (const) </p>

</div>
</div>
<a id="a4551b37598970f5ebd64f9a0d4843ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4551b37598970f5ebd64f9a0d4843ff6">&#9670;&nbsp;</a></span>pinv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::pinv </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useSVD</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>zeroThreshold</em> = <code>T(1E-16)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates the Moore-Penrose pseudo-inverse (only implemented for icl32f and icl64f) </p>
<p>Internally, this functions can use either a QR-decomposition based approach, or it can use SVD. QR-Decomposition is already much more stable than the naiv approach pinv(X) = X*(X*X')^(-1) </p><div class="fragment"><div class="line"><a class="code" href="structicl_1_1math_1_1DynMatrix.html#ab0b0fecc4e198b10c72b68a690dc8574">DynMatrix</a> Q,R;</div>
<div class="line"><a class="code" href="structicl_1_1math_1_1DynMatrix.html#ad4a98b1ca4c7b1293bf6c80ffff7ae3e">decompose_QR</a>(Q,R);</div>
<div class="line"><span class="keywordflow">return</span> R.inv() * Q.transp();</div>
</div><!-- fragment --><p> The QR-decomposition based approach does not use the zeroThreshold variable.</p>
<p>If useSVD is set to true, internally an SVD based approach is used:</p>
<p><code> <a class="el" href="structicl_1_1math_1_1DynMatrix.html" title="Highly flexible and optimized matrix class implementation.">DynMatrix</a> S,v,D; svd_dyn(*this,U,s,V);</code></p>
<p><code><a class="el" href="structicl_1_1math_1_1DynMatrix.html" title="Highly flexible and optimized matrix class implementation.">DynMatrix</a> S(s.rows(),s.rows(),0.0f); for(unsigned int i=0;i&lt;s.rows();++i){ S(i,i) = (fabs(s[i]) &gt; zeroThreshold) ? 1.0/s[i] : 0; } return V * S * U.transp(); </code> </p>

</div>
</div>
<a id="a3f6c1ac2738c8735a149d090f05ed7bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6c1ac2738c8735a149d090f05ed7bb">&#9670;&nbsp;</a></span>reshape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::reshape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resets the matrix dimensions without changing the content </p>
<p>This methods can only be used in case of <a class="el" href="structicl_1_1math_1_1DynMatrix.html#a06b8be83f6d36b95723daa0403ab4d55" title="width of the matrix (number of columns)">cols()</a>*rows() equals to newCols*newRows. If this dependency is fulfilled, only the matrix's m_cols and m_rows member variables are adapted according to the new values. The internal data is not touched at all, so the matrix's internal row-major data order is not affected.</p>
<p>This method can particularly be used to cheaply convert a row-vector matrix into a column vector matrix. </p>

</div>
</div>
<a id="ab39db10eaa46b7f2992b305d3d66baa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39db10eaa46b7f2992b305d3d66baa4">&#9670;&nbsp;</a></span>row() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a shallow copied matrix row. </p>

</div>
</div>
<a id="a09c218986527d009f42b206838d0dd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c218986527d009f42b206838d0dd71">&#9670;&nbsp;</a></span>row() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a shallow copied matrix row (const) </p>

</div>
</div>
<a id="a6af74d0695a04804fdfa39aeda79160c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af74d0695a04804fdfa39aeda79160c">&#9670;&nbsp;</a></span>row_begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab270c26102e39f8899f7421bbd15591c">row_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::row_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator running through a certain matrix row </p>

</div>
</div>
<a id="a03a754435395ee39c12b2aa2b4f624ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a754435395ee39c12b2aa2b4f624ae">&#9670;&nbsp;</a></span>row_begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a02dcebb3dacf9da7f15664393146b9d2">const_row_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::row_begin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator running through a certain matrix row (const) </p>

</div>
</div>
<a id="abeb2807e82791f246907cc450d8ae309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb2807e82791f246907cc450d8ae309">&#9670;&nbsp;</a></span>row_check()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::row_check </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a586be79b9c904b87eb5ca6a737cc0686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586be79b9c904b87eb5ca6a737cc0686">&#9670;&nbsp;</a></span>row_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#ab270c26102e39f8899f7421bbd15591c">row_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::row_end </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator of a certains row's end </p>

</div>
</div>
<a id="a6e3c50d646775f493ea284538b043a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3c50d646775f493ea284538b043a64">&#9670;&nbsp;</a></span>row_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html#a02dcebb3dacf9da7f15664393146b9d2">const_row_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::row_end </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an iterator of a certains row's end (const) </p>

</div>
</div>
<a id="a87aa61cb0482e28f53b874999fb5d722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87aa61cb0482e28f53b874999fb5d722">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>height of the matrix (number of rows) </p>

</div>
</div>
<a id="ad6d4769a2a3ea619e53b3ff057a9d2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d4769a2a3ea619e53b3ff057a9d2ba">&#9670;&nbsp;</a></span>saveCSV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::saveCSV </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writes the current matrix to a csv file </p>
<p>supported types T are all icl8u, icl16s, icl32s, icl32f, icl64f </p>

</div>
</div>
<a id="a568f127e1c498e9247e9508adc67146d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568f127e1c498e9247e9508adc67146d">&#9670;&nbsp;</a></span>set_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::set_data </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>newData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sets new data internally and returns old data pointer (for experts only!) </p>

</div>
</div>
<a id="a8a56b7ea708e375e6a68e1cdec2536cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a56b7ea708e375e6a68e1cdec2536cc">&#9670;&nbsp;</a></span>setBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::setBounds </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>holdContent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initializer</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resets matrix dimensions </p>

</div>
</div>
<a id="af3848f54865dc90b0b6addcfe30e3e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3848f54865dc90b0b6addcfe30e3e93">&#9670;&nbsp;</a></span>shallowTransposed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt;T&gt; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::shallowTransposed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a shallow transposed copy of this matrix (dimensions are swapped, data is not re-aranged) </p>

</div>
</div>
<a id="a410ed7757fb3c544f32807825b454788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410ed7757fb3c544f32807825b454788">&#9670;&nbsp;</a></span>shallowTransposed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt;T&gt; <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::shallowTransposed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a shallow transposed copy of this matrix (dimensions are swapped, data is not re-aranged) (const) </p>
<p>This is usually only useful for transposing row- to colume vectors and vice versa. </p>

</div>
</div>
<a id="a2f15be51279fd30075923615167fd45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f15be51279fd30075923615167fd45b">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;lu&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>zeroThreshold</em> = <code>T(1E-16)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solves Mx=b for M=*this (only for icl32f and icl64f) </p>
<p>solves Mx=b using one of the following algorithms </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td></td></tr>
    <tr><td class="paramname">method</td><td>"lu" (default) using LU-decomposition "svd" (using svd-based pseudo-inverse) "qr" (using QR-decomposition based pseudo-inverse) "inv" (using matrix inverse)</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="BENCHM"></a>
Benchmarks</h1>
<p>While LU decomposition based solving provides the worst results, it is also the fastest method in general. Only in case of having very small matrices (e.g. 4x4), other methods are faster. A double precision random N by N system is solved up to an accuracy of about 10e-5 if LU decomposition is used. All other methods provide accuracies of about 10e-14 in case of double precision.</p>
<p>Here are some benchmarks for double precision: 10.000 times 4x4 matrix: inv 16.2 ms lu 26.7 ms qr 105 ms svd 142 ms 10.000 times 5x5 matrix: inv 20.2 ms lu 30.2 ms qr 148 ms svd 131 ms 10.000 times 6x6 matrix: inv 26.9 ms lu 35.6 ms qr 206 ms svd 192 ms 10.000 times 4x4 matrix: inv 448 ms lu 42 ms qr 642 ms svd 237 ms 10.000 times 10x10 matrix: inv 2200 ms lu 75 ms qr 3000 ms svd 495 ms 10 times 50x50 matrix: <b>note: here we have inv and qr in seconds and only 10 trials!</b> inv 5.7 s lu 2.5 ms qr 4.6 s svd 23.4 ms </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zeroThreshold</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39b1c32ead7366cdf9f97bd95c5e61e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b1c32ead7366cdf9f97bd95c5e61e5">&#9670;&nbsp;</a></span>solve_lower_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::solve_lower_triangular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solves Mx=b for M=*this (only if M is a squared lower triangular matrix) (only for icl32f and icl64f) </p>

</div>
</div>
<a id="a8fd5678f404061bf57cec32b1618cc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd5678f404061bf57cec32b1618cc27">&#9670;&nbsp;</a></span>solve_upper_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::solve_upper_triangular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>solves Mx=b for M=*this (only if M is a squared upper triangular matrix) (only for icl32f and icl64f) </p>

</div>
</div>
<a id="aaf2e1590d8196a2131c71146cb7dd44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2e1590d8196a2131c71146cb7dd44d">&#9670;&nbsp;</a></span>sqrDistanceTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::sqrDistanceTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the squared distance of the inner data vectors (linearly interpreted) (IPP accelerated) </p>

</div>
</div>
<a id="aaea77388cac36a51092804540dab5d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea77388cac36a51092804540dab5d73">&#9670;&nbsp;</a></span>stride0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::stride0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns sizeof (T)*dim() </p>

</div>
</div>
<a id="a7fd47232663031e25ca432cf29a7c813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd47232663031e25ca432cf29a7c813">&#9670;&nbsp;</a></span>stride1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::stride1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns sizeof(T)*cols() </p>

</div>
</div>
<a id="a2ba7d61f8e4a06c42b748e6419cd10c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba7d61f8e4a06c42b748e6419cd10c2">&#9670;&nbsp;</a></span>stride2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::stride2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns sizeof (T) </p>

</div>
</div>
<a id="a925d12155ba95dcdeef1fa63834b4326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925d12155ba95dcdeef1fa63834b4326">&#9670;&nbsp;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Singular Value Decomposition of a matrix - decomposes A into USV'. </p>
<p>Internaly, this function will always use double values. Other types are converted internally. This funciton is only instantiated for icl32f and icl64f. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>is filled column-wise with the eigenvectors of AA' </td></tr>
    <tr><td class="paramname">S</td><td>is filled with the singular values of A (s is a ColumnVector and not diagonal matrix) </td></tr>
    <tr><td class="paramname">V</td><td>is filled column-wise with the eigenvectors of A'A (in V, V is stored not V') </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>icl::svd_dyn </dd></dl>

</div>
</div>
<a id="a299d7a07df7e8c36068a319dfaf35a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299d7a07df7e8c36068a319dfaf35a45">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the sum of all diagonal elements </p>

</div>
</div>
<a id="adff0a60ea0fce98cd7fc90b352bb6b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff0a60ea0fce98cd7fc90b352bb6b8f">&#9670;&nbsp;</a></span>transp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1DynMatrix.html">DynMatrix</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::transp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>matrix transposed </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af578b8c18a067c0b4d0b9ac93f0973c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af578b8c18a067c0b4d0b9ac93f0973c7">&#9670;&nbsp;</a></span>const_col_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const typedef <a class="el" href="structicl_1_1math_1_1DynMatrix_1_1col__iterator.html">col_iterator</a> <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::const_col_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>const column iterator typedef </p>

</div>
</div>
<a id="a91bcd84b01ce44f98685cdb7e9fea845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91bcd84b01ce44f98685cdb7e9fea845">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const typedef T* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dafault const_iterator type (just a data-pointer) </p>

</div>
</div>
<a id="a02dcebb3dacf9da7f15664393146b9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02dcebb3dacf9da7f15664393146b9d2">&#9670;&nbsp;</a></span>const_row_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const typedef T* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::const_row_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>complex const_row_iterator type </p>

</div>
</div>
<a id="afcda0bea91c2cc59c89b15a1b22a6e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcda0bea91c2cc59c89b15a1b22a6e11">&#9670;&nbsp;</a></span>m_cols</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::m_cols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8787c2f7082a7134f61706cb590cb3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8787c2f7082a7134f61706cb590cb3b0">&#9670;&nbsp;</a></span>m_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::m_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90a8947dc78624efb508c2ec829781ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a8947dc78624efb508c2ec829781ae">&#9670;&nbsp;</a></span>m_ownData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::m_ownData</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7853efc7ab8f01c03e65a217e1bbe006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7853efc7ab8f01c03e65a217e1bbe006">&#9670;&nbsp;</a></span>m_rows</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structicl_1_1math_1_1DynMatrix.html">icl::math::DynMatrix</a>&lt; T &gt;::m_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/runner/work/icl/icl/ICLMath/src/ICLMath/<a class="el" href="DynMatrix_8h_source.html">DynMatrix.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="astructicl_1_1math_1_1DynMatrix_html_ab0b0fecc4e198b10c72b68a690dc8574"><div class="ttname"><a href="structicl_1_1math_1_1DynMatrix.html#ab0b0fecc4e198b10c72b68a690dc8574">icl::math::DynMatrix::DynMatrix</a></div><div class="ttdeci">DynMatrix()</div><div class="ttdoc">Default empty constructor creates a null-matrix.</div><div class="ttdef"><b>Definition:</b> DynMatrix.h:147</div></div>
<div class="ttc" id="astructicl_1_1math_1_1DynMatrix_html_ad4a98b1ca4c7b1293bf6c80ffff7ae3e"><div class="ttname"><a href="structicl_1_1math_1_1DynMatrix.html#ad4a98b1ca4c7b1293bf6c80ffff7ae3e">icl::math::DynMatrix::decompose_QR</a></div><div class="ttdeci">void decompose_QR(DynMatrix &amp;Q, DynMatrix &amp;R) const</div><div class="ttdoc">applies QR-decomposition using stabilized Gram-Schmidt orthonormalization (only for icl32f and icl64f...</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 14:54:53 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
