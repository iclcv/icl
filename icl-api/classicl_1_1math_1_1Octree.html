<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Image Component Library (ICL): icl::math::Octree&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icl-logo-50.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Image Component Library (ICL)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicl.html">icl</a></li><li class="navelem"><a class="el" href="namespaceicl_1_1math.html">math</a></li><li class="navelem"><a class="el" href="classicl_1_1math_1_1Octree.html">Octree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classicl_1_1math_1_1Octree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">icl::math::Octree&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic <a class="el" href="classicl_1_1math_1_1Octree.html" title="Generic Octree Implementation.">Octree</a> Implementation.  
 <a href="classicl_1_1math_1_1Octree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Octree_8h_source.html">Octree.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1Octree_1_1AABB.html">AABB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">internally used axis-aligned bounding box  <a href="structicl_1_1math_1_1Octree_1_1AABB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1Octree_1_1Allocator.html">Allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inernally used block allocator.  <a href="structicl_1_1math_1_1Octree_1_1Allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structicl_1_1math_1_1Octree_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internally used node structure.  <a href="structicl_1_1math_1_1Octree_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af83fc9ca5813714f046087fc635be593"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#af83fc9ca5813714f046087fc635be593">Octree</a> (const Scalar &amp;minX, const Scalar &amp;minY, const Scalar &amp;minZ, const Scalar &amp;width, const Scalar &amp;height, const Scalar &amp;depth)</td></tr>
<tr class="memdesc:af83fc9ca5813714f046087fc635be593"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> for the given 2D rectangle  <a href="classicl_1_1math_1_1Octree.html#af83fc9ca5813714f046087fc635be593">More...</a><br /></td></tr>
<tr class="separator:af83fc9ca5813714f046087fc635be593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae842778483bfb1863128600a6fae76df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#ae842778483bfb1863128600a6fae76df">Octree</a> (const Scalar &amp;min, const Scalar &amp;len)</td></tr>
<tr class="memdesc:ae842778483bfb1863128600a6fae76df"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> for the given 2D rectangle  <a href="classicl_1_1math_1_1Octree.html#ae842778483bfb1863128600a6fae76df">More...</a><br /></td></tr>
<tr class="separator:ae842778483bfb1863128600a6fae76df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8851505dfe34afbcb94239763dde62e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#a8851505dfe34afbcb94239763dde62e0">~Octree</a> ()</td></tr>
<tr class="memdesc:a8851505dfe34afbcb94239763dde62e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="classicl_1_1math_1_1Octree.html#a8851505dfe34afbcb94239763dde62e0">More...</a><br /></td></tr>
<tr class="separator:a8851505dfe34afbcb94239763dde62e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab774114993b65a27e8a0e4fe016eb52b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structicl_1_1math_1_1Octree_1_1AABB.html">AABB</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#ab774114993b65a27e8a0e4fe016eb52b">getRootAABB</a> () const</td></tr>
<tr class="memdesc:ab774114993b65a27e8a0e4fe016eb52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returs the <a class="el" href="classicl_1_1math_1_1Octree.html" title="Generic Octree Implementation.">Octree</a>'s top-level bounding box  <a href="classicl_1_1math_1_1Octree.html#ab774114993b65a27e8a0e4fe016eb52b">More...</a><br /></td></tr>
<tr class="separator:ab774114993b65a27e8a0e4fe016eb52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b6928550c57ab65b6919483e56df93"><td class="memItemLeft" align="right" valign="top">Pt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#aa3b6928550c57ab65b6919483e56df93">nn_approx</a> (const Pt &amp;p) const</td></tr>
<tr class="memdesc:aa3b6928550c57ab65b6919483e56df93"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an approximated nearst neighbour  <a href="classicl_1_1math_1_1Octree.html#aa3b6928550c57ab65b6919483e56df93">More...</a><br /></td></tr>
<tr class="separator:aa3b6928550c57ab65b6919483e56df93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66c343fefe42c47637ef0a86c34b8be"><td class="memItemLeft" align="right" valign="top">Pt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#ab66c343fefe42c47637ef0a86c34b8be">nn</a> (const Pt &amp;pIn) const</td></tr>
<tr class="memdesc:ab66c343fefe42c47637ef0a86c34b8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the nearest neighbor to the given node  <a href="classicl_1_1math_1_1Octree.html#ab66c343fefe42c47637ef0a86c34b8be">More...</a><br /></td></tr>
<tr class="separator:ab66c343fefe42c47637ef0a86c34b8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c42219f1ccd9afd5eda420543d43858"><td class="memTemplParams" colspan="2">template&lt;class OtherVectorType &gt; </td></tr>
<tr class="memitem:a9c42219f1ccd9afd5eda420543d43858"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#a9c42219f1ccd9afd5eda420543d43858">insert</a> (const OtherVectorType &amp;pIn)</td></tr>
<tr class="memdesc:a9c42219f1ccd9afd5eda420543d43858"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a node into the <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a>  <a href="classicl_1_1math_1_1Octree.html#a9c42219f1ccd9afd5eda420543d43858">More...</a><br /></td></tr>
<tr class="separator:a9c42219f1ccd9afd5eda420543d43858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae85b90edf72e4722e8913ae7b9a169"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator &gt; </td></tr>
<tr class="memitem:a3ae85b90edf72e4722e8913ae7b9a169"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#a3ae85b90edf72e4722e8913ae7b9a169">assign</a> (ForwardIterator begin, ForwardIterator end)</td></tr>
<tr class="memdesc:a3ae85b90edf72e4722e8913ae7b9a169"><td class="mdescLeft">&#160;</td><td class="mdescRight">utilty method to assign new data  <a href="classicl_1_1math_1_1Octree.html#a3ae85b90edf72e4722e8913ae7b9a169">More...</a><br /></td></tr>
<tr class="separator:a3ae85b90edf72e4722e8913ae7b9a169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d66ed92c6f13205fcd12e1f5cfeb8c3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Pt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#a5d66ed92c6f13205fcd12e1f5cfeb8c3">query</a> (const Scalar &amp;minX, const Scalar &amp;minY, const Scalar &amp;minZ, const Scalar &amp;width, const Scalar &amp;height, const Scalar &amp;depth) const</td></tr>
<tr class="memdesc:a5d66ed92c6f13205fcd12e1f5cfeb8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all contained points within the given rectangle  <a href="classicl_1_1math_1_1Octree.html#a5d66ed92c6f13205fcd12e1f5cfeb8c3">More...</a><br /></td></tr>
<tr class="separator:a5d66ed92c6f13205fcd12e1f5cfeb8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae88e0b04589d4abe3fdd6bde6acda96"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Pt &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#aae88e0b04589d4abe3fdd6bde6acda96">queryAll</a> () const</td></tr>
<tr class="memdesc:aae88e0b04589d4abe3fdd6bde6acda96"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all contained points  <a href="classicl_1_1math_1_1Octree.html#aae88e0b04589d4abe3fdd6bde6acda96">More...</a><br /></td></tr>
<tr class="separator:aae88e0b04589d4abe3fdd6bde6acda96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c18a023ff55829ee9fd7f9aee62d01b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#a3c18a023ff55829ee9fd7f9aee62d01b">clear</a> ()</td></tr>
<tr class="memdesc:a3c18a023ff55829ee9fd7f9aee62d01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes all contained points and nodes  <a href="classicl_1_1math_1_1Octree.html#a3c18a023ff55829ee9fd7f9aee62d01b">More...</a><br /></td></tr>
<tr class="separator:a3c18a023ff55829ee9fd7f9aee62d01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae37dff412cd9dd0c31d36195cb0fb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#acae37dff412cd9dd0c31d36195cb0fb1">size</a> () const</td></tr>
<tr class="memdesc:acae37dff412cd9dd0c31d36195cb0fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elments inserted  <a href="classicl_1_1math_1_1Octree.html#acae37dff412cd9dd0c31d36195cb0fb1">More...</a><br /></td></tr>
<tr class="separator:acae37dff412cd9dd0c31d36195cb0fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adf8d557ffe922427bd2324ea3f7a5d66"><td class="memItemLeft" align="right" valign="top">const Pt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#adf8d557ffe922427bd2324ea3f7a5d66">nn_approx_internal</a> (const Pt &amp;p, double &amp;currMinDist, const Pt *&amp;currNN) const</td></tr>
<tr class="memdesc:adf8d557ffe922427bd2324ea3f7a5d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal utility method that is used to find an approximated nearest neighbour  <a href="classicl_1_1math_1_1Octree.html#adf8d557ffe922427bd2324ea3f7a5d66">More...</a><br /></td></tr>
<tr class="separator:adf8d557ffe922427bd2324ea3f7a5d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a5017abaaf12d7818eeb01e25821fc78b"><td class="memItemLeft" align="right" valign="top">static Pt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#a5017abaaf12d7818eeb01e25821fc78b">scale_up</a> (const Pt &amp;p)</td></tr>
<tr class="separator:a5017abaaf12d7818eeb01e25821fc78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaffb6b00ff6cd450ff092e0b69c7b20"><td class="memItemLeft" align="right" valign="top">static Pt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#abaffb6b00ff6cd450ff092e0b69c7b20">scale_down</a> (const Pt &amp;p)</td></tr>
<tr class="separator:abaffb6b00ff6cd450ff092e0b69c7b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477d994d090f4f4b7f61676f7ee10bd3"><td class="memItemLeft" align="right" valign="top">static Pt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#a477d994d090f4f4b7f61676f7ee10bd3">scale_down_1</a> (const Pt &amp;p)</td></tr>
<tr class="separator:a477d994d090f4f4b7f61676f7ee10bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aea478ec29138e97e1351fb74c377d87e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1Octree_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#aea478ec29138e97e1351fb74c377d87e">root</a></td></tr>
<tr class="memdesc:aea478ec29138e97e1351fb74c377d87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">root node pointer  <a href="classicl_1_1math_1_1Octree.html#aea478ec29138e97e1351fb74c377d87e">More...</a><br /></td></tr>
<tr class="separator:aea478ec29138e97e1351fb74c377d87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4199d3777487e3a491656864d7ab7002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structicl_1_1math_1_1Octree_1_1Allocator.html">Allocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#a4199d3777487e3a491656864d7ab7002">alloc</a></td></tr>
<tr class="memdesc:a4199d3777487e3a491656864d7ab7002"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory allocator for all children except for the root node  <a href="classicl_1_1math_1_1Octree.html#a4199d3777487e3a491656864d7ab7002">More...</a><br /></td></tr>
<tr class="separator:a4199d3777487e3a491656864d7ab7002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6061f9b5baf1d18e33d0ff7861d4e459"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicl_1_1math_1_1Octree.html#a6061f9b5baf1d18e33d0ff7861d4e459">num</a></td></tr>
<tr class="memdesc:a6061f9b5baf1d18e33d0ff7861d4e459"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal counter for the number of contained points  <a href="classicl_1_1math_1_1Octree.html#a6061f9b5baf1d18e33d0ff7861d4e459">More...</a><br /></td></tr>
<tr class="separator:a6061f9b5baf1d18e33d0ff7861d4e459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Scalar, int CAPACITY = 16, int SF = 1, class Pt = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt;<br />
class icl::math::Octree&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;</h3>

<p>Generic <a class="el" href="classicl_1_1math_1_1Octree.html" title="Generic Octree Implementation.">Octree</a> Implementation. </p>
<p>The <a class="el" href="classicl_1_1math_1_1Octree.html" title="Generic Octree Implementation.">Octree</a> implementation is a simple 3D-generalization of the <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> class template.</p>
<h1><a class="anchor" id="BENCH"></a>
Benchmarks:</h1>
<p>Even though, we do not have any reliable results, it might be possible, that the octree is much faster then the pcl-octree! </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af83fc9ca5813714f046087fc635be593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83fc9ca5813714f046087fc635be593">&#9670;&nbsp;</a></span>Octree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::<a class="el" href="classicl_1_1math_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> for the given 2D rectangle </p>

</div>
</div>
<a id="ae842778483bfb1863128600a6fae76df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae842778483bfb1863128600a6fae76df">&#9670;&nbsp;</a></span>Octree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::<a class="el" href="classicl_1_1math_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> for the given 2D rectangle </p>

</div>
</div>
<a id="a8851505dfe34afbcb94239763dde62e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8851505dfe34afbcb94239763dde62e0">&#9670;&nbsp;</a></span>~Octree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::~<a class="el" href="classicl_1_1math_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<p>Deletes the root node only, all other nodes are deleted by the allocator </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ae85b90edf72e4722e8913ae7b9a169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae85b90edf72e4722e8913ae7b9a169">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<div class="memtemplate">
template&lt;class ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utilty method to assign new data </p>
<p>Internally, this is implemented using <a class="el" href="classicl_1_1math_1_1Octree.html#a3c18a023ff55829ee9fd7f9aee62d01b" title="removes all contained points and nodes">clear()</a> followed by a for-loop based insertion of all the points. </p>

</div>
</div>
<a id="a3c18a023ff55829ee9fd7f9aee62d01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c18a023ff55829ee9fd7f9aee62d01b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes all contained points and nodes </p>
<p>The allocator will free all memory except for the first CHUNK </p>

</div>
</div>
<a id="ab774114993b65a27e8a0e4fe016eb52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab774114993b65a27e8a0e4fe016eb52b">&#9670;&nbsp;</a></span>getRootAABB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structicl_1_1math_1_1Octree_1_1AABB.html">AABB</a>&amp; <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::getRootAABB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returs the <a class="el" href="classicl_1_1math_1_1Octree.html" title="Generic Octree Implementation.">Octree</a>'s top-level bounding box </p>

</div>
</div>
<a id="a9c42219f1ccd9afd5eda420543d43858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c42219f1ccd9afd5eda420543d43858">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<div class="memtemplate">
template&lt;class OtherVectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const OtherVectorType &amp;&#160;</td>
          <td class="paramname"><em>pIn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts a node into the <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> </p>
<p>This method is also implemented in an iterative fashion for performance issues. 'insert' automatically uses the internal allocator if new nodes are needed. </p>

</div>
</div>
<a id="ab66c343fefe42c47637ef0a86c34b8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66c343fefe42c47637ef0a86c34b8be">&#9670;&nbsp;</a></span>nn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Pt <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::nn </td>
          <td>(</td>
          <td class="paramtype">const Pt &amp;&#160;</td>
          <td class="paramname"><em>pIn</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds the nearest neighbor to the given node </p>
<p>The implementation of this method explicitly avoids recursion by using a run-time stack. This leads to a 4x speed factor in comparison to the recursive implementaiton of this function.</p>
<p>As an extra accelleration, the method initializes it's frist nearest neighbor guess using the nn_approx method, which gives an approximate speed up of factor two to four.</p>
<p>As a 2nd accelleration heuristic, all CAPACITY nodes' distances are are first calculated and compared in a squared version, which can be computed without an expensive square-root operation. However, once the closest point within a single node is found, its real euclidian minimum distance is computed and stored for further bounding box checks.</p>
<p>If no neighbour could be found, an exception is thown. This should actually only happen when nn is called on an empty <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a> </p>

</div>
</div>
<a id="aa3b6928550c57ab65b6919483e56df93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b6928550c57ab65b6919483e56df93">&#9670;&nbsp;</a></span>nn_approx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Pt <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::nn_approx </td>
          <td>(</td>
          <td class="paramtype">const Pt &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an approximated nearst neighbour </p>
<p>While the real nearst neighbour must not neccessarily be in the cell that would theoretically contain p, The approximated one is always assumed to be in that bottom layer cell. If, by chance, the optimal leaf node does not contain any points (because it was just created as empty leaf), the leaf's parent node, which must actually contain CAPACITY points, is used instead. The approximate nearest neighbour search can easily be 5 times as fast as the real nearest neighbor search. The result quality depends on the number of contained points, and on the <a class="el" href="classicl_1_1math_1_1QuadTree.html" title="Generic QuadTree Implementation.">QuadTree</a>'s template parameters </p>

</div>
</div>
<a id="adf8d557ffe922427bd2324ea3f7a5d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8d557ffe922427bd2324ea3f7a5d66">&#9670;&nbsp;</a></span>nn_approx_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Pt&amp; <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::nn_approx_internal </td>
          <td>(</td>
          <td class="paramtype">const Pt &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>currMinDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pt *&amp;&#160;</td>
          <td class="paramname"><em>currNN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal utility method that is used to find an approximated nearest neighbour </p>

</div>
</div>
<a id="a5d66ed92c6f13205fcd12e1f5cfeb8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d66ed92c6f13205fcd12e1f5cfeb8c3">&#9670;&nbsp;</a></span>query()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Pt&gt; <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::query </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>minZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns all contained points within the given rectangle </p>

</div>
</div>
<a id="aae88e0b04589d4abe3fdd6bde6acda96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae88e0b04589d4abe3fdd6bde6acda96">&#9670;&nbsp;</a></span>queryAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Pt&gt; <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::queryAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns all contained points </p>

</div>
</div>
<a id="abaffb6b00ff6cd450ff092e0b69c7b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaffb6b00ff6cd450ff092e0b69c7b20">&#9670;&nbsp;</a></span>scale_down()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Pt <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::scale_down </td>
          <td>(</td>
          <td class="paramtype">const Pt &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a477d994d090f4f4b7f61676f7ee10bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477d994d090f4f4b7f61676f7ee10bd3">&#9670;&nbsp;</a></span>scale_down_1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Pt <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::scale_down_1 </td>
          <td>(</td>
          <td class="paramtype">const Pt &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5017abaaf12d7818eeb01e25821fc78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5017abaaf12d7818eeb01e25821fc78b">&#9670;&nbsp;</a></span>scale_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Pt <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::scale_up </td>
          <td>(</td>
          <td class="paramtype">const Pt &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acae37dff412cd9dd0c31d36195cb0fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae37dff412cd9dd0c31d36195cb0fb1">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>number of elments inserted </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4199d3777487e3a491656864d7ab7002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4199d3777487e3a491656864d7ab7002">&#9670;&nbsp;</a></span>alloc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1Octree_1_1Allocator.html">Allocator</a> <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::alloc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>memory allocator for all children except for the root node </p>

</div>
</div>
<a id="a6061f9b5baf1d18e33d0ff7861d4e459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6061f9b5baf1d18e33d0ff7861d4e459">&#9670;&nbsp;</a></span>num</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::num</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal counter for the number of contained points </p>

</div>
</div>
<a id="aea478ec29138e97e1351fb74c377d87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea478ec29138e97e1351fb74c377d87e">&#9670;&nbsp;</a></span>root</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Scalar , int CAPACITY = 16, int SF = 1, class Pt  = FixedColVector&lt;Scalar,4&gt;, int ALLOC_CHUNK_SIZE = 1024&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structicl_1_1math_1_1Octree_1_1Node.html">Node</a>* <a class="el" href="classicl_1_1math_1_1Octree.html">icl::math::Octree</a>&lt; Scalar, CAPACITY, SF, Pt, ALLOC_CHUNK_SIZE &gt;::root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>root node pointer </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/icl/icl/ICLMath/src/ICLMath/<a class="el" href="Octree_8h_source.html">Octree.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 13 2021 15:28:23 for Image Component Library (ICL) by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
